(function(n){function e(e){for(var o,r,i=e[0],a=e[1],d=e[2],c=0,s=[];c<i.length;c++)r=i[c],p[r]&&s.push(p[r][0]),p[r]=0;for(o in a)Object.prototype.hasOwnProperty.call(a,o)&&(n[o]=a[o]);u&&u(e);while(s.length)s.shift()();return l.push.apply(l,d||[]),t()}function t(){for(var n,e=0;e<l.length;e++){for(var t=l[e],o=!0,r=1;r<t.length;r++){var i=t[r];0!==p[i]&&(o=!1)}o&&(l.splice(e--,1),n=a(a.s=t[0]))}return n}var o={},r={app:0},p={app:0},l=[];function i(n){return a.p+"js/"+({}[n]||n)+"."+{"chunk-26fcfe48":"8f556e16","chunk-2b7c2472":"2ba2edae","chunk-4b1b6550":"211b3ae9","chunk-9385f998":"f150f5e5","chunk-b73103de":"06745afb","chunk-bbc910ea":"01737b40"}[n]+".js"}function a(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(n){var e=[],t={"chunk-26fcfe48":1,"chunk-2b7c2472":1,"chunk-4b1b6550":1,"chunk-9385f998":1,"chunk-b73103de":1,"chunk-bbc910ea":1};r[n]?e.push(r[n]):0!==r[n]&&t[n]&&e.push(r[n]=new Promise(function(e,t){for(var o="css/"+({}[n]||n)+"."+{"chunk-26fcfe48":"7556e9ab","chunk-2b7c2472":"fd0696f5","chunk-4b1b6550":"9cb800dd","chunk-9385f998":"0285d20a","chunk-b73103de":"8c72bfd1","chunk-bbc910ea":"320aa268"}[n]+".css",p=a.p+o,l=document.getElementsByTagName("link"),i=0;i<l.length;i++){var d=l[i],c=d.getAttribute("data-href")||d.getAttribute("href");if("stylesheet"===d.rel&&(c===o||c===p))return e()}var s=document.getElementsByTagName("style");for(i=0;i<s.length;i++){d=s[i],c=d.getAttribute("data-href");if(c===o||c===p)return e()}var u=document.createElement("link");u.rel="stylesheet",u.type="text/css",u.onload=e,u.onerror=function(e){var o=e&&e.target&&e.target.src||p,l=new Error("Loading CSS chunk "+n+" failed.\n("+o+")");l.request=o,delete r[n],u.parentNode.removeChild(u),t(l)},u.href=p;var g=document.getElementsByTagName("head")[0];g.appendChild(u)}).then(function(){r[n]=0}));var o=p[n];if(0!==o)if(o)e.push(o[2]);else{var l=new Promise(function(e,t){o=p[n]=[e,t]});e.push(o[2]=l);var d,c=document.getElementsByTagName("head")[0],s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=i(n),d=function(e){s.onerror=s.onload=null,clearTimeout(u);var t=p[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src,l=new Error("Loading chunk "+n+" failed.\n("+o+": "+r+")");l.type=o,l.request=r,t[1](l)}p[n]=void 0}};var u=setTimeout(function(){d({type:"timeout",target:s})},12e4);s.onerror=s.onload=d,c.appendChild(s)}return Promise.all(e)},a.m=n,a.c=o,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"===typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)a.d(t,o,function(e){return n[e]}.bind(null,o));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="",a.oe=function(n){throw console.error(n),n};var d=window["webpackJsonp"]=window["webpackJsonp"]||[],c=d.push.bind(d);d.push=e,d=d.slice();for(var s=0;s<d.length;s++)e(d[s]);var u=c;l.push([0,"chunk-vendors"]),t()})({0:function(n,e,t){n.exports=t("cd49")},"01e6":function(n,e){n.exports='<p>全局过滤器\n在src目录，新建filter</p>\n<p>在main.js中引入</p>\n<pre><code>import * as filters from &#39;./filters&#39;\n\nObject.keys(filters).forEach(k =&gt; Vue.filter(k, filters[k]))</code></pre><p>一个时间过滤器</p>\n<pre><code>\n/**\n*\n* @export\n* @param {any} time 输入需要转化的时间参数\n* @param {any} format 需要转化的格式\n* @returns 返回处理后的时间格式\n*/\nexport function dateFormat (time, format) {\n  const between = (Date.now() - Number(time)) / 1000\n  if (between &lt; 3600 &amp;&amp; ((between / 60) &lt; 1)) {\n    return &#39;刚刚&#39;\n  } else if (between &lt; 3600) {\n    return pluralize(~~(between / 60), &#39;分钟&#39;)\n  } else if (between &lt; 86400) {\n    return pluralize(~~(between / 3600), &#39;小时&#39;)\n  }\n  if (!time) return null\n  var date = new Date(time)\n  var o = {\n    &#39;M+&#39;: date.getMonth() + 1, // month\n    &#39;d+&#39;: date.getDate(), // day\n    &#39;h+&#39;: date.getHours(), // hour\n    &#39;m+&#39;: date.getMinutes(), // minute\n    &#39;s+&#39;: date.getSeconds(), // second\n    &#39;q+&#39;: Math.floor((date.getMonth() + 3) / 3), // quarter\n    &#39;S&#39;: date.getMilliseconds() // millisecond\n  }\n  let sss = format\n  if (/(y+)/.test(format)) {\n    if (new Date().getFullYear() !== date.getFullYear()) {\n      format = format.replace(RegExp.$1, (date.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length))\n    } else {\n      format = format.replace(RegExp.$1, &#39;&#39;)\n    }\n  }\n  for (var k in o) {\n    if (new RegExp(&#39;(&#39; + k + &#39;)&#39;).test(format)) {\n      format = format.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : (&#39;00&#39; + o[k]).substr((&#39;&#39; + o[k]).length))\n    }\n  }\n  if (/(y+)/.test(sss) &amp;&amp; new Date().getFullYear() === date.getFullYear()) {\n    format = format.substr(1)\n  }\n  return format\n}\n\nfunction pluralize (time, label) {\n  return time + label + &#39;以前&#39;\n}\n</code></pre><p>只在某个文件中的过滤器</p>\n<pre><code>  filters: {\n    chnNum (val) {\n      if (val === 10) return &#39;第十节&#39;\n      var chnNumChar = {\n        0: &#39;早读&#39;,\n        1: &#39;第一节&#39;,\n        2: &#39;第二节&#39;,\n        3: &#39;第三节&#39;,\n        4: &#39;第四节&#39;,\n        5: &#39;第五节&#39;,\n        6: &#39;第六节&#39;,\n        7: &#39;第七节&#39;,\n        8: &#39;第八节&#39;,\n        9: &#39;第九节&#39;\n      }\n      return chnNumChar[val]\n    }\n  }</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-5ef7b8a152426070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<h3 id="-">根据数字里面对象的某个属性，过滤该数组</h3>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-637e4461dc09b9c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},"0228":function(n,e){n.exports='<p>本地缓存\n只能存储字符串的数据，对于JS中常用的数组或对象却不能直接存储。\n需要转换</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-6b20152bc2d14187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<pre><code>\nlet obj = {name: &#39;Tom&#39;};\nlet str = JSON.stringify(obj);\n\n// 存储\nsessionStorage.obj = str;\n//  读取\nstr = sessionStorage.obj\n\nobj = JSON.parse(str)\n\n</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-e8b51709ed1fd448.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<pre><code>// 存储\nsessionStorage.setItem(&#39;str&#39;, obj)\n\n// 读取\nsessionStorage.getItem(&#39;str&#39;)</code></pre>'},"02c5":function(n,e){n.exports='<blockquote>\n<p> with 语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。  </p>\n</blockquote>\n<p>一个简单的例子</p>\n<pre><code>    function Lakers () {\n        this.name = &#39;jike&#39;;\n        this.age = 22;\n        this.gender = &quot;boy&quot;;\n    }\n    let perple = new Lakers();\n    with (perple) {\n        let str = &quot;姓名：&quot; + name + &quot;&lt;br/&gt;&quot;;\n        str += &quot;年龄&quot; + age + &quot;&lt;br/&gt;&quot;;\n        str += &quot;性别&quot; + gender;\n        document.write(str)\n    }\n</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-26b192728cd8dec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},"0309":function(n,e){n.exports='<p><code>vue run build</code>的时候</p>\n<ol>\n<li>提示\n<code>Unexpected token: name (变量名)</code></li>\n</ol>\n<p><img src="https://upload-images.jianshu.io/upload_images/2941543-904efd864ba4d52f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>这个一般是因为<code>UglifyJs</code>不能识别<code>ES6</code>\n也就是说编译的时候，压缩失败了\n具体是为什么，现阶段还不了解，先提供解决办法</p>\n<p>根据报错提示的包文件，通过<code>ctrl + 鼠标左键</code>进行跟踪，找到这个文件</p>\n<p>在网上找一个在线转es5的工具\n<a href="https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=Q&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;sourceType=module&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=">babel</a></p>\n<p>把那个文件里面所有的内容全选在工具转换，然后替换掉原来的文件，就可以了。</p>\n<ol start="2">\n<li>内存溢出</li>\n</ol>\n<pre><code>提示internal字样</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2941543-7a5acc22befb5a78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p><code>package.json</code>文件中修改<code>build</code></p>\n<pre><code>&quot;build&quot;: &quot;node --max_old_space_size=4096 build/build.js&quot;</code></pre>'},"03df":function(n,e){n.exports="<p>理解：</p>\n<p>引用的工程术语，在计算机编程中，shim是一个小型的函数库，用于透明地拦截API调用，修改传递的参数、自身处理操作、或把操作重定向到其他地方。Shim也可以用来在不同的软件平台上运行程序。</p>\n"},"0498":function(n,e){n.exports=""},"0614":function(n,e){n.exports='<h3 id="limit-n-">Limit(n)</h3>\n<p>读取指定数量的数据记录,接受一个数字参数。\n<code>db.col.find().limit(Number)</code></p>\n<h3 id="skip-n-">Skip(n)</h3>\n<p>使用<code>skip()</code>跳过指定数量的数据</p>\n<h3 id="sort-">sort()</h3>\n<p>通过参数指定排序的字段，1为升序， -1为降序。</p>\n<pre><code>db.col.find().sort({KEY:1})</code></pre><h3 id="-">索引</h3>\n<p><code>ensureIndex()</code>创建索引</p>\n<pre><code>db.col.ensureIndex({KEY:1})\n\n1为升序， -1为降序。</code></pre><p>eg:</p>\n<pre><code>复合索引\n\ndb.col.ensureIndex({&quot;title&quot;:1, &quot;likes&quot;:-1})</code></pre><h2 id="-">覆盖索引查询</h2>\n<ul>\n<li><p>所有的查询字段是索引的一部分</p>\n</li>\n<li><p>所有的查询返回字段在同一个索引中</p>\n</li>\n</ul>\n'},"0785":function(n,e){n.exports="<p>根据某个属性值对数组进行排序</p>\n<pre><code>    compare (propertyName) {\n      return (obj1, obj2) =&gt; {\n        let val1 = obj1[propertyName]\n        let val2 = obj2[propertyName]\n        if (val2 &lt; val1) {\n          return 1\n        } else if (val2 &gt; val1) {\n          return -1\n        } else {\n          return 0\n        }\n      }\n    }\n\n使用 \narr.sort(compare(&#39;属性名&#39;))；</code></pre>"},"09dc":function(n,e){n.exports="<p>### </p>\n"},"0f02":function(n,e){n.exports="<p>云计算是通过使计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将与互联网更相似。\n这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。</p>\n<ol>\n<li>运算 存储能力</li>\n<li>大量用户</li>\n<li>基于互联网</li>\n<li>安全性，抵抗攻击</li>\n<li>多端使用 手机电脑...</li>\n</ol>\n<p><strong>特点</strong></p>\n<p>(1) 超大规模</p>\n<p>“云”具有相当的规模，Google云计算已经拥有100多万台服务器，\nAmazon、IBM、微软、Yahoo等的“云”均拥有几十万台服务器。\n企业私有云一般拥有数百上千台服务器。“云”能赋予用户前所未有的计算能力。</p>\n<p>(2) 虚拟化</p>\n<p>云计算支持用户在任意位置、使用各种终端获取应用服务。\n所请求的资源来自“云”，而不是固定的有形的实体。\n应用在“云”中某处运行，但实际上用户无需了解、也不用担心应用运行的具体位置。\n只需要一台笔记本或者一个手机，就可以通过网络服务来实现我们需要的一切，甚至包括超级计算这样的任务。</p>\n<p>(3) 高可靠性</p>\n<p>“云”使用了数据多副本容错、计算节点同构可互换等措施来保障服务的高可靠性，使用云计算比使用本地计算机可靠。</p>\n<p>(4) 通用性</p>\n<p>云计算不针对特定的应用，在“云”的支撑下可以构造出千变万化的应用，同一个“云”可以同时支撑不同的应用运行。</p>\n<p>(5) 高可扩展性</p>\n<p>“云”的规模可以动态伸缩，满足应用和用户规模增长的需要。</p>\n<p>(6) 按需服务</p>\n<p>“云”是一个庞大的资源池，你按需购买；云可以像自来水，电，煤气那样计费。</p>\n<p>(7) 极其廉价</p>\n<p>由于“云”的特殊容错措施可以采用极其廉价的节点来构成云，\n“云”的自动化集中式管理使大量企业无需负担日益高昂的数据中心管理成本，\n“云”的通用性使资源的利用率较之传统系统大幅提升，因此用户可以充分享受“云”的低成本优势，\n经常只要花费几百美元、几天时间就能完成以前需要数万美元、数月时间才能完成的任务。\n云计算可以彻底改变人们未来的生活，但同时也要重视环境问题，这样才能真正为人类进步做贡献,而不是简单的技术提升。</p>\n<p>(8) 潜在的危险性\n云计算服务除了提供计算服务外，还必然提供了存储服务。\n但是云计算服务当前垄断在私人机构（企业）手中，而他们仅仅能够提供商业信用。\n对于政府机构、商业机构（特别像银行这样持有敏感数据的商业机构）对于选择云计算服务应保持足够的警惕。\n一旦商业用户大规模使用私人机构提供的云计算服务，无论其技术优势有多强，都不可避免地让这些私人机构以“数据（信息）”的重要性挟制整个社会。\n对于信息社会而言，“信息”是至关重要的。\n另一方面，云计算中的数据对于数据所有者以外的其他用户云计算用户是保密的，\n但是对于提供云计算的商业机构而言确实毫无秘密可言。所有这些潜在的危险，\n是商业机构和政府机构选择云计算服务、特别是国外机构提供的云计算服务时，不得不考虑的一个重要的前提。</p>\n"},10988:function(n,e){n.exports='<h4 id="-">一、实现一个双向通讯</h4>\n<blockquote>\n<p><code>socket</code>主要有两种方法\n<code>socket.on(&#39;方法名&#39;, &#39;参数&#39;)</code> // 接收数据\n<code>socket.emit(&#39;方法名&#39;, &#39;参数&#39;)</code> // 向服务器 \\ 客户端发送数据</p>\n</blockquote>\n<h6 id="1-">1. 客户端</h6>\n<p>引入</p>\n<pre><code>// 直接下载下来，script引入\n&lt;script type=&quot;text/javascript&quot; src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;\n\n// 推荐\nimport VueSocketio from &#39;vue-socket.io&#39;\n// 在vue中\nVue.use(VueSocketio, &#39;http://localhost:8000&#39;)</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2941543-a3648fa94ba2a69b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="socket.io"></p>\n<blockquote>\n<p>在vue中，通过<code>this.$socket</code>获取socket.io实例</p>\n</blockquote>\n<pre><code>// 自定义methods\n    send () {\n      this.$socket.emit(&#39;send&#39;, &#39;111&#39;)\n    },</code></pre><p>获取返回值</p>\n<pre><code>// mounted () {}\n\n    this.$socket.on(&#39;acc&#39;, msg =&gt; {\n      alert(msg)\n      console.log(1)\n    })</code></pre><h6 id="2-node-">2. 服务端(node)</h6>\n<p>先接收一个<code>http.createServer</code>返回的变量</p>\n<p><img src="https://upload-images.jianshu.io/upload_images/2941543-d856df8bf1cf07bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="socket.io"></p>\n<pre><code>io.on(&#39;connection&#39;, function(socket) {\n    //接收并处理客户端的hi事件\n    socket.on(&#39;acc&#39;, function(data) {\n        console.log(data);\n\n        //触发客户端事件c_hi\n        socket.emit(&#39;事件&#39;,&#39;返回的变量&#39;)\n    })\n\n    //断开事件\n    socket.on(&#39;disconnect&#39;, function(data) {\n        console.log(&#39;断开&#39;,data)\n        socket.emit(&#39;leave&#39;,&#39;离开&#39;);\n        //socket.broadcast用于向整个网络广播(除自己之外)\n        //socket.broadcast.emit(&#39;c_leave&#39;,&#39;某某人离开了&#39;)\n    })\n\n});</code></pre><h4 id="-">二、实现一个简易聊天窗口</h4>\n<h4 id="-websocket">三、websocket</h4>\n<p>使用H5自带的websocket。</p>\n<pre><code>    var host = window.location.host\n    if (location.protocol === &#39;https:&#39;) {\n      var server = &#39;wss://&#39; + host + &#39;/wss&#39;\n    } else {\n      var server = &#39;ws://&#39; + host + &#39;/wss&#39;\n    }\n    console.log(server)\n    this.websock = new WebSocket(server)\n    socket.onopen = function (event) {\n      console.log(&#39;已连接&#39;)\n      socket.send(&#39;来自服务端的消息&#39;)\n    };\n    socket.onmessage = function (event) {\n      console.log(&#39;收到消息&#39;)\n      console.log(event.data)\n    }\n    socket.onclose = function (event) {\n      console.log(&#39;链接失败&#39;)\n      console.log(event.code)\n      console.log(event)\n      let _this = this\n      setTimeout(() =&gt; {\n        _this.initWebSocket()\n      }, 1000)\n    }</code></pre><h6 id="-">实现断开重连机制</h6>\n<p><a href="https://github.com/joewalnes/reconnecting-websocket">git地址</a></p>\n<pre><code>cnpm i reconnecting-websocket\n\n把上面的new WebSocket()\n替换成\nnew ReconnectingWebSocket(&#39;ws://....&#39;)\n\n正常使用默认的参数就可以了</code></pre><ul>\n<li>遇到问题\n<img src="https://upload-images.jianshu.io/upload_images/2941543-e5d3fac7e0998e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="socket"></li>\n</ul>\n<p>链接关闭，event.code = 1006;\n在固定时间内没有通信 就会自动断开<code>TCP</code>链接</p>\n<p>在<code>nginx</code>中设置</p>\n<pre><code>proxy_read_timeout: 默认60s;</code></pre>'},"134c":function(n,e){n.exports="<ul>\n<li>one</li>\n</ul>\n<p><code>main.js</code></p>\n<pre><code>Vue.prototype.$fun = &#39;function&#39;</code></pre><ul>\n<li>two</li>\n</ul>\n<pre><code>let obj = {\n    install (Vue, options) {\n        console.log(Vue) // vue\n        console.log(options) // {a: 1}\n        Vue.prototype.$fun = options\n    }\n}\n\nVue.use(obj, {\n    a: 1\n})</code></pre>"},"13da":function(n,e){n.exports='<p>使用单个标签，实现斜线效果</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-104ccda900a82f9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css斜线效果"></p>\n<p>假定这是一个div,宽高100px;</p>\n<ul>\n<li>方法一：c3旋转缩放</li>\n</ul>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-ea381a416366a3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-fabbac3e496b38e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-f6ff01b28920a675.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css"></p>\n<pre><code>div{\n  position:relative;\n  margin:50px auto;\n  width:100px;\n  height:100px;\n  box-sizing:border-box;\n  border:1px solid #333;  \n}\n\ndiv::before{\n  content:&quot;&quot;;\n  position:absolute;\n  left:0;\n  top:0;\n  width:100%;\n  height:50px;\n  box-sizing:border-box;\n  border-bottom:1px solid deeppink;\n  transform-origin:bottom center;\n  // transform:rotateZ(45deg) scale(1.414);\n  animation:slash 5s infinite ease;\n}</code></pre><ul>\n<li>方法二：线性渐变linear-gradient()</li>\n</ul>\n<p>渐变方向45deg,渐变色依次为transparent -&gt; deeppink -&gt; deeppink -&gt;transparent。</p>\n<pre><code>        div{\n            position:relative;\n            margin:50px auto;\n            width:100px;\n            height:100px;\n            box-sizing:border-box;\n            border:1px solid #333;\n            background:linear-gradient(45deg, transparent 49.5%, deeppink 49.5%, deeppink 50.5%, transparent 50.5%);\n        }</code></pre><ul>\n<li>方法三：伪元素+三角形</li>\n</ul>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-764b43ba3cea36a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css">\n下面一个这样的三角，上面一个白的，盖着他</p>\n<pre><code>三角\n        div::before{\n            content:&quot;&quot;;\n            position:absolute;\n            left:0;\n            bottom:0;\n            width:0;\n            height:0;\n            border:49px solid transparent;\n            border-left:49px solid deeppink;\n            border-bottom:49px solid deeppink;\n        }</code></pre><ul>\n<li>方法四clip-path<pre><code>div {\n  width: 100px;\n  height: 100px;\n  -webkit-clip-path: polygon(0 0, 0 100px, 100px 100px, 0 0);\n  background: deeppink;\n}\n//polygon里面放三个点</code></pre></li>\n</ul>\n<p>完整代码</p>\n<pre><code>body{\n  background:#eee;\n}\ndiv{\n  position:relative;\n  margin:50px auto;\n  width:100px;\n  height:100px;\n  box-sizing:border-box;\n  border:1px solid #333;  \n  background:#fff;\n  line-height:120px;\n  text-indent:5px;\n}\n\ndiv::before{\n  content:&quot;&quot;;\n  position:absolute;\n  left:0;\n  bottom:0;\n  width:0;\n  height:0;\n  border:49px solid transparent;\n  border-left:49px solid deeppink;\n  border-bottom:49px solid deeppink;\n  animation:slash 6s infinite ease;\n}\n\ndiv::after{\n  content:&quot;&quot;;\n  position:absolute;\n  left:0;\n  bottom:0;\n  width:0;\n  height:0;\n  border:48px solid transparent;\n  border-left:48px solid #fff;\n  border-bottom:48px solid #fff;\n  animation:slash2 6s infinite ease;\n}\n\n@keyframes slash{\n  0%{\n    transform:translate(-50px);\n  }\n  30%{\n    transform:translate(0px);\n  }\n  100%{\n    transform:translate(0px);\n  }\n}\n@keyframes slash2{\n  0%{\n    transform:translate(-100px);\n  }\n  30%{\n    transform:translate(-100px);\n  }\n  60%{\n    transform:translate(0px);\n  }\n  100%{\n    transform:translate(0px);\n  }\n}</code></pre>'},1606:function(n,e){n.exports='<h3 id="-mongod-dbpath-c-data">闪退 <code>mongod --dbpath c:\\data</code></h3>\n<p><strong>创建数据库</strong>，如果不存在则创建，否则切换到指定数据库\n<code>use DATABASE_NAME</code></p>\n<p>查看所有数据库\n<code>show dbs</code></p>\n<p>如果是空数据库，就不会显示</p>\n<p>向test数据库插入数据\n<code>db.test.insert({&quot;name&quot;: &quot;hello&quot;})</code></p>\n<p>默认数据库为test，如果没有创建新的数据库，集合将放在test数据库中</p>\n<p><strong>删除数据库</strong>\n<code>db.dropDatabase()</code>\n(删除当前数据库，默认为test)</p>\n<p>常用删除的方法：\n<code>show dbs</code> =&gt; <code>use test</code> =&gt; <code>db.dropDatabase()</code></p>\n<p><strong>删除集合</strong>\n<code>db.collection.drop()</code>\neg: </p>\n<pre><code>use test\n\nshow tables\n\ndb.site.drop() // 集合名为site</code></pre><p><strong>插入文档</strong>(insert()/save())\n<code>db.collection_name.insert(document)</code></p>\n<p>eg:</p>\n<pre><code>db.site.insert({\n  title: &#39;表头&#39;,\n  content: &#39;这是一篇文章&#39;,\n  url: &#39;www.baidu.com&#39;\n})</code></pre><p>没有该数据库，则自动创建，并插入数据</p>\n<p><strong>查看已插入的文档</strong>\n<code>db.collection_name.find()</code></p>\n<pre><code>3.2 版本后还有以下几种语法可用于插入文档:\n\n db.collection.insertOne():向指定集合中插入一条文档数据\n db.collection.insertMany():向指定集合中插入多条文档数据\n#  插入单条数据\n\n&gt; var document = db.collection.insertOne({&quot;a&quot;: 3})\n&gt; document\n{\n        &quot;acknowledged&quot; : true,\n        &quot;insertedId&quot; : ObjectId(&quot;571a218011a82a1d94c02333&quot;)\n}\n\n#  插入多条数据\n&gt; var res = db.collection.insertMany([{&quot;b&quot;: 3}, {&#39;c&#39;: 4}])\n&gt; res\n{\n        &quot;acknowledged&quot; : true,\n        &quot;insertedIds&quot; : [\n                ObjectId(&quot;571a22a911a82a1d94c02337&quot;),\n                ObjectId(&quot;571a22a911a82a1d94c02338&quot;)\n        ]\n}</code></pre><p><strong>更新文档</strong>\n<code>updata()</code></p>\n<pre><code>db.collection.update(\n        &lt;query&gt;,\n        &lt;update&gt;,\n        {\n                upsert: &lt;boolean&gt;,\n                multi: &lt;boolean&gt;,\n                writeConcern: &lt;document&gt;\n        }\n)\n\nquery: update的查询条件\nupdate: update的对象和一些更新的操作符\nupsert: 可选，如果不存在update的记录，是否插入objNew,true为插入，默认false。\nmulti: 可选，默认false，只更新找到第一条记录，（true, 表示把所有符合条件的都更新）\nwriteConcern: 可选，抛出异常的级别</code></pre><p><strong>删除文档</strong>\n<code>remove()</code></p>\n<p>在执行<code>remove()</code>前先执行<code>find()</code>判断执行条件是否正确</p>\n<pre><code>db.collection.remove(\n        &lt;query&gt;, // 删除文档的条件\n        {\n                justOne: &lt;boolean&gt;, // 如果为true或1，则只删除一个文档\n                writeConcern: &lt;document&gt; // 抛出异常的级别\n        }\n)</code></pre><p>eg:\n先插入两条数据\n<img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/Mongo.png" alt="_"></p>\n<p>remove\n<img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/Mongo_remove.png" alt="_"></p>\n<ul>\n<li>如果要删除所有数据<pre><code>db.col.remove({})</code></pre><img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/Mongo_remove_all.png" alt="_"></li>\n</ul>\n<p>remove已out,现在推荐<code>deleteOne()</code>,<code>deleteMany()</code> 方法同remove。</p>\n<p><strong>查询文档</strong>\n<code>find()</code></p>\n<pre><code>db.collection.find(query, projection);\n\nquery: 可选，使用查询操作符指定查询条件\nprojection: 可选， 使用投影操作符指定返回的键</code></pre><ul>\n<li>pretty() 以格式化的方式来显示文档\n<code>db.collection.find().pretty()</code></li>\n</ul>\n<blockquote>\n<p><code>findOne()</code>只返回一个文档</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>格式</th>\n<th>范例</th>\n<th>RDBMS中的类似语句</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>等于</td>\n<td><code>{&lt;key&gt;:&lt;value&gt;}</code></td>\n<td>db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;}).pretty()</td>\n<td>where by = &#39;菜鸟教程&#39;</td>\n</tr>\n<tr>\n<td>小于</td>\n<td><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td>\n<td>db.col.find({&quot;likes&quot;:{$lt:50}}).pretty()</td>\n<td>where likes &lt; 50</td>\n</tr>\n<tr>\n<td>小于或等于</td>\n<td><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td>\n<td>db.col.find({&quot;likes&quot;:{$lte:50}}).pretty()</td>\n<td>where likes &lt;= 50</td>\n</tr>\n<tr>\n<td>大于</td>\n<td><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td>\n<td>db.col.find({&quot;likes&quot;:{$gt:50}}).pretty()</td>\n<td>where likes &gt; 50</td>\n</tr>\n<tr>\n<td>大于或等于</td>\n<td><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td>\n<td>db.col.find({&quot;likes&quot;:{$gte:50}}).pretty()</td>\n<td>where likes &gt;= 50</td>\n</tr>\n<tr>\n<td>不等于</td>\n<td><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td>\n<td>db.col.find({&quot;likes&quot;:{$ne:50}}).pretty()</td>\n<td>where likes != 50</td>\n</tr>\n</tbody></table>\n<ul>\n<li>&amp;&amp;</li>\n</ul>\n<pre><code>db.col.find({key1:value1,key2:value2}).pretty()</code></pre><ul>\n<li>|| 或</li>\n</ul>\n<pre><code>db.col.find({\n        $or: [\n                {key1: value1},\n                {key2: value2}\n        ]\n})</code></pre><p>eg: 查询键 by 值为 菜鸟教程 或键 title 值为 MongoDB 教程 的文档。</p>\n<blockquote>\n<p>db.col.find({$or:[{&quot;by&quot;:&quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()</p>\n</blockquote>\n<p>第二个参数</p>\n<pre><code>db.collection.find(query, {title: 1, by: 1}) // inclusion模式 指定返回的键，不返回其他键\ndb.collection.find(query, {title: 0, by: 0}) // exclusion模式 指定不返回的键,返回其他键\n\n_id 键默认返回，需要主动指定 _id:0 才会隐藏\n\ndb.collection.find(query, {_id:0, title: 1, by: 1})</code></pre><p>eg:</p>\n<pre><code>db.col.find({},{&quot;title&quot;:1,_id:0}).limit(2)\n\n第一个 {} 放 where 条件，为空表示返回集合中所有文档。\n第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。</code></pre>'},"165f":function(n,e){n.exports='<h3 id="-">一、了解</h3>\n<p>mongo 管理员账号有两种，一种是admin用户（可以给所有的数据库设置权限,但不能直接访问某个数据库），另一种是针对特定数据库访问权限的用户（给该用户授权，必须在admin数据库下设置）</p>\n<h3 id="-">二、具体操作</h3>\n<ol>\n<li><p>打开cmd，进入mongodb文件夹下bin目录；</p>\n</li>\n<li><p>mongo.exe；</p>\n</li>\n<li><p>show dbs;</p>\n</li>\n<li><p>use admin；</p>\n</li>\n<li><p>db.createUser({user:&#39;root&#39;, pwd: &#39;password&#39;, roles: [&#39;userAdminAnyDatabase&#39;]});</p>\n</li>\n<li><p>关闭该cmd；</p>\n</li>\n<li><p>新开一个cmd (最好开管理员权限)；</p>\n</li>\n<li><p>mongodb/bin&gt; <strong>mongod --dbpath d:\\data\\db --auth</strong>(有auth启动才会验证管理员，默认不需要身份验证);</p>\n</li>\n<li><p>新开一个cmd， &gt; <code>mongo.exe</code></p>\n</li>\n<li><p>use admin</p>\n</li>\n<li><p>show collections; // 提示无权限，则表示开启了验证</p>\n</li>\n<li><p>db.auth(&#39;root&#39;,&#39;password&#39;) // 验证身份（返回1 表示验证成功， 返回0表示错误）</p>\n</li>\n<li><p>show collections // 正常返回</p>\n</li>\n<li><p>在admin库验证成功，再跳转到其他库，则可以正常访问</p>\n</li>\n<li><p>添加单个数据库管理员：<code>db.createUser({user: &#39;test&#39;, pwd: &#39;123456&#39;, roles: [{role: &#39;dbOwner&#39;, db: &#39;库名&#39;}]})</code>；</p>\n</li>\n<li><p>show roles // 查看当前数据库的所有角色</p>\n</li>\n</ol>\n<h3 id="-">三、附</h3>\n<table>\n<thead>\n<tr>\n<th>权限</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Read：</td>\n<td>允许用户读取指定数据库</td>\n</tr>\n<tr>\n<td>readWrite：</td>\n<td>允许用户读写指定数据库</td>\n</tr>\n<tr>\n<td>dbOwner</td>\n<td>数据库管理员</td>\n</tr>\n<tr>\n<td>dbAdmin：</td>\n<td>允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td>\n</tr>\n<tr>\n<td>userAdmin：</td>\n<td>允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</td>\n</tr>\n<tr>\n<td>clusterAdmin：</td>\n<td>只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</td>\n</tr>\n<tr>\n<td>readAnyDatabase：</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读权限</td>\n</tr>\n<tr>\n<td>readWriteAnyDatabase：</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的读写权限</td>\n</tr>\n<tr>\n<td>userAdminAnyDatabase：</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td>\n</tr>\n<tr>\n<td>dbAdminAnyDatabase：</td>\n<td>只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</td>\n</tr>\n<tr>\n<td>root：</td>\n<td>只在admin数据库中可用。超级账号，超级权限</td>\n</tr>\n<tr>\n<td>backup、restore</td>\n<td>备份恢复</td>\n</tr>\n</tbody></table>\n'},1789:function(n,e){n.exports="<blockquote>\n<p>伪数组： 无法直接调用数组的方法或属性,但仍可以通过数组的遍历遍历方法。</p>\n</blockquote>\n<p>如<code>arguments参数</code>， <code>NodeList</code></p>\n<p>转换为数组的方法：</p>\n<pre><code>Array.prototype.slice.call(arguments); \n\n[].slice.call(arguments);\n</code></pre><p>ES6</p>\n<pre><code>Array.from(arguments);\n\n[...arguments];</code></pre><p>jq</p>\n<pre><code>$.makeArray(arguments);</code></pre>"},"17b4":function(n,e){n.exports="<blockquote>\n<p>const声明一个只读的常量，即常量的值不能被改变，如果改变就会报错</p>\n<pre><code>     const a=10;\n     a=100;//报错</code></pre></blockquote>\n<ul>\n<li><p>作用域：与let命令相同，只在声明所在的块级作用域内有效</p>\n<pre><code>  // if(true){\n  //     const foo=5;\n  // }\n  // console.log(foo);//报错</code></pre></li>\n<li><p>同样不能提升，存在暂时性死区，只能在声明的位置后面使用</p>\n<pre><code>  // if(true){\n      // console.log(foo);\n      // const foo=5;\n  // }</code></pre></li>\n<li><p>不能重复声明，同let</p>\n<pre><code>  // const foo={};\n  // foo.prop=123;\n  // console.log(foo.prop);//123\n  // foo={};//报错\n  // 对象本身是可变的，依然可以为其添加新属性。但是不能重新赋值</code></pre><blockquote>\n<p>冻结对象的方法</p>\n</blockquote>\n</li>\n</ul>\n<pre><code>const foo=Object.freeze({});\nfoo.prop=123;//在常规模式下，不起作用，严格模式报错。</code></pre><ul>\n<li>除了冻结对象本身，对象的属性也可以冻结<pre><code> var constantize=(obj)=&gt;{\n     Object.freeze(obj);//冻结obj\n     Object.keys(obj).forEach((key,value)=&gt;{\n         if(typeof obj[key]===&#39;object&#39;){\n             constantize(obj[key]);\n         }\n      })\n }</code></pre></li>\n</ul>\n<blockquote>\n<p>ES6中声明变量的方法:var function const let class import;</p>\n</blockquote>\n<p>####顶层对象</p>\n<blockquote>\n<p>在浏览器指window对象，在node指的是global对象，ES5中顶层对象的属性与全局变量是等价的</p>\n</blockquote>\n<blockquote>\n<p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\nES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>\n</blockquote>\n<pre><code>    // var a=1;\n    // 若在node的repl环境中，可也写成global.a\n    //通用的this.a\n    // console.log(window.a);//1\n\n    // let b=1;\n    // console.log(window.b);//undefined</code></pre><blockquote>\n<p>同一段代码，若想拿到顶层对象，一般我们会想到用this方法，但是它是有局限性的\n全局环境中，this.会返回顶层对象，但是node和ES6返回当前所在模块</p>\n</blockquote>\n<pre><code>    // (function (){\n    //     console.log(this)//window,在严格模式下会报错\n    // }())</code></pre><blockquote>\n<p>若非要获取的话，引用system.global库拿到global；保证在各种环境下global对象都是存在的</p>\n<pre><code>    require(&#39;system.global/shim&#39;)();</code></pre><p>ES6写法</p>\n<pre><code>    import shim form &#39;system.global/shim&#39;;shim();</code></pre></blockquote>\n"},"17eb":function(n,e){n.exports='<h2 id="vue-markdown">vue中读取markdown</h2>\n<ol>\n<li>webpack配置</li>\n</ol>\n<pre><code class="language-js">  {\n    test: /\\.md$/,\n    use: [\n      {\n        loader: &quot;html-loader&quot;\n      },\n      {\n        loader: &quot;markdown-loader&quot;,\n        options: {\n        }\n      }\n    ]\n  }</code></pre>\n<ol start="2">\n<li>安装依赖</li>\n</ol>\n<p><code>npm i markdown-loader html-loader --save-dev</code></p>\n<ol start="3">\n<li>引入</li>\n</ol>\n<pre><code class="language-js">import md from &#39;./abc.md&#39;\ndata () {\n  return {\n    md\n  }\n}</code></pre>\n<h1 id="vue3-0">vue3.0</h1>\n<p><code>/node_modules/@vue/cli-service/lib/config/base.js</code></p>\n<pre><code class="language-js">    webpackConfig.module\n      .rule(&#39;md&#39;)\n        .test(/\\.md$/)\n        .use(&#39;html-loader&#39;)\n          .loader(&#39;html-loader&#39;)\n          .end()\n        .use(&#39;markdown-loader&#39;)\n          .loader(&#39;markdown-loader&#39;)</code></pre>\n<pre><code>const files = require.context(&quot;./markdown&quot;, true, /\\.md$/);\nconst modules = {};\n\nfiles.keys().forEach((key) =&gt; {\n  modules[key.replace(/(\\.\\/|\\.md)/g, &quot;&quot;)] = files(key);\n});\n\nexport default modules;\n</code></pre>'},"182c":function(n,e){n.exports='<p><a href="http://www.echartsjs.com">echarts官网</a></p>\n<p><strong>Question 1： 数据堆叠</strong></p>\n<p>数据堆叠，同个类目轴上系列配置相同的stack值后，后一个系列的值会在前一个系列的值上相加。</p>\n<p><img src="http://cdn.jsan.top//echarts/20181114181426.png" alt="数据堆叠"></p>\n<p><img src="http://cdn.jsan.top//echarts/20181114181426%20%281%29.png" alt="数据堆叠"></p>\n<p>删除这个属性，就会正常显示；</p>\n<p><strong>Question 2： x轴显示倾斜</strong></p>\n<pre><code>        xAxis: {\n            type: &#39;category&#39;,\n            axisLabel: {\n                rotate: 30\n            },\n        },</code></pre><p><strong>Question 3： 修改标题</strong></p>\n<pre><code>        title: {\n            text: &#39;&#39;\n        },</code></pre><p><strong>Question 4： x轴 是否从起始位置开始</strong></p>\n<pre><code>    xAxis: {\n        boundaryGap: false, // 从起始位置\n    },</code></pre><p><strong>Question 5： 多条线名称</strong></p>\n<p>图例组件展现了不同系列的标记，颜色和名字。可以通过点击图例控制哪些系列不显示。</p>\n<pre><code>    legend: {\n        data:[&#39;邮件营销&#39;,&#39;联盟广告&#39;]\n    },\n\n\n    需要和series中name对应\n</code></pre><p><strong>Question 6： GL</strong></p>\n<p><a href="http://echarts.baidu.com/examples/editor.html?c=bar3d-simplex-noise&amp;gl=1&amp;theme=dark">http://echarts.baidu.com/examples/editor.html?c=bar3d-simplex-noise&amp;gl=1&amp;theme=dark</a></p>\n'},"1a37":function(n,e,t){var o={"./CSS/css3.md":"d2f1","./CSS/getStyle.md":"a400","./CSS/grid.md":"fe36","./CSS/ie浏览器-输入框自带删除.md":"c428","./CSS/transform形变.md":"957f","./CSS/一些好看的font-family.md":"9ec1","./CSS/多列布局.md":"e096","./CSS/多行（省略号）显示.md":"6910","./CSS/字体消除锯齿.md":"909b","./CSS/实现css斜线.md":"13da","./CSS/帧动画.md":"5419","./CSS/弹层-滚动条.md":"494c","./CSS/弹性布局flex.md":"7924","./CSS/新闻导航条.md":"2535","./CSS/无标题文章.md":"4bc8","./CSS/禁止复制选中文本.md":"975b","./CSS/绝对定位下的样式修改.md":"9656","./CSS/表格属性.md":"a78f","./ES6/Class.md":"b3bf","./ES6/Generator.md":"371c","./ES6/Promise.md":"fe3d","./ES6/Set对象.md":"fbe2","./ES6/const.md":"17b4","./ES6/let.md":"3459","./ES6/rem.md":"c0be","./ES6/字符串.md":"38c3","./ES6/概述1.md":"2540","./ES6/概述2.md":"852a","./ES6/箭头函数和普通函数的区别.md":"e69f","./Koa/package.md":"6cf9","./MongoDB/README.md":"378b","./MongoDB/deep/MapReduce.md":"8d92","./MongoDB/deep/ObjectId.md":"9e93","./MongoDB/deep/全文索引.md":"da6d","./MongoDB/deep/原子操作.md":"97f7","./MongoDB/deep/可视化.md":"8635","./MongoDB/deep/固定集合.md":"bd1d","./MongoDB/deep/数据库引用.md":"e36f","./MongoDB/install.md":"44e8","./MongoDB/mongo +管理员账号  修改端口.md":"165f","./MongoDB/nginx.md":"8115","./MongoDB/分页获取指定数量.md":"0614","./MongoDB/命令.md":"1606","./MongoDB/备份恢复.md":"fdf6","./MongoDB/条件操作符.md":"d651","./MongoDB/检测性能.md":"44e0","./MongoDB/概念.md":"c740","./MongoDB/聚合.md":"7140","./architect/1概念.md":"0498","./architect/2云计算.md":"0f02","./architect/3IaaS.md":"363b","./architect/4PaaS.md":"7626","./architect/5趋势.md":"f923","./architect/README.md":"ab6a","./components/qrcode-vue.md":"8535","./http/cors.md":"f1a8","./http/ngrok.md":"ae1b","./http/socket.io.md":"10988","./http/免费ssl申请.md":"3ddc","./http/本地启动跨域调试.md":"aaa1","./http/跨域.md":"3500","./images/readme.md":"d288","./jq/jquery AJAX.md":"8e7d","./jq/jquery 事件.md":"09dc","./jq/jquery 其他.md":"d476","./jq/jquery 动画.md":"e4a8","./jq/jquery 方法.md":"3ad9","./jq/jquery 选择器.md":"30e8","./jq/jquery 遍历.md":"a395","./jq/事件委托的区别.md":"8b11","./mac/root.md":"a597","./nginx/代理node.md":"b2e1","./nibuzhidaodejs/DOM0 DOM2添加事件.md":"6d66","./nibuzhidaodejs/Date().md":"d8d5","./nibuzhidaodejs/NaN-及-数值转换.md":"e759","./nibuzhidaodejs/Object对象.md":"34d4","./nibuzhidaodejs/caller与callee区别.md":"ae55","./nibuzhidaodejs/for-循环demo.md":"ebeb","./nibuzhidaodejs/jsonp.md":"b1c3","./nibuzhidaodejs/js阻止冒泡.md":"7a47","./nibuzhidaodejs/local sessionStorage.md":"0228","./nibuzhidaodejs/object类型.md":"d418","./nibuzhidaodejs/print.md":"9f7a","./nibuzhidaodejs/script.md":"28ca","./nibuzhidaodejs/with语句.md":"02c5","./nibuzhidaodejs/伪数组.md":"1789","./nibuzhidaodejs/保存下载图片.md":"9298","./nibuzhidaodejs/原型链.md":"d81a","./nibuzhidaodejs/垃圾回收.md":"ce62","./nibuzhidaodejs/数组迭代.md":"8989","./nibuzhidaodejs/闭包.md":"a534","./nibuzhidaodejs/面向对象.md":"a2e7","./node/koa install.md":"7de5","./node/了解.md":"9c26","./node/正则.md":"6b5a","./other/README.md":"de4f","./other/run.md":"3095","./other/will.md":"fe7b","./other/图片剪切上传.md":"8029","./sql/install.md":"1cde","./ts/语法.md":"1d41","./vue/$emit.md":"a194","./vue/$ref.md":"77b2","./vue/UI/iVIew.md":"d00b","./vue/axios-class-vuex-querystring.md":"91c9","./vue/build.md":"e632","./vue/cli@3.0.0.md":"342d","./vue/computed实现.md":"8742","./vue/elementUI-scss.md":"477e","./vue/elementUI按需引入.md":"ff0c","./vue/filter.md":"01e6","./vue/framework7.md":"9121","./vue/highlight.md":"1e90","./vue/lodash.js.md":"d42c","./vue/lodash使用.md":"f3e8","./vue/markdown.md":"17eb","./vue/new nuxt.md":"c1ec","./vue/npm run build遇到的问题.md":"0309","./vue/nuxt.md":"1e5a","./vue/router.md":"2c48","./vue/shim.md":"03df","./vue/vue-angular-react区别.md":"62e2","./vue/vue.js.md":"7985","./vue/vue本地修改自定义域名.md":"c739","./vue/watch_set_delete.md":"84fd","./vue/上传文件之前判断格式.md":"e2c2","./vue/全局api.md":"a82a","./vue/刷新页面不跳转.md":"3a0e","./vue/富文本编辑器.md":"9d3a","./vue/小结.md":"c194","./vue/更新数组.md":"464c","./vue/添加行内样式.md":"b16d","./vue/生命周期.md":"2fb5","./vue/监听路由.md":"99ef","./vue/组件.md":"c7b0","./vue/组件懒加载.md":"36b2","./vue/绑定到实例上的方法.md":"134c","./webpack/require.context.md":"2e28","./以太坊/learn web3.js.md":"d7a9","./以太坊/生成以太坊二维码 转地址.md":"6501","./其他/MD5/README.md":"48a4","./其他/RxJS.md":"2659","./其他/angularJS.md":"298a","./其他/dll.md":"5379","./其他/echarts bar3D 打印.md":"f538","./其他/echarts.md":"182c","./其他/echarts和highchart的区别.md":"8698","./其他/md语法.md":"d6e7","./其他/react.md":"651e","./其他/代码优化.md":"ad47","./其他/网站统计.md":"bb40","./其他/面试.md":"38ab","./兼容/input iphone边框问题.md":"ba93","./正则/回车替换成换行.md":"bce5","./正则/常用的一些正则.md":"9085","./正则/正则表达式.md":"ec44","./算法/数组去重.md":"a7da","./算法/数组排序.md":"d263","./算法/比较器.md":"0785"};function r(n){var e=p(n);return t(e)}function p(n){var e=o[n];if(!(e+1)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return e}r.keys=function(){return Object.keys(o)},r.resolve=p,n.exports=r,r.id="1a37"},"1cde":function(n,e){n.exports='<p><a href="https://dev.mysql.com/downloads/mysql/">download zip:</a></p>\n<pre><code>链接：https://pan.baidu.com/s/1eTn6hCQ 密码：ea5x</code></pre><p>1)、把 mysql-5.7.19-winx64.zip 压缩文件解压到 C:\\MySQL\\ 目录下；</p>\n<p>2)、在 C:\\MySQL\\ 目录下新建 my.ini 配置文件；</p>\n<p>3)、用文本编辑器或其他编辑器打开 my.ini 文件，把以下代码复制粘贴进去，保存退出；</p>\n<p>#代码开始</p>\n<pre><code>[Client]\n#设置3306端口\nport = 3306\n[mysqld]\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir=C:\\mysql\n# 设置mysql数据库的数据的存放目录\ndatadir=C:\\mysql\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为8比特编码的latin1字符集\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8</code></pre><p>#代码结束</p>\n<p>4)、配置环境变量；</p>\n<p>4.1、新建系统变量 MYSQL_HOME ，并配置变量值为 C:\\mysql ；</p>\n<p>4.2、编辑系统变量 Path ，将 ;%MYSQL_HOME%\\bin 添加到 Path 变量值后面。</p>\n<p>5)、以管理员身份运行命令提示符cmd（一定要用管理员身份运行，不然权限不够）；</p>\n<p>5.1、使用dos指令，进入C:\\mysql 目录，运行以下指令</p>\n<pre><code>mysqld --defaults-file=my.ini --initialize-insecure\nmysqld --install\nnet start mysql\n</code></pre><p>5.2、设置 mysql 的 root 密码，运行以下指令</p>\n<pre><code>mysql -u root -p\nuse mysql;\nupdate user set authentication_string=password(&#39;您的密码&#39;) where user=&#39;root&#39;;\nflush privileges;\n\nexit\n</code></pre><p><strong>安装配置完成</strong></p>\n'},"1d41":function(n,e){n.exports="<p>向小郭同志学习</p>\n<pre><code>let i: number = 1\n\nlet text: string = &#39;abc&#39;\n\nlet isTrue: boolean = true\n\n...\n\n</code></pre><p>使用<code>tsc + 文件名</code>进行编译</p>\n"},"1e5a":function(n,e){n.exports='<h2 id="-elementui">安装ElementUI</h2>\n<p><code>nuxt.config.js</code></p>\n<pre><code>module.exports = {\n  /*\n  ** Headers of the page\n  */\n  css: [\n    &#39;element-ui/lib/theme-chalk/index.css&#39;\n  ],\n  head: {\n    title: &#39;{{ name }}&#39;,\n    meta: [\n      { charset: &#39;utf-8&#39; },\n      { name: &#39;viewport&#39;, content: &#39;width=device-width, initial-scale=1&#39; },\n      { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;{{escape description }}&#39; }\n    ],\n    link: [\n      { rel: &#39;icon&#39;, type: &#39;image/x-icon&#39;, href: &#39;/favicon.ico&#39; }\n    ]\n  },\n  /*\n  ** Customize the progress bar color\n  */\n  loading: { color: &#39;#3B8070&#39; },\n  /*\n  ** Build configuration\n  */\n  build: {\n    /*\n    ** Run ESLint on save\n    */\n    vendor: [\n      &#39;axios&#39;,\n      &#39;element-ui&#39;\n    ],\n    babel: {\n      // plugins: [[&#39;component&#39;, [{\n      //   libraryName: &#39;element-ui&#39;,\n      //   styleLibraryName: &#39;theme-default&#39;\n      // }]]]\n    },\n    extend (config, { isDev, isClient }) {\n      if (isDev &amp;&amp; isClient) {\n        config.module.rules.push({\n          enforce: &#39;pre&#39;,\n          test: /\\.(js|vue)$/,\n          loader: &#39;eslint-loader&#39;,\n          exclude: /(node_modules)/\n        })\n      }\n    }\n  },\n  plugins: [&#39;~plugins/element-ui&#39;]\n}\n</code></pre><p><code>plugins/element-ui</code></p>\n<pre><code>import Vue from &#39;vue&#39;\nimport ElementUI from &#39;element-ui&#39;\n\nVue.use(ElementUI)\n</code></pre>'},"1e90":function(n,e){n.exports="<p>新建<code>.js</code>文件</p>\n<pre><code>import Hljs from &#39;highlight.js&#39;\nimport &#39;highlight.js/styles/googlecode.css&#39;\nlet Highlight = {}\nHighlight.install = function (Vue, options) {\n  Vue.directive(&#39;highlight&#39;, function (el) {\n    // let blocks = el.querySelectorAll(&#39;pre code&#39;)\n    // blocks.forEach((block) =&gt; {\n    //   Hljs.highlightBlock(block)\n    // })\n    Hljs.initHighlightingOnLoad()\n  })\n}\n\nexport default Highlight\n</code></pre><p><code>main.js</code>中</p>\n<pre><code>import Highlight from &#39;&lt;path&gt;/highlight&#39;\nVue.use(Highlight)</code></pre>"},2535:function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-463e6a93cfbb6a7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>使用box布局</p>\n<pre><code>&lt;li class=&quot;li&quot;&gt;\n    ![](img/1.png)\n    &lt;div class=&quot;left&quot;&gt;主题门票&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;10&lt;/div&gt;\n&lt;/li&gt;\n\nli {\n    margin-left: 45px;\n    height: 44px;\n    display: -webkit-box; //box布局并做好兼容\n    display: box;\n    position: relative;\n}\n\n\n.left {\n    -webkit-box-flex: 1; //box-flex:1控制宽度自适应\n    box-flex: 1;\n    text-align: left;\n    line-height: 45px;\n    font-size: 16px;\n    color: #333;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.right {    //右侧啥都不用管\n    text-align: right;\n    line-height: 45px;\n    font-size: 12px;\n    color: #999;\n    padding-left: 10px;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>'},2540:function(n,e){n.exports='<blockquote>\n<p>ECMAScript 6，也叫 ES6 或 ES2015。\ufeff</p>\n</blockquote>\n<blockquote>\n<p>JavaScript 自 1995 年面世,1997 年成立的 ECMAScript 引领着 JavaScript 的发展。已发布的版本 ES3、 ES5、 ES6 。</p>\n</blockquote>\n<ul>\n<li>JavaScript 进化史</li>\n</ul>\n<blockquote>\n<p>ES3 与 ES5 之间隔了 10 年，而ES5 与 ES6 之间隔了 6 年。改进的新模式是每年都渐进式地做一些小改动，而不是像 ES6 一样一次性地进行大量的更改。</p>\n</blockquote>\n<ul>\n<li>浏览器支持</li>\n</ul>\n<blockquote>\n<p>大部分都已可以使用</p>\n</blockquote>\n<h3 id="es6-">ES6 新增优势</h3>\n<blockquote>\n<ul>\n<li>块级作用域变量<strong>let</strong>    <strong>const</strong>   </li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<p> var 定义的变量会泄露到其它代码块，比如 for 循环或是 if 块。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>（详见let和const语法）</p>\n</blockquote>\n</blockquote>\n<ul>\n<li>#####IIFE</li>\n</ul>\n<p>在ES5中</p>\n<pre><code>\n{\n\n var private = 1;\n\n}\n\nconsole.log(private); // 1</code></pre><blockquote>\n<p>private 会发生泄漏。需要使用 IIFE（立即执行函数表达式）将其包起来：</p>\n</blockquote>\n<pre><code>\n(function(){\n\n var private2 = 1;\n\n})();\n\nconsole.log(private2); // Uncaught ReferenceError</code></pre><blockquote>\n<p>jQuery等开源项目的源代码，它们都利用了 IIFE，以避免污染全局环境，而只在全局下定义 _、$或是 jQuery。</p>\n</blockquote>\n<p>而在ES6中</p>\n<pre><code>{\n\n let private3 = 1;\n\n}\n\nconsole.log(private3); // Uncaught ReferenceError</code></pre><blockquote>\n<p>Const表示定义了一个常量，更改值，会报错</p>\n</blockquote>\n<ul>\n<li><h5 id="-">文本模板</h5>\n</li>\n</ul>\n<p>ES5</p>\n<pre><code>\nvar first = &#39;Adrian&#39;;\n\nvar last = &#39;Mejia&#39;;\n\nconsole.log(&#39;Your name is &#39; + first + &#39; &#39; + last + &#39;.&#39;);</code></pre><p>ES6可以用 反引号 和字符串插值 ${}：</p>\n<pre><code>const first = &#39;Adrian&#39;;\n\nconst last = &#39;Mejia&#39;;\n\nconsole.log(`Your name is ${first} ${last}.`);</code></pre><ul>\n<li><p>多行字符串也同样可以使用反引号连接</p>\n</li>\n<li><p>ES6 解构非常简明并且好用</p>\n</li>\n</ul>\n<p>ES5</p>\n<pre><code>var array = [1, 2, 3, 4];\n\nvar first = array[0];\n\nvar third = array[2];\n\nconsole.log(first, third); // 1 3</code></pre><p>等同于：</p>\n<p>ES6</p>\n<pre><code>const array = [1, 2, 3, 4];\n\nconst [first, ,third] = array;\n\nconsole.log(first, third); // 1 3</code></pre><ul>\n<li>调换值</li>\n</ul>\n<p>ES5</p>\n<pre><code>var a = 1;\n\nvar b = 2;\n\nvar tmp = a;\n\na = b;\n\nb = tmp;\n\nconsole.log(a, b); // 2 1</code></pre><p>等同于</p>\n<p>ES6</p>\n<pre><code>let a = 1;\n\nlet b = 2;\n\n[a, b] = [b, a];\n\nconsole.log(a, b); // 2 1</code></pre><ul>\n<li>返回多个值</li>\n</ul>\n<p>ES5</p>\n<pre><code>function margin() {\n\n var left=1, right=2, top=3, bottom=4;\n\n return { left: left, right: right, top: top, bottom: bottom };\n\n}\n\nvar data = margin();\n\nvar left = data.left;\n\nvar bottom = data.bottom;\n\nconsole.log(left, bottom); // 1 4\n\n在第3行，也可以像这样用数组返回（并保存序列）：\n\nreturn [left, right, top, bottom];\n\n但之后调用时需要考虑返回数据的顺序。\n\nvar left = data[0];\n\nvar bottom = data[3];</code></pre><p>ES6 中调用时只会选择需要的数据（第 6 行）：</p>\n<pre><code>1. function margin() {\n\n2  const left=1, right=2, top=3, bottom=4;\n\n3  return { left, right, top, bottom };\n\n4 }\n\n5 const { left, bottom } = margin();\n\n6 console.log(left, bottom); // 1 4\n\n</code></pre><blockquote>\n<p>注意：第3行用到了一些其它的 ES6 功能。可以将 { left: left } 简化为 { left }.</p>\n</blockquote>\n<p>参数匹配解构</p>\n<p>ES5</p>\n<pre><code>var user = {firstName: &#39;Adrian&#39;, lastName: &#39;Mejia&#39;};\n\nfunction getFullName(user) {\n\n var firstName = user.firstName;\n\n var lastName = user.lastName;\n\n return firstName + &#39; &#39; + lastName;\n\n}\n\nconsole.log(getFullName(user)); // Adrian Mejia\n</code></pre><p>ES6</p>\n<pre><code>const user = {firstName: &#39;Adrian&#39;, lastName: &#39;Mejia&#39;};\n\nfunction getFullName({ firstName, lastName }) {\n\n return `${firstName} ${lastName}`;\n\n}\n\nconsole.log(getFullName(user)); // Adrian Mejia</code></pre><p>深度匹配</p>\n<p>ES5</p>\n<pre><code>function settings() {\n\n return { display: { color: &#39;red&#39; }, keyboard: { layout: &#39;querty&#39;} };\n\n}\n\nvar tmp = settings();\n\nvar displayColor = tmp.display.color;\n\nvar keyboardLayout = tmp.keyboard.layout;\n\nconsole.log(displayColor, keyboardLayout); // red querty\n\n</code></pre><p>ES6</p>\n<pre><code>function settings() {\n\n return { display: { color: &#39;red&#39; }, keyboard: { layout: &#39;querty&#39;} };\n\n}\n\nconst { display: { color: displayColor }, keyboard: { layout: keyboardLayout }} = settings();\n\nconsole.log(displayColor, keyboardLayout); // red querty</code></pre><p>使用数组解构获取元素或调换变量，这样就不用创建临时引用了。</p>\n<p>对于多返回值的情况，不要用数组解构，用对象解构。</p>\n<ul>\n<li>类和对象</li>\n</ul>\n<p>ES6 用“类”替代“构造函数”。</p>\n<blockquote>\n<p>在 JavaScript 中，每个对象都有原型对象。所有 JavaScript 对象都从原型上继承方法和属性。</p>\n</blockquote>\n<p>ES5 以面向对象编程的方式创建对象，是利用构造函数实现的：</p>\n<p>ES5</p>\n<pre><code>var Animal = (function () {\n\n function MyConstructor(name) {\n\n   this.name = name;\n\n }\n\n MyConstructor.prototype.speak = function speak() {\n\n   console.log(this.name + &#39; makes a noise.&#39;);\n\n };\n\n return MyConstructor;\n\n})();\n\nvar animal = new Animal(&#39;animal&#39;);\n\nanimal.speak(); // animal makes a noise.</code></pre><blockquote>\n<p>ES6 可以用 class、constructor 等新的关键字、更少的样板代码实现相同的效果。同样可以看到相比于constructor.prototype.speak = function ()，用 speak() 定义方法更加清晰：</p>\n</blockquote>\n<p>ES6</p>\n<pre><code>class Animal {\n\n constructor(name) {\n\n   this.name = name;\n\n }\n\n speak() {\n\n   console.log(this.name + &#39; makes a noise.&#39;);\n\n }\n\n}\n\nconst animal = new Animal(&#39;animal&#39;);\n\nanimal.speak(); // animal makes a noise.</code></pre><blockquote>\n<p>用 class 语法，避免直接操作 prototype.</p>\n</blockquote>\n<blockquote>\n<p>避免出现空的构造器。如果没有指明，类会有默认的构造器的。</p>\n</blockquote>\n<ul>\n<li>继承</li>\n</ul>\n<blockquote>\n<p>基于前面的 Animal 类，现在想要拓展 Animal，定义一个 Lion 类。</p>\n</blockquote>\n<p>ES5</p>\n<pre><code>var Lion = (function () {\n\n function MyConstructor(name){\n\n   Animal.call(this, name);\n\n }\n\n MyConstructor.prototype = Object.create(Animal.prototype);\n\n MyConstructor.prototype.constructor = Animal;\n\n MyConstructor.prototype.speak = function speak() {\n\n   Animal.prototype.speak.call(this);\n\n   console.log(this.name + &#39; roars &#39;);\n\n };\n\n return MyConstructor;\n\n})();\n\nvar lion = new Lion(&#39;Simba&#39;);\n\nlion.speak(); // Simba makes a noise.\n\n// Simba roars.</code></pre><p>ES6</p>\n<pre><code>class Lion extends Animal {\n\n speak() {\n\n   super.speak();\n\n   console.log(this.name + &#39; roars &#39;);\n\n }\n\n}\n\nconst lion = new Lion(&#39;Simba&#39;);\n\nlion.speak(); // Simba makes a noise.\n\n// Simba roars.\n\n</code></pre><p>使用内置的 extends 实现继承。</p>\n<p>原生 Promise</p>\n<p>用 promise 替代回调地狱</p>\n<p>ES5</p>\n<pre><code>function printAfterTimeout(string, timeout, done){\n\n setTimeout(function(){\n\n   done(string);\n\n }, timeout);\n\n}\n\nprintAfterTimeout(&#39;Hello &#39;, 2000, function(result){\n\n console.log(result);\n\n // nested callback\n\n printAfterTimeout(result + &#39;Reader&#39;, 2000, function(result){\n\n   console.log(result);\n\n });\n\n});\n</code></pre><blockquote>\n<p>这个函数接收一个回调，在 done 后执行。我们想要先后执行两次，所以在回调中又一次调用了 printAfterTimeout。</p>\n</blockquote>\n<p>如果需要多次回调。用 promise 实现</p>\n<p>ES6</p>\n<pre><code>function printAfterTimeout(string, timeout){\n\n return new Promise((resolve, reject) =&gt; {\n\n   setTimeout(function(){\n\n     resolve(string);\n\n   }, timeout);\n\n });\n\n}\n\nprintAfterTimeout(&#39;Hello &#39;, 2000).then((result) =&gt; {\n\n console.log(result);\n\n return printAfterTimeout(result + &#39;Reader&#39;, 2000);\n\n}).then((result) =&gt; {\n\n console.log(result);\n\n});</code></pre><ul>\n<li>箭头函数</li>\n</ul>\n<blockquote>\n<p>ES6 没有移除函数表达式，但是新增了箭头函数。</p>\n</blockquote>\n<p>ES5 this的指向</p>\n<pre><code>var _this = this; // \n\n$(&#39;.btn&#39;).click(function(event){\n\n _this.sendData(); // reference outer this\n\n});\n\n$(&#39;.input&#39;).on(&#39;change&#39;,function(event){\n\n this.sendData(); // reference outer this\n\n}.bind(this)); // bind to outer this</code></pre><p>在函数内，需要用临时变量指向 this 或者使用 bind 绑定。ES6 中可以使用箭头函数。</p>\n<p>For…of</p>\n<p>最开始用 for ，然后使用 forEach，而现在可以用 for…of：</p>\n<p>ES6</p>\n<pre><code>\n$(&#39;.btn&#39;).click((event) =&gt;  this.sendData());\n\n// implicit returns\n\nconst ids = [291, 288, 984];\n\nconst messages = ids.map(value =&gt; `ID is ${value}`);\n</code></pre><p>ES6 的 for…of 也可以用来迭代。</p>\n<p>默认参数</p>\n<p>之前需要检测变量是否定义了，而现在可以指定 default parameters 的值。</p>\n<p>ES5</p>\n<pre><code>function point(x, y, isFlag){\n\n x = x || 0;\n\n y = y || -1;\n\n isFlag = isFlag || true;\n\n console.log(x,y, isFlag);\n\n}\n\npoint(0, 0) // 0 -1 true//我们传的值是 0, 0 但是得到的是 0, -1\n\n\npoint(0, 0, false) // 0 -1 true//传进去 false 但是得到的是 true。\n\npoint(1) // 1 -1 true\n\npoint() // 0 -1 true\n</code></pre><blockquote>\n<p>这可能是检测变量有值或指定默认值的惯用模式，但也存在一些问题：</p>\n</blockquote>\n<p>ES6</p>\n<pre><code>function point(x = 0, y = -1, isFlag = true){\n\n console.log(x,y, isFlag);\n\n}\n\n\npoint(0, 0) // 0 0 true\n\n\npoint(0, 0, false) // 0 0 false\n\n\npoint(1) // 1 -1 true\n\n\npoint() // 0 -1 true\n</code></pre><p>ES5 是因为先要检测 undefined的值，而 false、 null、 undefined 和 0 都是假的值。我们可以加些代码：</p>\n<p>ES5</p>\n<pre><code>function point(x, y, isFlag){\n\n x = x || 0;\n\n y = typeof(y) === &#39;undefined&#39; ? -1 : y;\n\n isFlag = typeof(isFlag) === &#39;undefined&#39; ? true : isFlag;\n\n console.log(x,y, isFlag);\n\n}\n\npoint(0, 0) // 0 0 true\n\npoint(0, 0, false) // 0 0 false\n\npoint(1) // 1 -1 true\n\npoint() // 0 -1 true\n</code></pre><blockquote>\n<p>现在当检测 undefined 值时就符合我们的要求了。</p>\n</blockquote>\n<p>之前使用 arguments，而现在可以用展开操作符。</p>\n<p>现在可以用展开操作符 ... 达到相同的目的。</p>\n<p>ES6</p>\n<pre><code>function printf(format, ...params) {\n\n console.log(&#39;params: &#39;, params);\n\n console.log(&#39;format: &#39;, format);\n\n}\n\nprintf(&#39;%s %d %.2f&#39;, &#39;adrian&#39;, 321, Math.PI);\n`</code></pre><p>展开操作符...</p>\n<p>之前用 apply()，现在可以方便地使用展开操作符 ... 了：</p>\n<p>提示：apply() 可以将数组转化为一系列参数。例如 Math.max() 接收一系列参数，但如果想应用于数组的话可以用 apply 帮助实现。</p>\n<p>如上所述，apply 可以将数组当作参数序列进行传递：</p>\n<p>ES5</p>\n<pre><code>Math.max.apply(Math, [2,100,1,6,43]) // 100</code></pre><p>ES6 可以用展开操作符：</p>\n<p>ES6</p>\n<blockquote>\n<p>\ufeff<code>Math.max(...[2,100,1,6,43]) // 100</code></p>\n</blockquote>\n<p> concat 合并数组，现在也可以用展开操作符：</p>\n<p>ES5</p>\n<pre><code>var array1 = [2,100,1,6,43];\n\nvar array2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n\nvar array3 = [false, true, null, undefined];\n\nconsole.log(array1.concat(array2, array3));</code></pre><p>ES6 可以用展开操作符展开嵌套的数组：</p>\n<p>ES6</p>\n<blockquote>\n</blockquote>\n<p>const array1 = [2,100,1,6,43];</p>\n<blockquote>\n<p>const array2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];</p>\n</blockquote>\n<blockquote>\n<p>const array3 = [false, true, null, undefined];</p>\n</blockquote>\n<blockquote>\n<p>console.log([...array1, ...array2, ...array3])</p>\n</blockquote>\n'},2659:function(n,e){n.exports='<h1 id="-rxjs-">什么是RxJS?</h1>\n<h2 id="-">一、简介（异步编程）</h2>\n<p>源自微软的JS脚本，针对异步数据流的编程。它将所有的数据（http，DOM，或普通数据等）包装成流的形式。</p>\n<p>流以<code>Observable</code>对象呈现，获取数据需要订阅<code>Observable</code>，\n可以理解成封装的<code>Promise</code>对象</p>\n<h2 id="-">二、核心</h2>\n<ul>\n<li><p>Observable</p>\n</li>\n<li><p>Observer</p>\n</li>\n<li><p>Operator</p>\n</li>\n</ul>\n<p>数据在<code>Observable</code>中保存，通过各种<code>operator</code>对流进行处理</p>\n'},"28ca":function(n,e){n.exports='<ul>\n<li>属性：async,表示应该立即下载脚本，但不妨碍页面中其他操作。\ndefer：表示脚本可以延迟到文档被完全解析和显示以后执行，只对外部脚本文件有限。\ntype：表示编写代码使用脚本语言的内容类型，也称为MIME类型。</li>\n</ul>\n<p>注：不建议使用单标签。\n  每个使用src属于的script标签中不能包含额外的js代码，否则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p>\n<ul>\n<li>解析顺序\n只要不存在defer和async属性，浏览器会根据其在页面中出现的先后顺序依次解析。</li>\n</ul>\n<h4 id="-">延迟脚本</h4>\n<pre><code>&lt;script src=&quot;&quot; defer=&quot;defer&quot; &gt;&lt;/script&gt;</code></pre>'},"298a":function(n,e){n.exports='<p>AngularJS通过使用标识符的结构，让浏览器能够识别一些新的语法。如：\n  使用双大括号{{}}语法进行数据绑定；\n  使用DOM控制结构来实现迭代或者隐藏DOM片段；\n  支持表单和表单的验证；\n  能将逻辑代码关联到相关的DOM元素上；\n  能将HTML分组成可重用的组件。</p>\n<p>不适合使用的地方：\n不常使用CRUD（增Create、删Delete、改Update、查Retrieve）的地方</p>\n<p>引入js</p>\n<pre><code>&lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&gt;&lt;/script&gt;</code></pre><h5 id="-angular-">安装angular的命令</h5>\n<ol>\n<li>npm init  //做初始化</li>\n<li>ls    查看</li>\n<li>npm install --save angular  //安装angular</li>\n<li>npm install --save angular-route  //安装路由</li>\n</ol>\n<p>###架构：</p>\n<ul>\n<li>指令</li>\n<li>config</li>\n<li>controller</li>\n<li>过滤器</li>\n<li>服务</li>\n</ul>\n<p>###一、指令</p>\n<blockquote>\n<p>又分为内置指令和自定义指令</p>\n</blockquote>\n<p>常用指令：\n1.<code>ng-app</code>表示在其所在的标签上，应用angularJs，一般放在跟标签html上，由于是单页应用，所以ng-app只需要写一个</p>\n<pre><code>&lt;html ng-app=&quot;app&quot;&gt;</code></pre><p>2.<code>ng-init</code>做变量的初始化</p>\n<pre><code>&lt;div ng-init=&quot;a=100;b=2&quot;&gt;\n    &lt;h1&gt;{{a}}&lt;/h1&gt;\n    &lt;h1&gt;{{a+b}}&lt;/h1&gt;\n&lt;/div&gt;</code></pre><p>3.加载两种方法</p>\n<pre><code>&lt;h1&gt;{{a}}{{b}}&lt;/h1&gt;\n或\n&lt;h1 ng-bind=&quot;a&quot;&gt;&lt;/h1&gt;\n&lt;h1 ng-bind=&quot;b&quot;&gt;&lt;/h1&gt;\n</code></pre><p>区别：如果在后面加载js文件，{{}}会先把原样式加载出来，(即：在页面显示{{a}})，等js加载结束才会更改内容，所以可能会在页面闪一下，而ng-bind则会等到js加载结束才显示</p>\n<p>4.事件绑定</p>\n<pre><code>&lt;div ng-init=&quot;a=&#39;abc&#39;;&quot;&gt;\n    &lt;h1&gt;{{a}}&lt;/h1&gt;\n    &lt;input ng-model=a /&gt;\n&lt;/div&gt;</code></pre><p>在input中任意输入内容，在h1中就会自己动态更改内容，即事件绑定</p>\n<p>5.ng-if:true显示；false隐藏\n可以代替display:none;</p>\n<pre><code>&lt;div ng-controlller=&#39;ctrl&#39;&gt;\n    &lt;div ng-if=&quot;flag&quot;&gt;\n        {{name}}\n    &lt;/div&gt;\n    &lt;input type=&quot;button&quot; value=&quot;button&quot; ng-model=&quot;flag&quot; ng-click=&#39;change()&#39; /&gt;\n&lt;/div&gt;\n\njs代码：\n    angular.module(&#39;app&#39;,[])\n    .controller(&#39;ctrl&#39;,function($scope){\n        $scope.flag=true;\n        $scope.name=&quot;aaa&quot;;\n        $scope.change=function(){\n            console.log($scope.flag);\n            $scope.flag=!$scope.flag;\n        }\n    })</code></pre><p>6.ng-show=&quot;true&quot;显示\n  ng-hide=&quot;true&quot;隐藏</p>\n<p>7.ng-repeat=&quot;x in arr track by $index&quot;\n根据下标遍历，下标不会重复，在下面有具体代码解释。</p>\n<p>8.ng-class\n9.ng-view配合路由使用；\n10.$rootScope()添加全局变量，用法同$scope\n11.ng-model</p>\n<ul>\n<li>自定义指令</li>\n</ul>\n<p>先自定义一个最简单的指令</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function(){})\n.directive(&#39;myHeader&#39;,function(){\n    //使用directive来自定义指令\n    return {\n        restrict:&quot;E&quot;,\n        template:&#39;&lt;h1&gt;你好&lt;/h1&gt;&#39;\n    }\n})\n\n\n在html中，就可以直接使用&lt;my-header&gt;&lt;/my-header&gt;标签，\n</code></pre><p>restrict有4个值：\nE(element) C(class) M(注释) A(attribute)；\ntemplate也可以写成templateUrl,后面加文件路径</p>\n<p>使用方法相同</p>\n<p>当restrict：‘M’时，需要加一个属性</p>\n<pre><code>    .directive(&#39;hi&#39;,function(){\n        return {\n            restrict:&#39;E&#39;,\n            replace:true,\n            template:&#39;&lt;h2&gt;hhhh&lt;/h2&gt;&#39;\n        }\n    })\n这样注释才能在页面显示出来</code></pre><p>加replace和不加的区别：\n不加的话直接显示<my-header></my-header>，在标签里面才是我们需要的，加上replace:true,就会把自定义标签去掉</p>\n<p>如果要在自定义标签内做嵌套，直接写到自定义标签里面，也不会显示，需要在代码中同意嵌套,在嵌套元素加一个属性ng-transclude</p>\n<pre><code>    .directive(&#39;myHeader&#39;,function(){\n        return {\n            restrict:&quot;E&quot;,\n            // template:&#39;&lt;h1&gt;你好&lt;/h1&gt;&#39;\n            transclude:true,//表示同意嵌套\n            template:&#39;&lt;h1 ng-transclude&gt;nihao&lt;/h1&gt;&#39;\n        //做嵌套时就会把元素都嵌套在这里\n        }\n    })\n\n`</code></pre><p>自定义指令的目的，一般是为了把重复的代码用自定义指令封装起来，使用的使用，传进相应的参数，就能得到自己想要的</p>\n<pre><code>    angular.module(&#39;app&#39;,[])\n    .directive(&#39;myHeader&#39;,function(){\n        return {\n            restrict:&quot;E&quot;,\n            replace:true,\n            scope:{//做配置\n                title:&#39;@&#39;,//表明title数据类型是一个字符串\n                name:&#39;=&#39;//表明name是一个变量\n                show:&#39;$&#39;//函数方法\n            },\n            template:&#39;&lt;div&gt;&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;/div&gt;&#39;,\n        }\n    })\n\n\n在html里面放进该自定义标签\n&lt;my-header title=&quot;首页&quot;&gt;&lt;/my-header&gt;\n&lt;my-header title=&quot;分类&quot;&gt;&lt;/my-header&gt;\n&lt;my-header title=&quot;购物车&quot;&gt;&lt;/my-header&gt;\n&lt;my-header title=&quot;我的&quot;&gt;&lt;/my-header&gt;</code></pre><p>把上面的代码完善一下</p>\n<pre><code>    &lt;my-header title=&quot;name&quot; name=&quot;name&quot; show=&quot;show(111)&quot;&gt;asdlkfjdsalfjsadlk&lt;/my-header&gt;\n    &lt;my-header title=&quot;分类&quot;  name=&quot;name&quot; show=&quot;show(222)&quot;&gt;&lt;/my-header&gt;\n    &lt;my-header title=&quot;购物车&quot; name=&quot;name&quot; show=&quot;show(333)&quot;&gt;&lt;/my-header&gt;\n\n\n提供name,show方法\n    angular.module(&#39;app&#39;,[])\n    .controller(&#39;ctrl&#39;,function($scope){\n        $scope.name=&quot;变量&quot;;\n        $scope.show=function(arg){\n            console.log(&#39;this is function show&#39;+arg)\n        }\n    })\n.directive(&#39;myHeader&#39;,function(){\n        return {\n            restrict:&quot;E&quot;,\n            replace:true,\n            scope:{\n                title:&#39;@&#39;,//表明title数据类型是一个字符串\n                name:&#39;=&#39;,//表示name是一个变量\n                show:&#39;&amp;&#39;//函数方法\n            },\n            template:&#39;&lt;div ng-click=&quot;show()&quot;&gt;&lt;h1&gt;{{title}}{{name}}&lt;/h1&gt;&lt;/div&gt;&#39;,\n            link:function($scope,$element,$attrs){\n                // console.log($scope);\n                // console.log($element);\n                // console.log($attrs);\n                console.log($attrs.title);\n                console.log($attrs.name);\n                console.log($attrs.show);\n                $element.bind(&#39;click&#39;,function(){\n                    // console.log(&#39;a&#39;)\n                    console.log(this)\n                    this.style.backgroundColor=&quot;red&quot;;\n                })\n                $element.on(&#39;touchstart&#39;,function(e){\n                    console.log(e)\n                })\n            }\n        }\n    })</code></pre><p>link提供了三个参数，用来控制和修改自定义的指令</p>\n<pre><code>.directive(&#39;myHeader&#39;,function(){\n        // 如果里面只有一个link的function，那么就可以简写成下面的\n        return function($scope,$element,$attrs){\n            console.log($scope)\n            $element.bind(&#39;click&#39;,function(){\n                console.log(this)\n                this.style.backgroundColor=&quot;red&quot;;\n            })\n        }\n    })</code></pre><h3 id="-controller-">二、controller控制器</h3>\n<ol>\n<li>需要先定义模块</li>\n</ol>\n<pre><code>var app=angular.module(&#39;app&#39;,[]);\n第一个参数是名称\n第二个参数是依赖\n\napp.controller(&#39;ctrl&#39;,function($scope){\n    $scope.b=200;\n    $scope.c=&#39;hello angular&#39;;\n    $scope.arr=[1,2,3,4,5];\n    $scope.show=function(){\n        return  &#39;&#39;神奇动物在哪里&quot;;\n    }\n})\n\n\n在html中，要引入ctrl:\n&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    &lt;h1&gt;{{b}}&lt;/h1&gt;\n    &lt;h1&gt;{{c}}&lt;/h1&gt;\n    &lt;h1&gt;{{arr}}&lt;/h1&gt;\n    &lt;h1&gt;{{show()}}&lt;/h1&gt;\n&lt;/div&gt;</code></pre><p>写一个具体的案例，定义一个div，点击变色</p>\n<pre><code>css样式\n.red{width:100px;height:100px;background:red;}\n.green{width:100px;height:100px;background:green;}\n\nhtml:\n&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    &lt;div ng-class=&quot;myclass&quot; ng-click=&quot;change()&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n\njs代码：\nangular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope){\n   $scope.myclass=&#39;green&#39;;\n   $scope.change=function(){\n       $scope.myclass=$scope.myclass==&#39;green&#39;?&#39;red&#39;:&#39;green&#39;;\n   }\n})</code></pre><p>2.作用域</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope,$rootScope){\n    $scope.brand=&quot;cp&quot;;\n    $rootScope.age=18;\n\n})\n.controller(&#39;ctrl2&#39;,function($scope){\n    $scope.say=function($scope,$rootScope){\n      return &#39;nnnnn&#39;\n    }\n    $rootScope.speak = function(){\n      return &quot;hello angular&quot;\n    }\n})\n\n添加一个$rootScope ,就可以在页面任意位置输出\n{{age}}//在页面正常显示\n{{brand}}//超出作用域，不显示\n&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    {{age}}\n    {{brand}}//两个都显示\n    &lt;div ng-controller=&quot;ctrl2&quot;&gt;\n            //在这里都可以正常显示\n    &lt;/div&gt;\n&lt;/div&gt;\n总结：在哪个标签调用控制器方法，就只能在该div里面显示，若想要在外面显示，可以在更外层标签调用控制器，或使用$rootScope;</code></pre><p>3.$watch、$apply方法监听</p>\n<p>双向数据绑定:\nng-model--&gt;$scope.name--&gt;{{name}}\nng-model常出现在input中，监听内容变化</p>\n<p>脏机制查询，须手动触发，$digest或使用timeout</p>\n<pre><code>html:\n&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    &lt;h1&gt;{{name}}&lt;/h1&gt;\n&lt;/div&gt;\n\njs:\nangular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope,$timeout){\n    $scope.name=&quot;小明&quot;;\n\n    $scope.$watch(&#39;name&#39;,function(newvalue,oldvalue,scope){\n        console.log(&#39;新值：&#39;+newvalue);\n        console.log(&#39;旧值：&#39;+oldvalue);\n        console.log(&quot;scope&quot;+scope.name)\n    },false)\n    $timeout(function(){\n        $scope.name=&quot;小红&quot;;\n    },2000)\n})\n效果：h1中的小明，经过2s自动切换成小红；</code></pre><blockquote>\n<p>$watch和$timeout都是库中封装的方法，直接调用就可以。\n$watch()有3个参数，第一个表示要检测的目标；第二个参数类似于callback的函数，当检测的目标发生变化时执行；第三个参数是布尔值，表示是否进行深度监听，true表示深度监听；\n其中第二个参数function(){}又有三个参数，分别是(&#39;新值：&#39;+newvalue)(&#39;旧值：&#39;+oldvalue)(&quot;scope&quot;+scope.name)；\n如果监听一般的字符串等时，不需要深度监听，就能检测到，当监听的是对象时，就需要进行深度监听才能检测到它内部的变化\n$timeout是已经封装好的延时计时器，用法和原生的一样；还有$interval\n如果要使用原生的演示器，并且效果不变时，就需要借助$apply方法，代码如下：</p>\n<pre><code>setTimeout(function(){\n    $scope.$apply(function(){\n        $scope.name=&#39;小红&#39;;\n    })\n},2000)</code></pre></blockquote>\n<p>就上面案例中，$watch事件列举一个监听的对象，第三个参数是true的小案例；</p>\n<pre><code>&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    &lt;h1&gt;{{brand.name}}&lt;/h1&gt;\n    &lt;input ng-model=&quot;brand.name&quot;&gt;\n&lt;/div&gt;\n\nangular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope){\n    $scope.brand={\n        name:&#39;hello&#39;,\n        age:18\n    }\n\n    $scope.$watch(&#39;brand&#39;,function(newvalue,oldvalue,scope){\n        console.log(&#39;新值：&#39;+newvalue);\n        console.log(&#39;旧值：&#39;+oldvalue);\n        console.log(&quot;scope&quot;+scope.name);\n    },true)\n    //最后一个参数必须是true,否则检测不到里面的变化，就不能打印到控制台\n})\n\n\n</code></pre><h3 id="-config">三、config</h3>\n<p>配置</p>\n<h3 id="-">四、过滤器</h3>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope){\n    $scope.price=998;\n    $scope.time=new Date();\n    $scope.arr=[\n            {name:&#39;abc&#39;,age:100},\n            {name:&#39;def&#39;,age:20},\n            {name:&#39;ghi&#39;,age:15},\n            {name:&#39;jkl&#39;,age:43},\n            {name:&#39;mno&#39;,age:27}\n        ]\n})</code></pre><ul>\n<li>currency货币过滤currency:&#39;$&#39;；</li>\n</ul>\n<pre><code>&lt;h1&gt;{{price | currency}}&lt;/h1&gt;\n不写参数，默认美元，并保留两位小数\n\n&lt;h1&gt;{{price | currency:&quot;￥&quot;}}&lt;/h1&gt;\n人民币</code></pre><ul>\n<li>date日期格式化date:&quot;yyyy-MM-dd hh:mm:ssa&quot;；</li>\n</ul>\n<pre><code>    &lt;h1&gt;{{time | date : &quot;hh:mm:ssa&quot;}}&lt;/h1&gt;\n    最后加a，显示上午下午（am\\pm）\n    &lt;h1&gt;{{time | date : &quot;yyyy-MM-dd&quot;}}&lt;/h1&gt;\n    &lt;h1&gt;{{time | date : &quot;yyyy-MM-dd hh:mm:ssa&quot;}}&lt;/h1&gt;</code></pre><ul>\n<li>json 变化不大，一般不用<pre><code>&lt;h1&gt;{{json | json}}&lt;/h1&gt;</code></pre></li>\n<li>filter内容过滤filter:&#39;abc&#39;；<code>实现搜索功能</code></li>\n</ul>\n<pre><code>&lt;input ng-model=&quot;myfilter&quot; /&gt;\n&lt;ul ng-repeat=&quot;x in arr | filter:myfilter&quot;&gt;\n    &lt;li&gt;{{x.name}}+&#39;---&#39;+{{x.age}}&lt;/li&gt;\n&lt;/ul&gt;\n在input中输入要找的内容，ul中自动过滤显示要查看的li;\nng-repeat表示遍历，arr是要遍历的数组；</code></pre><ul>\n<li>limitTo数量过滤，写几，显示几条；</li>\n</ul>\n<pre><code>在上面的例子中直接添加\n&lt;ul ng-repeat=&quot;x in arr | limitTo:2&quot;&gt;\n    &lt;li&gt;{{x.name}}+&#39;---&#39;+{{x.age}}&lt;/li&gt;\n&lt;/ul&gt;\n表示显示ul中的前两条</code></pre><ul>\n<li>uppercase全部大写；</li>\n</ul>\n<pre><code>    &lt;ul ng-repeat=&quot;x in arr&quot;&gt;\n        &lt;li&gt;{{x.name | uppercase}}&lt;/li&gt;\n    &lt;/ul&gt;</code></pre><ul>\n<li><p>lowercase全部小写；和大写的用法一样</p>\n</li>\n<li><p>orderBy通过**进行排序；</p>\n</li>\n</ul>\n<pre><code>&lt;ul ng-repeat=&quot;x in arr | orderBy:&#39;age&#39;&quot;&gt;\n    &lt;li&gt;{{x.name | uppercase}}&lt;/li&gt;\n&lt;/ul&gt;\n按年龄从小到大排序，也可以按name排序</code></pre><p>ng-repeat方法</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope){\n    $scope.arr=[\n            {name:&#39;王源&#39;,age:18},\n            {name:&#39;王俊凯&#39;,age:27},\n            {name:&#39;易烊千玺&#39;,age:15},\n            {name:&#39;王源1&#39;,age:23},\n            {name:&#39;王俊凯2&#39;,age:21},\n            {name:&#39;易烊千玺3&#39;,age:23},\n        ]\n\n    $scope.arr2=[1,1,3,4,5,6]\n})\n\n\n&lt;ul ng-repeat=&quot;x in arr | orderBy:&#39;age&#39;&quot;&gt;\n    &lt;li&gt;{{x.name}} -- {{x.age}}&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul ng-repeat=&quot;x in arr2 track by $index&quot;&gt;\n    &lt;li&gt;{{x}}&lt;/li&gt;\n&lt;/ul&gt;</code></pre><blockquote>\n<p>使用track by $index,在不知道数组是否重复的情况下使用，若重复而没有使用，则会报错</p>\n</blockquote>\n<h5 id="-">自定义过滤器</h5>\n<pre><code>angular.module(&#39;app&#39;,[])\n.filter(&#39;tc&#39;,function(){\n    return function(ele){\n\n        console.log(ele);\n        return ele+&#39;@@@&#39;;\n    }\n})\n.controller(&#39;ctrl&#39;,function($scope){\n    $scope.name=&#39;小明&#39;;\n})\n\n\n在使用时就可以直接使用\n&lt;div ng-controller=&quot;ctrl&quot;&gt;\n    &lt;h1&gt;{{name | tc}}&lt;/h1&gt;\n&lt;/div&gt;</code></pre><h3 id="-">五、服务</h3>\n<p>1.内置服务</p>\n<p>$interval定时器</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope){\n    $scope.count=0;\n\n    $interval(function(){\n        $scope.count++;\n    },1000)\n})</code></pre><p>2.$location方法</p>\n<pre><code>$location打印出来，在原型中的方法\n$location.absUrl()；//当前文件所在的绝对路径\n$location.host()// 当前IP\n$location.port()// 当前端口</code></pre><p>3.ajax数据交互,调用$http方法</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.controller(&#39;ctrl&#39;,function($scope,$http){\n\n    $http.get(&#39;http://*********&#39;)\n    .then(function(res){\n        console.log(res);\n        return res.data;\n    })\n    .then(function(res){\n        console.log(res);\n        $scope.pro=res;\n    })\n1.6以后版本使用thin，之前的版本都是success(function(){})\n若想知道用的什么方法，可以打印console.log($http.get(&#39;http://www.。。。。。&#39;))\n})</code></pre><p>4.自定义服务</p>\n<p>五种方法</p>\n<ul>\n<li>value</li>\n<li>constant</li>\n<li>factory</li>\n<li>service</li>\n<li>provider</li>\n</ul>\n<p>自定义服务不需要加$;</p>\n<p>constant定义一个常量，除了constant服务，其他都不能注入到config里面</p>\n<p>value定义了一个可变量：</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.config(function(PI){\n    console.log(PI);\n})\n.controller(&#39;ctrl&#39;,[&#39;$scope&#39;,&#39;$http&#39;,&#39;president&#39;,function($scope,$http,president){\n    $scope.name=&#39;hello&#39;;\n    $scope.pic=president;\n}])\n.controller(&#39;ctrl2&#39;,function($scope,$http,president,PI){\n    $scope.name=&#39;world&#39;;\n    $scope.picc=presidet;\n    $scope.pi=PI;\n})\n.value(&#39;president&#39;,&#39;abc&#39;)\n.constant(&#39;PI&#39;,3.1415926)</code></pre><p>service、factory</p>\n<pre><code>    angular.module(&#39;app&#39;,[])\n    .controller(&#39;ctrl&#39;,function($scope,math,math2){\n        // 注入math，调用他的加法\n        let result=math.add(2,3);\n        $scope.result=result;\n\n        $scope.result2=math2.add(1,2);\n    })\n    .service(&#39;math&#39;,function(){\n        // 可以添加方法，添加到this上面\n        this.add=function(x,y){\n            return x+y;\n        }\n        this.min=function(x,y){\n            return x-y;\n        }\n    })\n    .factory(&#39;math2&#39;,function(){\n        let factory={};\n        factory.add=function(x,y){\n            return x+y;\n        }\n        return factory;\n    })</code></pre><p>service是把方法添加到this上面，factory则是先定义一个对象，然后在对象上添加方法，最后返回这个对象</p>\n<p>provider只能定义在config里面</p>\n<pre><code>angular.module(&#39;app&#39;,[])\n.config(function($provide){\n    先注入provide对象\n    $provide.provider(&#39;math&#39;,fuction(){\n        this.$get=function(){\n            var factory={};\n            factory.add=function(x,y){\n                return x+y;\n            }\n\n            return factory;\n        }\n    })\n})\n.controller(&#39;ctrl&#39;,function($scope,math){\n    $scope.result=math.add(3,3);\n})</code></pre><p>方法更类似于factory；</p>\n<blockquote>\n<p>在自定义服务中，由于服务和$scope,$http等是同级，所以在服务中不能引入$scope,$http等，如若特别想用的话，可以在服务里面传进两个形参，在调用的时候再传进去。</p>\n</blockquote>\n<h4 id="-">路由</h4>\n<p>最简单的目的就是为了跳转显示页面，加载html；\n为了缩小angular体系，把路由独立出来；使用时，要把依赖写进去</p>\n<p>在说路由时，附带一个添加css的方法，也是angular提供的，{angular-css.min.js}</p>\n<p>angular-router:</p>\n<p>angular.module(&#39;qiongyou&#39;,[&#39;ngRouter&#39;])</p>\n<pre><code>&lt;a href=&quot;#/home&quot;&gt;home&lt;/a&gt;\n&lt;div ng-view&gt;&lt;/div&gt;\n\nangular.module(&#39;app&#39;,[&#39;ngRoute&#39;])\n.config(function($routeProvider){\n    $routeProvider\n    .$otherwise(&#39;home.html&#39;)//设置打开网页时的默认页面\n\n    $routeProvider\n    .when(&#39;/home&#39;,{\n        template:&quot;&lt;h1&gt;这是首页&lt;/h1&gt;&quot;,//或templateUrl:&#39;home.html&#39;,\n       // css:&#39;home.css&#39;//可以直接这样写\n        css:{\n            href:&#39;home.css&#39;,\n            persist:true//表示是否永久保存\n        },\n        controller:function(){\n            console.log($css);\n            $scope.arr=[\n                {name:&#39;aaa&#39;,age:&#39;12&#39;}, {name:&#39;aaa&#39;,age:&#39;12&#39;} ]\n        }\n    })\n})\n</code></pre><p>以上就是一个简单的路由，点击a标签就会在a标签下面的ng-view中显示出来，当然，路由可以分好多级，在页面a标签上设锚点，要和路由中的when的名称一致</p>\n<p>ui-router:\n{angular-ui-router/release/angular-ui-router.min.js}</p>\n<p>使用ui.router,显示区域使用ui-view；</p>\n<pre><code>angular.module(&#39;app&#39;,[&#39;ui.router&#39;])\n.config(function($stateProvider,$urlRouterProvider){\n    $urlRouterProvider.otherwise(&#39;/footer/home/tn&#39;);\n      //点击进去默认要显示的页面；\n\n    $stateProvider\n    .state(&#39;home&#39;,{\n        url:&#39;/home&#39;,\n        templateUrl:&#39;home.html&#39;，\n       // 如果下面有关联的控制器的话\n        controller:&#39;home&#39;\n    })\n})\n.controller(&#39;home&#39;,function($scope,$http){\n      //相关操作\n})\n\n\n在页面a标签，\n&lt;a ui-sref=&#39;home&#39;&gt;首页&lt;/a&gt;这里的home和state中的名称一致\n如果想要点击样式的话\n&lt;a ui-sref=&#39;home&#39; ui-sref-active=“active”&gt;首页&lt;/a&gt;\nactive是自定义的class样式\n\n</code></pre><p>如果想在路由下面再定义一个子路由</p>\n<pre><code>\nangular.module(&#39;app&#39;,[&#39;ui.router&#39;])\n.config(function($stateProvider,$urlRouterProvider){\n    $urlRouterProvider.otherwise(&#39;/footer/home/tn&#39;);\n      //点击进去默认要显示的页面；\n\n    $stateProvider\n    .state(&#39;home&#39;,{\n        url:&#39;/home&#39;,\n        templateUrl:&#39;home.html&#39;，\n       // 如果下面有关联的控制器的话\n        controller:&#39;home&#39;\n    })\n    .state(&#39;home.search&#39;,{\n        url:&#39;/search&#39;,\n        templateUrl:&#39;search.html&#39;\n    })\n})\n\n&lt;a ui-sref=&#39;home.search&#39;&gt;首页下的搜索页面&lt;/a&gt;\n\n</code></pre><p>如果想定义一个子路由,并且不再同一个js 文件中写，就在父路由的依赖里面把字路由都写进去。把相应的js引入html。</p>\n<p>#####传参</p>\n<p>1路由传参、2点击事件传参、3通过提交服务器，然后从服务器返回数据</p>\n<p>1路由传参\n<a ui-sref="home({p1:\'100\',p2:\'200\'})">首页</a>\n通过传键值对</p>\n<p>参数接受\n在state中接收参数</p>\n<pre><code>$stateProvider\n.state(&#39;home&#39;,{\n      url:&#39;/home&#39;,//可以通过/home/:p1:p2取到，但是不建议这样\n      params:{\n          p1:null,\n          p2:null,//可以配置一个默认的参数，\n      },\n      templateUrl:&#39;home.html&#39;,\n      controller:&#39;home&#39;\n})\n.controller(&#39;home&#39;,function($stateParams){\n    通过控制器的$stateParams拿到参数，\n    let p1=$stateParams.p1;\n    console.log(p1);//100\n})</code></pre><p>2通过ng-click=&quot;change(x.id)&quot;</p>\n<p>在控制器中定义一个change方法</p>\n<pre><code>$scope.change=function(id){\n    console.log(id);\n}\n\n\n实现页面的内部跳转，引用$state\n.controller(&#39;home&#39;,function($state){\n    通过$state的方法\n    $state.go(&#39;state的状态&#39;,{id:id})\n})\n在state(&#39;home&#39;,{\n    url:&#39;/home&#39;,\n    templateurl:&#39;路径&#39;,\n\n  controller:function($scope,$stateParams,){\n      let id=$stateParams.id;\n})\n})\n</code></pre><p>在事件传参时，可以传$index,当前的下标，还可以传$event,在控制器里面，</p>\n<pre><code>ng-click=change($event);\n\n.controller(&#39;home&#39;,function(e){\n    console.log(e.target);//获取到事件对象\n})\n\n\n\nng-click=change($index);\n\n.controller(&#39;home&#39;,function(a){\n    console.log(a);//获取到下标\n})</code></pre><h5 id="angular-jsonp-">angular也有jsonp方法：</h5>\n<pre><code>$http.jsonp(链接).success(function(\n\n))</code></pre>'},"2c48":function(n,e){n.exports='<h3 id="-">全局生命钩子</h3>\n<p><strong>router实例上添加</strong></p>\n<ol>\n<li><p><code>beforeEach</code></p>\n</li>\n<li><p><code>afterEach</code></p>\n</li>\n</ol>\n<p><strong>组件上添加</strong></p>\n<ol>\n<li><p><code>beforeRouteEnter</code></p>\n</li>\n<li><p><code>beforeRouteUpdate</code></p>\n</li>\n<li><p><code>beforeRouteLeave</code></p>\n</li>\n</ol>\n<p>所有方法带有的三个参数：</p>\n<ol>\n<li><p><code>to</code></p>\n</li>\n<li><p><code>from</code></p>\n</li>\n<li><p><code>next</code></p>\n</li>\n</ol>\n<h3 id="-">动态路由</h3>\n<pre><code>{\n  path: &#39;/page/:id?&#39;\n}\n\nthis.$route.params.id</code></pre>'},"2e28":function(n,e){n.exports='<h2 id="require-context-path-check-type-">require.context(path, check, type) 方法</h2>\n<blockquote>\n<p>当在一个页面引入多个组件时，正常引入多少就需要写多少条引入,维护比较麻烦，写着也费劲，就有这个方法。</p>\n</blockquote>\n<p><strong>三个参数</strong></p>\n<pre><code>path: 引入文件所在目录；\n\ncheck: boolean值，是否查询该目录下的子目录；\n\ntype: regExp, 查找文件的类型</code></pre><blockquote>\n<p>eg: <code>require.context(&#39;../&#39;, false, /\\.js$/)</code>查找<code>.js</code>文件</p>\n</blockquote>\n<p><strong>这个函数返回一个<code>require</code>函数</strong></p>\n<pre><code class="language-js">function webpackContext(req) {\n    return __webpack_require__(webpackContextResolve(req));\n}</code></pre>\n<blockquote>\n<p>该函数有三个属性</p>\n<ol>\n<li>resolve: 函数，他返回的是被解析模块的id</li>\n<li>keys: 函数，他返回的是一个数组，该数组是由所有可能被上下文模块解析的请求对象组成<code>（常用到）</code></li>\n<li>id：上下文模块的id</li>\n</ol>\n</blockquote>\n<pre><code class="language-js">let req = require.context(&#39;../&#39;, false, /\\.js$/);\nlet list = req.keys();\n\nlist;</code></pre>\n'},"2fb5":function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-b9b05fd97d562bd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期">\nbeforeCreate : 数据观测，事件配置之前调用。（也就是在实例的 data, computed, watch, method等之前调用）</p>\n<h1 id="data-">data 数据对象</h1>\n<blockquote>\n<p>组件的定义只接受function。原因： 当一个组件被定义，如果是对象的话，是引用类型，所有的引用都会变成相同的。</p>\n</blockquote>\n<pre><code>this.a = this.$data.a\n</code></pre><p>以<code>_</code>/<code>$</code>开头的属性不会被Vue实例所代理</p>\n<pre><code>this.$data._property 访问</code></pre><blockquote>\n<p>不能对<code>data</code>属性是用箭头函数，因为箭头函数默认继承他的上下文</p>\n</blockquote>\n<h1 id="props-">props 接收父组件给组件传值</h1>\n<blockquote>\n<p>格式： 数组，对象（对象允许配置高级选项，如类型检测，自定义效验和设置默认值）</p>\n</blockquote>\n<pre><code>props: {\n  height: Number,\n  age: {\n    type: Number,\n    default: 0,\n    required: true,\n    validator: value =&gt; value &gt;= 0\n  }\n}</code></pre><h1 id="computed-">computed 计算属性</h1>\n<blockquote>\n<p>同样不能使用箭头函数定义计算属性</p>\n</blockquote>\n<blockquote>\n<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算</p>\n</blockquote>\n<pre><code>computed: {\n  user () {\n    return this.info\n  },\n\n  sum: {\n    get: function () {\n      return this.a + 1\n    },\n    set: function (v) {\n      this.a += v\n    }\n  }\n}</code></pre><h1 id="methods-">methods 事件</h1>\n<blockquote>\n<p>不能使用箭头函数</p>\n</blockquote>\n<h1 id="watch-">watch 监测</h1>\n<blockquote>\n<p>监测对象， 键是要观察的变量表达式，值是方法\n同样不能使用箭头函数定义</p>\n</blockquote>\n<pre><code>data () {\n  return {\n    a: 1,\n    b: {\n      c: {\n        d: 2\n      }\n    },\n    f: 3\n  }\n},\nwatch: {\n  a (val, oldVal) {\n    console.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n  },\n  f: &#39;方法名&#39;,\n  &#39;b.c.d&#39; () {\n    // ...\n  }\n}\n</code></pre><hr>\n<p>生命周期钩子</p>\n<h1 id="boforecreate">boforeCreate</h1>\n<p><code>初始化之后， 数据观测之前</code></p>\n<h1 id="created">created</h1>\n<p><code>实例创建完之后立即被调用，已完成数据观测，属性，和方法运算，挂载没开始，$el不可见</code></p>\n<h1 id="beforemount">beforeMount</h1>\n<p><code>挂载前，相关render函数首次调用</code></p>\n<h1 id="mounted">mounted</h1>\n<p><code>挂载之后</code></p>\n<pre><code>若等到所有的自组建也一起完成\n\nmounted () {\n  this.$nextTick(_ =&gt; {\n    // .\n  })\n}</code></pre><h1 id="beforeupdate">beforeUpdate</h1>\n<p><code>数据更新时调用， 虚拟dom打补丁之前， 这里可以获取现有的DOM</code></p>\n<h1 id="update">update</h1>\n<p><code>数据更改导致的虚拟 DOM 重新渲染和打补丁之后</code></p>\n<h1 id="activated">activated</h1>\n<p><code>组件激活时调用</code></p>\n<h1 id="deactivated">deactivated</h1>\n<p><code>组件停用时调用</code></p>\n<h1 id="beforedestroy">beforeDestroy</h1>\n<p><code>实例销毁前调用</code></p>\n<h1 id="destroyed">destroyed</h1>\n<p><code>实例销毁后调用</code></p>\n<h1 id="errorcaptured">errorCaptured</h1>\n<p><code>当捕获一个来自子孙组件的错误时被调用</code></p>\n'},3095:function(n,e){n.exports='<h1 id="-">跑项目遇到的问题</h1>\n<h3 id="-package-json-scripts-">针对<code>package.json/scripts</code>中的命令</h3>\n<pre><code>  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;NODE_ENV=production node --harmony index.js&quot;\n  }</code></pre><p>其中<code>start</code>里面是合并了两个命令（这是Mac中bash或Linux的shell中的独特操作）</p>\n<p>我们需要改成</p>\n<pre><code>  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;set NODE_ENV=production &amp;&amp; node --harmony index.js&quot;\n  }\n</code></pre>'},"30e8":function(n,e){n.exports='<h3 id="-">元素选择器</h3>\n<pre><code>$(&#39;元素名&#39;)\n\n$(&#39;.class&#39;)\n\n$(&#39;#id&#39;)\n</code></pre><h3 id="-">属性选择器</h3>\n<pre><code>$(&#39;[href]&#39;)\n\n$(&#39;[href=&quot;#&quot;]&#39;)\n\n$(&#39;[href!=&quot;#&quot;]&#39;)\n\n$(&#39;[href$=&quot;.jpg&quot;]&#39;) // 选取所有 href 值以 &quot;.jpg&quot; 结尾的元素。\n</code></pre><h3 id="-">更多</h3>\n<pre><code>$(this) // 当前html元素\n\n\n\n</code></pre>'},"342d":function(n,e){n.exports='<p>全局安装3.0.0版本</p>\n<p><strong>需要node版本大于9.0</strong></p>\n<blockquote>\n<p>推荐使用yarn ==&gt; <code>npm i -g yarn</code>\n使用yarn install </p>\n</blockquote>\n<pre><code>npm install -g @vue/cli</code></pre><ul>\n<li><p>创建一个项目</p>\n<pre><code>vue create project</code></pre></li>\n<li><p>pick preset:</p>\n<blockquote>\n<p>上下选择第二个： <code>Manually select features</code>(手动预设)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>空格选择</p>\n</blockquote>\n<p><img src="https://github.com/Heisinadaze/notes/blob/master/images/WechatIMG52.jpeg" alt="vue@3.0.0"></p>\n<p>除了单元测试，都选上了</p>\n<p>后面的根据自己的需求进行回车选择</p>\n<h4 id="-">遇到问题</h4>\n<ol>\n<li>版本更新问题</li>\n</ol>\n<blockquote>\n<p>在安装最新<code>node@10.14.1</code>时，npm没有安装成最新版本，导致报错</p>\n</blockquote>\n<p><img src="http://cdn.jsan.top//vue-cli@3/4fbe6ae8a58eb132537e902d54f6843.png" alt="question 1"></p>\n<p><strong>解决</strong></p>\n<pre><code>npm uninstall npm -g\n\n重新安一遍node</code></pre><h3 id="-">装饰器问题</h3>\n<blockquote>\n<p>Experimental support for decorators is a feature that is subject to change in a future release. Set the &#39;experimentalDecorators&#39; option to remove this warning.</p>\n</blockquote>\n<p>已经设置过还有，应该是没有设置成功</p>\n<pre><code>可能是tsconfig.json加载失败\nnode 不是可用命令\n\nnpm i @types/node --save-dev</code></pre>'},3459:function(n,e){n.exports='<h1 id="es6-">ES6语法、</h1>\n<blockquote>\n<p> Let用来声明变量，但是所声明的变量，只在let命令所在的代码块内有效。不能用于变量提升</p>\n</blockquote>\n<pre><code>\n{\n\n   let a=10;\n\n   var b=0;\n\n}\n\nconsole.log(a);//undefine报错\n\nconsole.log(b)//0\n</code></pre><h5 id="-">适合环境</h5>\n<blockquote>\n<p>for 循环中</p>\n</blockquote>\n<blockquote>\n<p>for(let i=0;i&lt;10;i++){}</p>\n</blockquote>\n<ol start="2">\n<li>变量提升问题</li>\n</ol>\n<pre><code>\nconsole.log(a);\n\nconsole.log(b);\n\nvar a=2;\n\nlet b=0;\n</code></pre><h2 id="-">一个暂时性死区</h2>\n<pre><code>\nvar tmp=123;\n\nif(true){\n\ntmp=&#39;abc&#39;;\n\nconsole.log(tmp);\n\nconsole.log(typeof tmp)//有let时，typeof也就不安全了\n\nlet tmp;//如果不写这句话，console.log正常输出ABC，有了就会报错\n\n//在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”\n\n}\n\n// 举例一个隐蔽的死区\n\nfunction bar(x=y,y=2){\n\n   return [x,y];\n\n}\n\nbar();//报错，因为x=y时，也还没有声明\n\n// 总结：暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</code></pre><h3 id="-">短板二：不允许重复声明</h3>\n<pre><code>\nfunction (){\n\n   let a=10;\n\n   let a=1;\n\n }//报错\n\nfunction (){\n\n   let a=10;\n\n   var a=1;\n\n}//报错\n\nfunction (a){\n\n   let a=10;\n\n}//报错\n\nfunction (a){\n\n   {\n\n       let a=10;\n\n   }\n\n}//不报错\n</code></pre><h3 id="es6-">ES6新增块级作用域</h3>\n<ul>\n<li>在Es5中没有块级作用域，只有全局和局部,带来的不合理的场景</li>\n</ul>\n<blockquote>\n<ol>\n<li>内层变量覆盖外层变量</li>\n</ol>\n</blockquote>\n<pre><code>\nvar tmp=new Date();\n\nfunction f(){\n\n console.log(tmp);\n\nif(false){\n\nvar tmp=&quot;hello world&quot;;\n\n}\n\n}\n\nf();//undefine，因为变量的提升问题\n</code></pre><blockquote>\n<ol start="2">\n<li>for循环计数</li>\n</ol>\n</blockquote>\n<pre><code>\n var s=&#39;hello&#39;;\n\n for(var i=0;i&lt;s.length;i++){\n\nconsole.log(i);\n\n}\n\nconsole.log(i)//造成了全局泄露问题\n</code></pre><ul>\n<li><p>而let实际就是为JS新增了块级属性</p>\n</li>\n<li><p>像前面的问题</p>\n</li>\n</ul>\n<pre><code>\nfunction f1(){\n\nlet n=5;\n\nif(true){\n\nlet n=10;\n\n}\n\n console.log(n);\n\n}\n\nf1()//5\n\n// 内层作用域可以定义外层作用域的同名变量，也可以代替IIFE\n</code></pre><blockquote>\n<p>在严格模式下</p>\n</blockquote>\n<pre><code>\n&#39;use strict&#39;;\n\nfunction f(){console.log(&#39;I am outside&#39;)}\n\n(function(){\n\nif(true){\n\nfunction f(){console.log(&#39;I am inside&#39;)}\n\nf();\n\n}\n\n// f();\n\n})()\n\n// 函数声明类似于var，即会提升到全局作用域或函数作用域头部\n\n// 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n{\n\nlet a = &#39;secret&#39;;\n\nfunction f() {\n\nreturn a;\n\n}\n\n}\n\n// 函数表达式\n\n{\n\nlet a = &#39;secret&#39;;\n\nlet f = function () {\n\nreturn a;\n\n};\n\n}\n</code></pre><p>新语法不太熟悉，望理解#  ES6语法、</p>\n<blockquote>\n<p> Let用来声明变量，但是所声明的变量，只在let命令所在的代码块内有效。不能用于变量提升</p>\n</blockquote>\n<pre><code>\n{\n\n   let a=10;\n\n   var b=0;\n\n}\n\nconsole.log(a);//undefine报错\n\nconsole.log(b)//0\n</code></pre><h5 id="-">适合环境</h5>\n<blockquote>\n<p>for 循环中</p>\n</blockquote>\n<blockquote>\n<p>for(let i=0;i&lt;10;i++){}</p>\n</blockquote>\n<ol start="2">\n<li>变量提升问题</li>\n</ol>\n<pre><code>\nconsole.log(a);\n\nconsole.log(b);\n\nvar a=2;\n\nlet b=0;\n</code></pre><h2 id="-">一个暂时性死区</h2>\n<pre><code>\nvar tmp=123;\n\nif(true){\n\ntmp=&#39;abc&#39;;\n\nconsole.log(tmp);\n\nconsole.log(typeof tmp)//有let时，typeof也就不安全了\n\nlet tmp;//如果不写这句话，console.log正常输出ABC，有了就会报错\n\n//在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”\n\n}\n\n// 举例一个隐蔽的死区\n\nfunction bar(x=y,y=2){\n\n   return [x,y];\n\n}\n\nbar();//报错，因为x=y时，也还没有声明\n\n// 总结：暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</code></pre><h3 id="-">短板二：不允许重复声明</h3>\n<pre><code>\nfunction (){\n\n   let a=10;\n\n   let a=1;\n\n }//报错\n\nfunction (){\n\n   let a=10;\n\n   var a=1;\n\n}//报错\n\nfunction (a){\n\n   let a=10;\n\n}//报错\n\nfunction (a){\n\n   {\n\n       let a=10;\n\n   }\n\n}//不报错\n</code></pre><h3 id="es6-">ES6新增块级作用域</h3>\n<ul>\n<li>在Es5中没有块级作用域，只有全局和局部,带来的不合理的场景</li>\n</ul>\n<blockquote>\n<ol>\n<li>内层变量覆盖外层变量</li>\n</ol>\n</blockquote>\n<pre><code>\nvar tmp=new Date();\n\nfunction f(){\n\n console.log(tmp);\n\nif(false){\n\nvar tmp=&quot;hello world&quot;;\n\n}\n\n}\n\nf();//undefine，因为变量的提升问题\n</code></pre><blockquote>\n<ol start="2">\n<li>for循环计数</li>\n</ol>\n</blockquote>\n<pre><code>\n var s=&#39;hello&#39;;\n\n for(var i=0;i&lt;s.length;i++){\n\nconsole.log(i);\n\n}\n\nconsole.log(i)//造成了全局泄露问题\n</code></pre><ul>\n<li><p>而let实际就是为JS新增了块级属性</p>\n</li>\n<li><p>像前面的问题</p>\n</li>\n</ul>\n<pre><code>\nfunction f1(){\n\nlet n=5;\n\nif(true){\n\nlet n=10;\n\n}\n\n console.log(n);\n\n}\n\nf1()//5\n\n// 内层作用域可以定义外层作用域的同名变量，也可以代替IIFE\n</code></pre><blockquote>\n<p>在严格模式下</p>\n</blockquote>\n<pre><code>\n&#39;use strict&#39;;\n\nfunction f(){console.log(&#39;I am outside&#39;)}\n\n(function(){\n\nif(true){\n\nfunction f(){console.log(&#39;I am inside&#39;)}\n\nf();\n\n}\n\n// f();\n\n})()\n\n// 函数声明类似于var，即会提升到全局作用域或函数作用域头部\n\n// 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n{\n\nlet a = &#39;secret&#39;;\n\nfunction f() {\n\nreturn a;\n\n}\n\n}\n\n// 函数表达式\n\n{\n\nlet a = &#39;secret&#39;;\n\nlet f = function () {\n\nreturn a;\n\n};\n\n}\n</code></pre>'},"34d4":function(n,e){n.exports='<h1 id="-">属性</h1>\n<ul>\n<li>Object.prototype： Object的原型对象。</li>\n</ul>\n<h1 id="-">方法</h1>\n<h5 id="object-assign-">Object.assign()  用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</h5>\n<p>语法： <code>Object.assign(target, ...sources)</code></p>\n<p>target 目标对象。\nsources 源对象。</p>\n<p>返回值： 目标对象</p>\n<p>Object.assign\n 会跳过那些值为 null或 undefined的源对象。</p>\n<p>不能解决深拷贝的问题</p>\n<p>合并对象</p>\n<pre><code>var o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。</code></pre><p>合并相同属性的对象</p>\n<pre><code>var o1 = { a: 1, b: 1, c: 1 };\nvar o2 = { b: 2, c: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }</code></pre><h5 id="object-create-">Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。</h5>\n<p>语法：<code>Object.create(proto[, propertiesObject])</code></p>\n<p>proto 新创建对象的原型对象。</p>\n<p>propertiesObject 可选。如果没有指定为undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</p>\n<p>返回值:   在指定原型对象上添加新属性后的对象。</p>\n<p>如果propertiesObject参数不是 null或一个对象，则抛出一个 TypeError异常。</p>\n<p>实现类式继承</p>\n<pre><code>function Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info(&#39;Shape moved.&#39;);\n};\n\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\nvar rect = new Rectangle();\n\nconsole.log(&#39;Is rect an instance of Rectangle?&#39;,\n  rect instanceof Rectangle); // true\nconsole.log(&#39;Is rect an instance of Shape?&#39;,\n  rect instanceof Shape); // true\nrect.move(1, 1); // Outputs, &#39;Shape moved.&#39;</code></pre><p>当继承多个对象时：</p>\n<pre><code>function MyClass() {\n     SuperClass.call(this);\n     OtherSuperClass.call(this);\n}\n\nMyClass.prototype = Object.create(SuperClass.prototype);\n\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function() {\n     // do a thing\n};</code></pre><pre><code>var o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: { \n    writable:true,\n    configurable:true,\n    value: &quot;hello&quot; \n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(&quot;Setting `o.bar` to&quot;, value);\n    }\n  }\n});\n\n\nfunction Constructor(){}\no = new Constructor();\n// 上面的一句就相当于:\no = Object.create(Constructor.prototype);\n// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码\n\n\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//&quot;q&quot;\n\ndelete o.p\n//false\n\n//创建一个可写的,可枚举的,可配置的属性p\no2 = Object.create({}, {\n  p: {\n    value: 42, \n    writable: true,\n    enumerable: true,\n    configurable: true \n  } \n});</code></pre><h5 id="object-defineproperties-">Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</h5>\n<p>语法： <code>Object.defineProperties(obj, props)</code></p>\n<p>返回值： 传递给函数的对象</p>\n<h5 id="object-entries-for-in-for-in-">Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</h5>\n<p>语法： <code>Object.entries(obj)</code></p>\n<p>obj 可以返回其可枚举属性的键值对的对象。</p>\n<p>返回值  给定对象自身可枚举属性的键值对数组。</p>\n<pre><code>const obj = { foo: &#39;bar&#39;, baz: 42 };\nconsole.log(Object.entries(obj)); // [ [&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42] ]\n\nObject.entries(obj).forEach(([key, value]) =&gt; {\n  console.log(`${key} ${value}`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n});\n\n转为map\nvar obj = { foo: &quot;bar&quot;, baz: 42 }; \nvar map = new Map(Object.entries(obj));\nconsole.log(map); // Map { foo: &quot;bar&quot;, baz: 42 }</code></pre><h5 id="object-freeze-">Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</h5>\n<p>语法： <code>Object.freeze(obj)</code></p>\n<p>obj  要被冻结的对象。\n返回值  被冻结的对象。</p>\n<h5 id="object-getownpropertydescriptor-">Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</h5>\n<p>语法： <code>Object.getOwnPropertyDescriptor(obj, prop)</code></p>\n<p>obj  需要查找的目标对象\nprop  目标对象内属性名称（String类型），加引号。</p>\n<p>返回值： 如果改属性直接存在于对象上，返回，否则返回undefined。</p>\n<pre><code>  class Point {\n    constructor (x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    toString () {\n      console.log(this.x + this.y);\n    }\n  }\n\n  let p = new Point(1, &#39;y&#39;);\n  let a = Object.getOwnPropertyDescriptor(p, &#39;x&#39;);\n  console.log(a)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-d11a05f78651d860.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Object.getOwnPropertyDescriptor"></p>\n<p>ES6中，如果第一个参数不是一个对象，就会强制转换成一个对象，在ES5会报错。</p>\n<h5 id="object-getownpropertydescriptors-">Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。</h5>\n<p>如果没有任何自身属性，则返回空对象。</p>\n<h5 id="object-getownpropertynames-symbol-">Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</h5>\n<pre><code>var obj = { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;};\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</code></pre><h5 id="object-getownpropertysymbols-symbol-">Object.getOwnPropertySymbols() 方法会返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</h5>\n<h5 id="object-getprototypeof-prototype-">Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。</h5>\n<p>如果没有继承属性，返回null</p>\n<pre><code>var proto = {};\nvar obj = Object.create(proto);\nObject.getPrototypeOf(obj) === proto; // true</code></pre><h5 id="object-is-">Object.is()方法判断两个值是否是相同的值。</h5>\n<p>语法： <code>Object.is(value1, value2);</code></p>\n<p>返回一个Boolean值。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-62a28fcd02db04d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"></p>\n<p>与==区别： 不会隐式转换类型</p>\n<p>与===区别： 不会把+0和-0视为相等，并且可以认为NaN等于NaN。</p>\n<h5 id="object-keys-for-in-for-in-"><strong>Object.keys()</strong> 方法会返回一个由一个给定<strong>对象</strong>的自身可枚举属性组成的<strong>数组</strong>，数组中属性名的排列顺序和使用 for...in循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</h5>\n<pre><code>let arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\nconsole.log(Object.keys(arr)); \n// [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]\n\nlet anObj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; }; \nconsole.log(Object.keys(anObj)); \n// [&#39;2&#39;, &#39;7&#39;, &#39;100&#39;]\n</code></pre><h5 id="object-values-"><strong>Object.values()</strong></h5>\n<p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>\n<pre><code>var obj = { foo: &quot;bar&quot;, baz: 42 };\nconsole.log(Object.values(obj)); // [&#39;bar&#39;, 42]</code></pre>'},3500:function(n,e){n.exports='<h3 id="-jsonp-">一、JSONP方法</h3>\n<h3 id="-iframe-">二、iframe跨域</h3>\n<blockquote>\n<p>一般用于同域名下</p>\n</blockquote>\n<h3 id="-window-name-">三、window.name 跨域</h3>\n<blockquote>\n<p>在iframe的基础上，获取其他域名下的数据</p>\n</blockquote>\n<h3 id="-document-domain-">四、document.domain 跨域</h3>\n<blockquote>\n<p>需要两个跨域的对象有关联的域名，如果一个域名被攻击，另外一个也会有安全问题</p>\n</blockquote>\n<h3 id="-cookie-">五、cookie跨域</h3>\n<blockquote>\n<p>需要对cookie做一些额外的设置，删除也比较麻烦，两个关联域名</p>\n</blockquote>\n<h3 id="-postmessage-">六、postMessage跨域</h3>\n<blockquote>\n<p>HTML5新特性，浏览器兼容性问题</p>\n</blockquote>\n<h3 id="-html5">七、 html5</h3>\n'},"363b":function(n,e){n.exports=""},"36b2":function(n,e){n.exports="<p><code>方法一 .vue</code></p>\n<pre><code>&lt;tempalte&gt;\n  &lt;Header&gt;&lt;/Header&gt;\n&lt;/tempalte&gt;\n\n&lt;script&gt;\n// import Header from &#39;@/components/Header&#39;\n\nexport default {\n  components: {\n    // Header\n\n    Header: (resolve) =&gt; {\n      setTimeout(() =&gt; {\n        resolve(require(&#39;@/components/Header&#39;))\n      }, 2000)\n    }\n  }\n}\n&lt;/script&gt;</code></pre><p><code>方法二 router.js</code></p>\n<pre><code>let Header = (resolve) =&gt; {\n  return require.ensure([], () =&gt; { // 第一个是依赖，第二个是回调\n    resolve(require(&#39;@/components/Header&#39;))\n  }, &#39;ab&#39;) // 第三个参数， 命名， 可以省略\n}\n\ncomponent: Header</code></pre><blockquote>\n<p>每个<code>require.ensure</code> 都会打包出一个js,如果想合并两个文件打包到一个js,\n需要把第三个参数加上，并且一眼的命名就可以了</p>\n</blockquote>\n<p>如</p>\n<pre><code>let Header = (resolve) =&gt; {\n  return require.ensure([], () =&gt; {\n    resolve(require(&#39;@/components/Header&#39;))\n  }, &#39;ab&#39;)\n}\n\nlet Main = (resolve) =&gt; {\n  return require.ensure([], () =&gt; {\n    resolve(require(&#39;@/components/Main&#39;))\n  }, &#39;ab&#39;)\n}</code></pre><p><strong>简化方法二</strong></p>\n<pre><code>let Header = (resolve) =&gt; {\n  return import(&#39;@/components/Header&#39;)\n}</code></pre><p>这里不支持第三种参数</p>\n"},"371c":function(n,e){n.exports='<p>又一种异步编程解决方法\n内部可以保存多个状态</p>\n<blockquote>\n<p>和普通函数的区别\n1.function关键字与函数名之间有一个星号\n2.函数体内部使用yield表达式，定义不同的内部状态</p>\n</blockquote>\n<pre><code>    function* helloWorldGenerator () {\n        yield &#39;hello&#39;;\n        yield &#39;world&#39;;\n        return &#39;ending&#39;;\n    }\n    var hw = helloWorldGenerator(); // helloWorldGenerator {[[GeneratorStatus]]: &quot;suspended&quot;}</code></pre><p>该函数存有三个状态；\n在这里，调用该方法不会立即执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p>\n<p>必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</p>\n<pre><code>    hw.next();\n    hw.next();\n    hw.next();\n    hw.next();</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-2606b6d71c554ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generator"></p>\n<blockquote>\n<p>它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。</p>\n</blockquote>\n<ul>\n<li>遍历器对象的next方法的运行逻辑如下。</li>\n</ul>\n<p>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</p>\n<p>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</p>\n<p>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</p>\n<p>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。</p>\n<ul>\n<li>yield表达式与return语句区别：\n每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。\n如果return之后，在后面加yield就不会执行，返回undefined;</li>\n</ul>\n<p>Generator 函数不用yield表达式时就变成了一个单纯的暂缓执行函数。</p>\n<blockquote>\n<p>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。\nyield表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>\n<pre><code>function* demo() {\n  console.log(&#39;Hello&#39; + (yield)); // OK\n  console.log(&#39;Hello&#39; + (yield 123)); // OK\n}</code></pre></blockquote>\n<blockquote>\n<p>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号</p>\n<pre><code>function* demo() {\n  foo(yield &#39;a&#39;, yield &#39;b&#39;); // OK\n  let input = yield; // OK\n}</code></pre></blockquote>\n<pre><code>  var arr = [1, [[2, 3], 4], [5, 6]];\n\n  var flat = function* (a) {\n    var length = a.length;\n    for (let i = 0; i &lt; length; i++) {\n      var item = a[i];\n      if (typeof item !== &#39;number&#39;) {\n        yield* flat(item);\n      } else {\n        yield item;\n      }\n    }\n  };\n\n  for (let f of flat(arr)) {\n    console.log(f);\n  }\n// 1, 2, 3, 4, 5, 6</code></pre><h5 id="-iterator-">与Iterator接口的关系</h5>\n<p>任意对象通过赋值[Symbol.iterator]属性，从而具有Iterator接口</p>\n<pre><code>var myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable] // [1, 2, 3]</code></pre><p>Generator函数执行后，返回一个遍历器对象，该对象本身就具有[Symbol.iterator]属性，执行后返回自身。</p>\n<pre><code>function* gen(){\n  // some code\n}\n\nvar g = gen();\n\ng[Symbol.iterator]() === g // true</code></pre><h5 id="next-">next方法</h5>\n<p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n<pre><code>  function* f() {\n    for (var i = 0; true; i++) {\n      // console.log(i)\n      var reset = yield i;\n      console.log(reset)\n      if(reset) {\n        i = -1;\n      }\n    }\n  }\n\n  var g = f();\n  g.next()\n  g.next()\n  g.next()\n  g.next()\n  g.next(true)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-887708563006d038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="yield没有返回值"></p>\n<p>由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。</p>\n<h5 id="for-of-">for--of 循环</h5>\n<p>for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。</p>\n<pre><code>function *foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，\n所以上面代码的return语句返回的6，不包括在for...of循环之中。</code></pre><h5 id="generator-prototype-throw-">Generator.prototype.throw()</h5>\n<p>Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>\n<pre><code>var g = function* () {\n  try {\n    yield;\n  } catch (e) {\n    console.log(&#39;内部捕获&#39;, e);\n  }\n};\n\nvar i = g();\ni.next();\n\ntry {\n  i.throw(&#39;a&#39;);\n  i.throw(&#39;b&#39;);\n} catch (e) {\n  console.log(&#39;外部捕获&#39;, e);\n}\n// 内部捕获 a\n// 外部捕获 b\n</code></pre><p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。</p>\n<p>throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。</p>\n<p>注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p>\n<p>throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。</p>\n<pre><code>var gen = function* gen(){\n  try {\n    yield console.log(&#39;a&#39;);\n  } catch (e) {\n    // ...\n  }\n  yield console.log(&#39;b&#39;);\n  yield console.log(&#39;c&#39;);\n}\n\nvar g = gen();\ng.next() // a\ng.throw() // b\ng.next() // c</code></pre><p>只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>\n<p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p>\n<h5 id="generator-prototype-return-">Generator.prototype.return()</h5>\n<p>Generator函数返回的遍历器对象还有一个return方法，可以返回给定的值，并且终止遍历Generator函数</p>\n<pre><code>function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return(&#39;foo&#39;) // { value: &quot;foo&quot;, done: true }\ng.next()        // { value: undefined, done: true }\n</code></pre><p>上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。\n如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p>\n<p>如果 Generator 函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>\n<pre><code>function* numbers () {\n  yield 1;\n  try {\n    yield 2;\n    yield 3;\n  } finally {\n    yield 4;\n    yield 5;\n  }\n  yield 6;\n}\nvar g = numbers();\ng.next() // { value: 1, done: false }\ng.next() // { value: 2, done: false }\ng.return(7) // { value: 4, done: false }\ng.next() // { value: 5, done: false }\ng.next() // { value: 7, done: true }</code></pre><h4 id="yield-">yield* 表达式</h4>\n<p>如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。\n这个就需要用到yield*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>\n<pre><code>function* inner() {\n  yield &#39;hello!&#39;;\n}\n\nfunction* outer1() {\n  yield &#39;open&#39;;\n  yield inner();\n  yield &#39;close&#39;;\n}\n\nvar gen = outer1()\ngen.next().value // &quot;open&quot;\ngen.next().value // 返回一个遍历器对象\ngen.next().value // &quot;close&quot;\n\nfunction* outer2() {\n  yield &#39;open&#39;\n  yield* inner()\n  yield &#39;close&#39;\n}\n\nvar gen = outer2()\ngen.next().value // &quot;open&quot;\ngen.next().value // &quot;hello!&quot;\ngen.next().value // &quot;close&quot;</code></pre><p>从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*表达式。</p>\n<p>如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>\n<pre><code>function* gen(){\n  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n}\n\ngen().next() // { value:&quot;a&quot;, done:false }</code></pre><p>实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。</p>\n<pre><code>let read = (function* () {\n  yield &#39;hello&#39;;\n  yield* &#39;hello&#39;;\n})();\n\nread.next().value // &quot;hello&quot;\nread.next().value // &quot;h&quot;</code></pre><h5 id="-generator-">作为对象属性的Generator函数</h5>\n<pre><code>let obj = {\n  * myGeneratorMethod() {\n    ···\n  }\n};</code></pre>'},"378b":function(n,e){n.exports="<p>mongod --port 1994 --dbpath d:\\data\\db --auth</p>\n"},"38ab":function(n,e){n.exports='<ul>\n<li>webpack 自定义配置</li>\n</ul>\n<p><del>冒泡排序 算法</del></p>\n<p><a href="https://github.com/Heisinadaze/notes/blob/master/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F.md">冒泡算法</a></p>\n<ol>\n<li><del>angular1 和angular2 的区别</del></li>\n<li>原型链，闭包</li>\n<li>写小程序流程</li>\n<li>vue生命周期</li>\n<li>vuex vue-router</li>\n<li>路由有几种跳转方式</li>\n<li>git 都有哪些常用命令</li>\n<li>cookie 和 session 区别</li>\n<li>如何判断data是一个数组</li>\n<li>针对页面渲染等，有那些优化方法</li>\n<li>node闪退怎么解决</li>\n<li>node缺点有哪些</li>\n<li>ES6有哪些缺点</li>\n<li>垃圾回收机制</li>\n<li>一个完整的http请求</li>\n<li>http状态码</li>\n<li>https如何实现加密</li>\n<li>如何优化图像，图像格式区别（cdn..）</li>\n<li>常用的动画都有哪些</li>\n<li>浏览器渲染页面的过程</li>\n<li>MVC、MVVM理解</li>\n<li>html5 为什么只需要写&lt;! DOCTYPE HTML&gt;?</li>\n<li>常用正则表达式验证邮箱手机号等</li>\n<li>页面导入样式时，使用link和@import 区别</li>\n<li><del>void元素有哪些（空元素： hr\\ br）</del></li>\n<li>CSS实现水平垂直居中</li>\n<li>src、href区别</li>\n<li><del>CSS Hack?</del> 针对不同的浏览器，不同的默认展示效果不用，写相应的css code.</li>\n<li>优雅降级、逐渐增强</li>\n<li>数组去重，求交集，并集，差集；</li>\n<li><del>什么是伪数组，如何转化成标准数组</del> <a href="https://github.com/Heisinadaze/notes/blob/master/nibuzhidaodejs/%E4%BC%AA%E6%95%B0%E7%BB%84.md">伪数组</a></li>\n<li><del>callee和caller区别</del></li>\n<li><del>jquery事件委托方法on,live,delegate区别</del> <a href="https://github.com/Heisinadaze/notes/blob/master/jq/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E5%8C%BA%E5%88%AB.md">事件委托的区别</a></li>\n<li>闭包；</li>\n<li>原型链</li>\n<li>this</li>\n<li>刷新页面，如何保存当前页面的数据</li>\n<li>linux 命令行</li>\n<li>dom和虚拟dom区别 虚拟dom是如何操作的</li>\n<li><del>echarts和highcharts区别</del></li>\n<li><del>web3.js socket.io</del></li>\n<li>css 选择兄弟节点</li>\n<li>第一次刷新页面慢的问题</li>\n</ol>\n'},"38c3":function(n,e){n.exports='<h4 id="-indexof-">类似于indexOf()</h4>\n<p>ES6又提供了三种新方法。用来确定一个字符串是否包含在另一个字符串中。</p>\n<ul>\n<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>\n</li>\n<li><p>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</p>\n</li>\n<li><p>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p>\n<p>第二个参数表示开始搜索的位置</p>\n</li>\n</ul>\n<h4 id="repeat-n-n-">repeat(n) 返回一个新字符串，表示将原字符串重复n次</h4>\n<pre><code>    &#39;hello&#39;.repeat(2.8) // &quot;hellohello&quot;</code></pre><ul>\n<li>参数如果是小数时,会向下取整。</li>\n<li>参数如果是负数或无穷时，会报错</li>\n<li>参数如果是-1到0之间的小数或NaN时，会先取整，取整为0，所以不会报错</li>\n<li>参数如果是字符串，则会先转换成数字。</li>\n</ul>\n<h4 id="-">字符串自动补全</h4>\n<ul>\n<li>padStart()用于头部补全，padEnd()用于尾部补全.<pre><code>   &#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;</code></pre><blockquote>\n<p>第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。\n如果省略第二个参数，默认使用空格补全长度</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="-">模板字符串</h4>\n<p> 在使用模板字符串时，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</p>\n<pre><code>     let str = `\n         &lt;ul&gt;\n             &lt;li&gt;first&lt;/li&gt;\n             &lt;li&gt;second&lt;/li&gt;\n         &lt;/ul&gt;`.trim()\n     console.log(str)</code></pre><blockquote>\n<p>模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数。\n```\n     function fn() {\n         return &quot;Hello World&quot;;\n     }</p>\n</blockquote>\n<pre><code> console.log(`foo ${fn()} bar`) // foo Hello World bar</code></pre><pre><code>#### 标签模板\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</code></pre><pre><code>alert`123`\n等同于\nalert(123)</code></pre><p>```#### 类似于indexOf()\nES6又提供了三种新方法。用来确定一个字符串是否包含在另一个字符串中。</p>\n<ul>\n<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>\n</li>\n<li><p>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</p>\n</li>\n<li><p>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</p>\n<p>第二个参数表示开始搜索的位置</p>\n</li>\n</ul>\n<h4 id="repeat-n-n-">repeat(n) 返回一个新字符串，表示将原字符串重复n次</h4>\n<pre><code>    &#39;hello&#39;.repeat(2.8) // &quot;hellohello&quot;</code></pre><ul>\n<li>参数如果是小数时,会向下取整。</li>\n<li>参数如果是负数或无穷时，会报错</li>\n<li>参数如果是-1到0之间的小数或NaN时，会先取整，取整为0，所以不会报错</li>\n<li>参数如果是字符串，则会先转换成数字。</li>\n</ul>\n<h4 id="-">字符串自动补全</h4>\n<ul>\n<li>padStart()用于头部补全，padEnd()用于尾部补全.<pre><code>   &#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;</code></pre><blockquote>\n<p>第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。\n如果省略第二个参数，默认使用空格补全长度</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="-">模板字符串</h4>\n<p> 在使用模板字符串时，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</p>\n<pre><code>     let str = `\n         &lt;ul&gt;\n             &lt;li&gt;first&lt;/li&gt;\n             &lt;li&gt;second&lt;/li&gt;\n         &lt;/ul&gt;`.trim()\n     console.log(str)</code></pre><blockquote>\n<p>模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数。\n```\n     function fn() {\n         return &quot;Hello World&quot;;\n     }</p>\n</blockquote>\n<pre><code> console.log(`foo ${fn()} bar`) // foo Hello World bar</code></pre><pre><code>#### 标签模板\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</code></pre><pre><code>alert`123`\n等同于\nalert(123)</code></pre><p>```</p>\n'},"3a0e":function(n,e){n.exports='<p>在store/action.js</p>\n<p>router.replace(url)</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-3085335c7dad19de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>layout/app.vue</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-dbddd9a1644b94ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>不做初始化的页面中，可以直接在app.vue 中</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-e434d69d2168c3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},"3ad9":function(n,e){n.exports='<h3 id="-">获取内容</h3>\n<pre><code>.text() // 设置或返回所选元素的文本内容\n\n.html() // 设置或返回所选元素的内容（包括html标记）\n\n.val() // 设置或返回表单字段的值\n</code></pre><p><em>回调函数：</em>\n两个参数： 被选中列表中当前元素的下标，原始值</p>\n<pre><code>$(&#39;button1&#39;).click(function() {\n    $(&#39;#test1&#39;).text(function(i, orgText) {\n        return `Old text: ${orgText} New text: Hello world! (index: i);`\n    })\n})\n</code></pre><h3 id="-">获取属性</h3>\n<pre><code>.attr(&#39;属性&#39;) // 获取元素属性值\n\n修改属性值\n$(&#39;.link&#39;).attr(&#39;href&#39;, &#39;http://www.baidu.com&#39;);\n\n设置多个值\n$(&#39;.link&#39;).attr({\n    &#39;href&#39;: &#39;http://www.baidu.com&#39;,\n    &#39;title&#39;: &#39;a html&#39;\n});</code></pre><p><em>回调函数：</em>\n两个参数： 被选中列表中当前元素的下标，原始值</p>\n<pre><code>$(&#39;button1&#39;).click(function() {\n    $(&#39;#test1&#39;).text(function(i, origValue) {\n        return `${origValue} Hello world!`;\n    })\n})\n</code></pre><h3 id="-">添加元素</h3>\n<p><em>add</em></p>\n<p>向匹配的元素集添加元素</p>\n<pre><code>.add(selector) // 字符串值，把选到的选择器都添加进去\n\n.add(elements) // 添加一个或多个元素\n\n.add(html) // 添加html片段\n\n.add(jQueryObject)\n\n.add(selector, context) // context: 选择器开始进行匹配的位置\n</code></pre><h6 id="-html-">添加新的HTML内容</h6>\n<pre><code>.append(); // 在被选元素的结尾插入内容，添加多个时，以&#39;,&#39;分隔\n\n.prepend(); // 在被选元素的开头插入内容\n\n.after(); // 在被选元素之后插入内容\n\n.before(); // 在被选元素之前插入内容\n\nlet text1 = &#39;&lt;p&gt;文本1&lt;/p&gt;&#39; // 用html创建元素\nlet text2 = &#39;$(&quot;&lt;p&gt;&lt;/p&gt;&quot;).text(&quot;Text2&quot;)&#39; // 用jq创建元素\nlet text3 = document.createElement(&quot;p&quot;);\ntext3.innerHTML = &#39;Text.&#39;; // 用原生js创建元素\n\n$(&#39;p&#39;).append(text1, text2, text3);</code></pre><h3 id="-">删除内容</h3>\n<pre><code>.empty() // 从被选元素中删除所有子元素\n\n.remove() // 删除被选元素，及其子元素\n\n\n过滤被删除的元素\nremove() 方法接收一个参数，允许对被删元素进行过滤\n\n</code></pre><hr>\n<h3 id="-css">操作css</h3>\n<pre><code>.addClass(); // 向被选元素添加一个或多个类\n\n.removeClass(); // 从被选元素删除一个或多个类\n\n.toggleClass(); // 对被选元素进行添加/删除类的切换操作\n\n.css(); // 设置或返回样式属性\n</code></pre><h3 id="-">操作元素尺寸</h3>\n<pre><code>.width(); // 设置或返回元素的宽度(不包括内边距、边框、外边距)\n\n.height();\n\n.innerWidth(); // 返回元素的宽度（包括内边距）\n\n.innerHeight();\n\n.outerWidth(); // 返回元素的宽度（包括内边距和边框）\n\n.outerHeight();</code></pre>'},"3ddc":function(n,e){n.exports='<p><a href="https://account.aliyun.com">https://account.aliyun.com</a></p>\n<p><img src="https://github.com/Heisinadaze/notes/blob/master/http/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180531205656.png" alt="阿里云"></p>\n'},"44e0":function(n,e){n.exports='<h2 id="-">了解运行情况，查看其性能</h2>\n<p><code>mongostat</code> / <code>mongotop</code></p>\n<ul>\n<li>mongostat 间隔获取当前运行状态，并输入，用于数据库突然变慢或其他一些问题。</li>\n</ul>\n<pre><code>mongostat</code></pre><ul>\n<li>mongotop 用来跟踪一个实例</li>\n</ul>\n<pre><code>mongotop\n\nmongotop 10 (等待时长： 10s)</code></pre><p>输出字段说明</p>\n<ol>\n<li><p>ns 数据库命名空间，后者结合了数据库名称和集合</p>\n</li>\n<li><p>db 数据库名称，名为.的数据库针对全局锁定</p>\n</li>\n<li><p>total mongod花费时间工作在这个时间的总和</p>\n</li>\n<li><p>read 执行读取操作时间</p>\n</li>\n<li><p>write 执行写操作时间</p>\n</li>\n</ol>\n'},"44e8":function(n,e){n.exports='<h1 id="-">安装</h1>\n<p><a href="https://www.mongodb.com/">官网地址</a></p>\n<p>百度云存windows-64安装包\n<code>链接：https://pan.baidu.com/s/1mkgOEm8 密码：ttpf</code></p>\n<p>直接下载msi安装</p>\n<p><img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/1.png" alt="_"></p>\n<p>自定义安装目录</p>\n<p>在c: 目录下新建data 文件夹</p>\n<p>在data文件夹下新建db文件夹和log文件夹</p>\n<p>然后在安装的目录下，进入bin文件夹，执行</p>\n<pre><code>mongod --dbpath c:\\data\\db</code></pre><p>成功会显示</p>\n<p><img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/2.png" alt="_"></p>\n<p>打开一个新的命令行</p>\n<p>在安装目录下新建一个<code>mongod.cfg</code>文件，</p>\n<pre><code>systemLog:\n    destination: file\n    path: c:\\data\\log\\mongod.log\nstorage:\n    dbPath: c:\\data\\db\n</code></pre><p>在bin目录下，执行命令</p>\n<pre><code>mongod.exe --config &quot;安装目录\\mongod.cfg&quot; --install</code></pre><p>然后启动</p>\n<pre><code>mongo.exe</code></pre>'},"453c":function(n,e,t){"use strict";var o=t("6a9b"),r=t.n(o);r.a},"464c":function(n,e){n.exports='<h3 id="-">更新数组</h3>\n<ul>\n<li>push()</li>\n<li>pop()</li>\n<li>shift()</li>\n<li>unshift()</li>\n<li>splice()</li>\n<li>sort()</li>\n<li>reverse()</li>\n</ul>\n<p>以上方法可以触发视图更新</p>\n<ul>\n<li>filter()</li>\n<li>concat()</li>\n<li>slice()</li>\n</ul>\n<p>这三个方法不会出发，但是会返回一个新数组，用新数组替换旧数组</p>\n<h3 id="-set">利用索引替换某一项时，用$set</h3>\n<h3 id="-">修改数组长度时：</h3>\n<pre><code>arr.splice(newLength)</code></pre><h3 id="-">给已有对象添加多个新属性时</h3>\n<pre><code>this.obj = Object.assign({}, this.obj, {\n  opt1: &#39;&#39;,\n  opt2: &#39;&#39;\n})</code></pre><h3 id="v-model-">v-model 修饰符</h3>\n<ul>\n<li>.lazy 在change事件时进行同步</li>\n<li>.number 将用户输入的值转换为数字</li>\n<li>.trim 过滤用户输入的首尾的空白字符</li>\n</ul>\n'},"477e":function(n,e){n.exports='<h3 id="element-ui">element-ui</h3>\n<p>安装方式</p>\n<pre><code>npm i element-ui -S</code></pre><p>在main.js中引入</p>\n<pre><code>import ElementUI from &#39;element-ui&#39;</code></pre><p>CDN</p>\n<pre><code>&lt;!-- 引入样式 --&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-default/index.css&quot;&gt;\n&lt;!-- 引入组件库 --&gt;\n&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</code></pre><p>提供了较多样式标签，\n官网\n<a href="http://element.eleme.io/#/zh-CN/component/quickstart">http://element.eleme.io/#/zh-CN/component/quickstart</a></p>\n<p>关于scss</p>\n<p>安装sass</p>\n<pre><code>npm install sass-loader node-sass webpack --save-dev</code></pre><p>如果引用了scss,产生如下的错误</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-d0112e16b98622ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌浏览器"></p>\n<p>解决办法：\nnpm install -g cnpm --registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p>\n<p>cnpm install --save-dev node-sass</p>\n<p>运行这两句代码</p>\n<pre><code>&lt;!-- 阻止单击事件冒泡 --&gt;\n&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\n&lt;!-- 修饰符可以串联  --&gt;\n&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 只有修饰符 --&gt;\n&lt;form v-on:submit.prevent&gt;&lt;/form&gt;\n\n&lt;!-- 添加事件侦听器时使用事件捕获模式 --\n&lt;div v-on:[click.capture=](http://click.capture=)&quot;doThis&quot;&gt;...&lt;/div&gt;\n\n&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n&lt;!-- 点击事件将只会触发一次 --&gt;\n&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</code></pre><p>点击事件的按键别名</p>\n<ul>\n<li>.enter</li>\n<li>.tab</li>\n<li>.delete(捕获删除和退格键)</li>\n<li>.esc</li>\n<li>.space</li>\n<li>.up</li>\n<li>.down</li>\n<li>.left</li>\n<li>.right</li>\n<li>.ctrl</li>\n<li>.alt</li>\n<li>.shift</li>\n<li>.meta\n.left - (2.2.0) 只当点击鼠标左键时触发。\n.right - (2.2.0) 只当点击鼠标右键时触发。\n.middle - (2.2.0) 只当点击鼠标中键时触发。</li>\n</ul>\n<blockquote>\n<p>注: 若添加不成功，在事件后添加native\n例如：</p>\n<pre><code>@keyup.enter.native=&quot;事件名&quot;</code></pre><p>一般原生的标签里面不需要加</p>\n</blockquote>\n<p>也可以通过全局config.keyCode对象自定义按键修饰符别名</p>\n<p>//可以使用v-on:keyCodes.f1 = 112;</p>\n<p>组合键</p>\n<pre><code>&lt;!-- Alt + C --&gt;\n&lt;input @keyup.alt.67=&quot;clear&quot;&gt;\n&lt;!-- Ctrl + Click --&gt;\n&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</code></pre><p>在vue2.0开始.已经明确规定给自定义组件绑定原生事件时，必须是使用native修饰符,另外用的比较多的修饰符是 .stop （阻止冒泡事件）.prevent （阻止默认事件）。</p>\n<p>vue-elementui</p>\n'},"48a4":function(n,e){n.exports='<h1 id="md5">MD5</h1>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-928997435fcb8aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-8dbdca399a368fb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>使用\n引入\nimport upload from &#39;../../md5/uploadMd5&#39;</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-3d0e15546063c06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传文件"></p>\n<p>在</p>\n<pre><code>:before-upload=&quot;beforeAvatarUpload&quot;\n\nbeforeAvatarUpload () {\n\n}\n</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-73022dcc27e304d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>返回的参数中success=true表示后台已有该文件\n就不会再上传。</p>\n'},"494c":function(n,e){n.exports="<p>要求：弹出框出现，弹出框的内容滚动，但是dom层不随着弹出框的滚动而滚动，在弹层上滚动时整个页面也不滚动</p>\n<pre><code>&lt;section class=&quot;father&quot;&gt;\n    &lt;section class=&quot;content-body&quot;&gt;\n\n    &lt;/section&gt;\n    &lt;section class=&quot;layout&quot;&gt;\n\n    &lt;/section&gt;\n    &lt;section class=&quot;layout-body&quot;&gt;\n\n    &lt;/section&gt;\n&lt;/section&gt;\n\n.father{\n    height: 533px;\n    overflow-y: scroll;\n    //页面高度设置为屏幕高度，正常情况下超出滚动\n}\n\n.content-body{\n    height: 533px;\n    overflow-y: scroll;//内容高度设置为屏幕高度，正常情况下超出滚动\n}\n\n.layout{\n    height: 100%;\n    width: 100%;\n    position: fixed;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.7);\n    overflow: hidden;\n    z-index: 1000000;\n}\n\n.layout-body{\n    height: 50%;\n    width: 100%;\n    position: fixed;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.7);\n    overflow: hidden;\n    z-index: 1000001;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>"},"4bc8":function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-761f671b9e24cfa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>首先新建文件夹views，在里面新建五个文件</p>\n<p>在app.vue里面</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-ac30acd7512a1136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>在路由里面\nrouter  index.js</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-09184522f672f135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},5379:function(n,e){n.exports="<p>new <code>webpack.dll.conf.js</code></p>\n<pre><code>// const path = require(&quot;path&quot;);\n// const webpack = require(&quot;webpack&quot;);\n// const pkg = require(&#39;../package.json&#39;); // 引入package.json\n// module.exports = {\n//     entry: {\n//         vendor: Object.keys(pkg.dependencies) // 遍历package.json的所有依赖包\n//     },\n//     output: {\n//         path: path.join(__dirname, &#39;dll&#39;), // 生成的文件存放路径\n//         filename: &#39;[name].dll.js&#39;, // 生成的文件名字(默认为vendor.dll.js)\n//         library: &#39;[name]_library&#39;  // 生成文件的映射关系，与下面DllPlugin中配置对应\n//     },\n//     node: {\n//       fs: &#39;empty&#39;\n//     },\n//     plugins: [\n//         new webpack.DllPlugin({\n//             // 会生成一个json文件，里面是关于dll.js的一些配置信息\n//             path: path.join(__dirname, &#39;dll&#39;, &#39;[name]-manifest.json&#39;),\n//             name: &#39;[name]_library&#39;, // 与上面output中配置对应\n//             context: __dirname // 上下文环境路径（必填，为了与DllReferencePlugin存在与同一上下文中）\n//         })\n//     ]\n// };\n\nconst path = require(&#39;path&#39;);\nconst webpack = require(&#39;webpack&#39;);\nconst CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;);\nconst pkg = require(&#39;../package.json&#39;);\n\nmodule.exports = {\n    entry: {\n        vendor: Object.keys(pkg.dependencies)\n    },\n    output: {\n        path: path.join(__dirname, &#39;../www/dll&#39;), // 生成的文件存放路径\n        filename: &#39;[name].dll.js&#39;, // 生成的文件名字(默认为vendor.dll.js)\n        library: &#39;[name]_[chunkhash]&#39; // 生成文件的映射关系，与下面DllPlugin中配置对应\n    },\n    plugins: [\n        new webpack.DllPlugin({\n            // 会生成一个json文件，里面是关于dll.js的一些配置信息\n            path: path.join(__dirname, &#39;../www/dll&#39;, &#39;[name]-manifest.json&#39;),\n            name: &#39;[name]_[chunkhash]&#39;, // 与上面output中配置对应\n            context: __dirname // 上下文环境路径（必填，为了与DllReferencePlugin存在与同一上下文中）\n        }),\n        new webpack.optimize.UglifyJsPlugin(),\n        new CleanWebpackPlugin([&#39;dll&#39;])\n    ]\n}\n</code></pre><p>edit <code>webpack.dev.conf.js</code></p>\n<pre><code>const UglifyJSPlugin = require(&#39;uglifyjs-webpack-plugin&#39;);\n\n    new UglifyJSPlugin(),\n    new webpack.DllReferencePlugin({\n      context: __dirname, // 与DllPlugin中的那个context保持一致\n      manifest: require(&#39;./dll/vendor-manifest.json&#39;) // 下面这个地址对应webpack.dll.config.js中生成的那个json文件的路径\n    })</code></pre><p>edit <code>package.json</code></p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;dll&quot;: &quot;webpack -p --config ./build/webpack.dll.config.js --progress --profile --colors&quot;,\n}</code></pre><p>edit <code>index.html</code></p>\n<pre><code>  &lt;script src=&quot;./dll/vendor.dll.js&quot;&gt;&lt;/script&gt;</code></pre><p><code>npm run dll</code></p>\n<p><code>npm run build</code></p>\n"},5419:function(n,e){n.exports="<pre><code>@keyframes name{\n    from,10%{}\n    to{}\n}\n\nanimation:name 2s infinite;\nanimation-name // 动画名称（见名知意）\n\n\n    animation-duration // 动画时间\n    animation-iteration-count // 动画次数：infinite\n\n    animation-delay // 动画延迟（连续动画时使用）\n    animation-fill-mode // 动画播放开始和结束的时候是否停留在第一帧和最后一帧\n    animation-direction // 动画的方向\n    animation-play-state // 动画状态： paused running\n    animation-timing-function // 速度曲线\n</code></pre>"},"62e2":function(n,e){n.exports='<p>一、关于数据绑定</p>\n<ul>\n<li>Angular \n使用双向绑定即：界面的操作能实时反映到数据，数据的变更能实时展现到界面。</li>\n</ul>\n<blockquote>\n<p>原理：\n$scope变量中使用脏值检查来实现。\n$scope.$watch函数，监视一个变量的变化。函数有三参数，”要观察什么”，”在变化时要发生什么”,以及你要监视的是一个变量还是一个对象。\n使用ng-model时，你可以使用双向数据绑定。 \n调用$scope.$watch时只为它传递了一个参数，无论作用域中的什么东西发生了变化，这个函数都会被调用。在ng-model中，这个函数被用来检查模型和视图有没有同步，如果没有同步，它将会使用新值来更新模型数据。</p>\n</blockquote>\n<p>双向绑定的三个重要方法：</p>\n<p>$scope.$apply()</p>\n<p>$scope.$digest()</p>\n<p>$scope.$watch()</p>\n<p>（脏检测）是用来检查绑定的scope中的对象的状态的，例如，在js里创建了一个对象，并且把这个对象绑定在scope下，这样这个对象就处于digest loop中，loop通过遍历这些对象来发现他们是否改变，如果改变就会调用相应的处理方法来实现双向绑定</p>\n<ul>\n<li>Vue 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。</li>\n</ul>\n<p>脏检测的利弊\n和ember.js等技术的getter/setter观测机制相比（优）： \ngetter/setter当每次对DOM产生变更，它都要修改DOM树的结构，性能影响大，Angular会把批量操作延时到一次更新，性能相对较好。</p>\n<p>和Vue相比（呈现劣势）\nVue.js 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。Angular，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。 Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。Vue.js 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系。唯一需要做的优化是在 v-for 上使用 track-by。</p>\n<p>React-单向数据流\nMVVM流的Angular和Vue，都是通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后，再根据配置好的规则去，从数据更新界面状态。\nReact推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。</p>\n<p>React和Vue都可以配合Redux来管理状态数据。</p>\n<p>二、 视图渲染</p>\n<ul>\n<li><p>AngularJS的工作原理是:HTML模板将会被浏览器解析到DOM中, DOM结构成为AngularJS编译器的输入。AngularJS将会遍历DOM模板, 来生成相应的NG指令,所有的指令都负责针对view(即HTML中的ng-model)来设置数据绑定。因此, NG框架是在DOM加载完成之后, 才开始起作用的</p>\n</li>\n<li><p>React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的<a href="http://lib.csdn.net/base/datastructure">数据结构</a>。当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁。</p>\n<p><strong>Virtual DOM</strong> 提供了函数式的方法描述视图，<strong>它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步</strong>。它也开辟了 <a href="http://lib.csdn.net/base/javascript">JavaScript</a> 同构应用的可能性。</p>\n<p>在超大量数据的首屏渲染速度上，React 有一定优势，因为 Vue 的渲染机制启动时候要做的工作比较多，而且 React 支持服务端渲染。</p>\n<p>React 的 Virtual DOM 也需要优化。复杂的应用里可以选择 1. 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render；2. Components 尽可能都用 pureRenderMixin，然后采用 Flux 结构 + Immutable.js。其实也不是那么简单的。相比之下，Vue 由于采用依赖追踪，默认就是优化状态：动了多少数据，就触发多少更新，不多也不少。</p>\n<p>React 和 Angular 2 都有服务端渲染和原生渲染的功能。</p>\n<p>Vue.js 不使用 Virtual DOM 而是使用真实 DOM 作为模板，数据绑定到真实节点。Vue.js 的应用环境必须提供 DOM。Vue.js 有时性能会比 React 好**，而且几乎不用手工优化。</p>\n</li>\n</ul>\n<p>三 、性能与优化</p>\n<p>   性能方面，这几个主流框架都应该可以轻松应付大部分常见场景的性能需求，区别在于可优化性和优化对于开发体验的影响。Vue 的话需要加好 track-by 。React 需要 shouldComponentUpdate 或者全面 Immutable，Angular 2 需要手动指定 change detection strategy。从整体趋势上来说，浏览器和手机还会越变越快，框架本身的渲染性能在整个前端性能优化体系中，会渐渐淡化，更多的优化点还是在构建方式、缓存、图片加载、网络链路、HTTP/2 等方面。</p>\n'},6501:function(n,e){n.exports='<p><a href="https://github.com/jibrelnetwork/ethereum-qr-code">git</a></p>\n<h3 id="use">use</h3>\n<ul>\n<li>生成二维码 (base64格式)</li>\n</ul>\n<blockquote>\n<p>扫出来的格式大致： &#39;ethereum:0x7cB57B5A97eAbe94205C07890BE4c1aD31E486A8</p>\n</blockquote>\n<pre><code>import EthereumQRPlugin from &#39;ethereum-qr-code&#39;\n\n        const qr = new EthereumQRPlugin()\n        qr.toDataUrl({\n          to: this.info.name2\n        }, {\n          selector: &#39;#my-qr-code&#39;\n        }).then(res =&gt; {\n          this.imgUrl = res.dataURL\n        })</code></pre>'},"651e":function(n,e){n.exports='<blockquote>\n<p>react 用于构建用户界面的javascript;</p>\n</blockquote>\n<p>(npm start)</p>\n<p>首先需要引入三个js文件</p>\n<ul>\n<li>react.js</li>\n<li>react-dom.js</li>\n<li>browser.js\n中文官网 <a href="http://react-cn.com">http://react-cn.com</a></li>\n</ul>\n<h3 id="-">基本语法</h3>\n<p>由于使用了jsx语法(javascript+Xml,browser.js提供)，所以script的type值如下：</p>\n<pre><code>&lt;script type=&quot;text/babel&quot;&gt;&lt;/script&gt;</code></pre><p>Xml一般用来做数据保存\nreact-dom.js提供了一个方法，ReactDOM</p>\n<pre><code>ReactDOM.render(&lt;h1&gt;hello react&lt;/h1&gt;,document.getElementById(&#39;container&#39;))</code></pre><p>第一个参数是要渲染的内容，第二个参数是要时使用的容器</p>\n<p>如果第一个参数内容较多的话，可以赋给一个变量，</p>\n<pre><code>let h1=&lt;h1&gt;hello react&lt;/h1&gt;，\nReactDOM.render(h1,document.getElementById(&#39;container&#39;))</code></pre><p>自定义组件，createClass方法\n需要拿一个变量接受返回值,变量首字母必须要大写</p>\n<pre><code>    let Wumai=React.createClass({\n        render(){\n            return &lt;div&gt;雾霾走了，天气好了&lt;/div&gt;\n        }\n    })</code></pre><p>自定义组件引入时，要写成一个单标签的形式</p>\n<pre><code>ReactDOM.render(&lt;Wumai/&gt;,document.getElementById(&#39;container&#39;))</code></pre><p>若想要在里面插入内容，可以写成双标签，把内容放在双标签里面；如想要传参进去，如<Wumai count={10} />的形式；\n如果觉得麻烦的话，要是用变量的形式</p>\n<pre><code>let wumai=&lt;Wumai/&gt;\nReactDOM.render(wumai,document.getElementById(&#39;container&#39;))</code></pre><p>可以把容器提前获取出来</p>\n<pre><code>let container=document.getElementById(&#39;container&#39;);</code></pre><p>在react中，要实现angular的ng-transclude类似功能，直接放到标签里面就可以了</p>\n<pre><code>    let SmallBox=React.createClass({\n        render(){//可以把渲染内容放到一个小括号里面\n            return (\n                    &lt;div&gt;这是一个小盒子&lt;/div&gt;\n                )\n        }\n    })\n    let BigBox=React.createClass({\n        render(){\n            return (\n                &lt;div&gt;\n                    &lt;h1&gt;这是大盒子&lt;/h1&gt;\n                    &lt;SmallBox/&gt;\n                    &lt;SmallBox/&gt;\n                &lt;/div&gt;\n            )\n        }\n    })\n    ReactDOM.render(&lt;BigBox /&gt;,container)</code></pre><ul>\n<li>列表的渲染</li>\n</ul>\n<pre><code>    let List=React.createClass({\n        render(){\n            let list=[\n                &lt;h3 key={&#39;a&#39;}&gt;小明&lt;/h3&gt;,\n                &lt;h3 key={2}&gt;小红&lt;/h3&gt;,\n                &lt;h3 key={3}&gt;小猪&lt;/h3&gt;\n            ]\n\n            return (\n                &lt;div&gt;\n                    &lt;h1&gt;列表渲染&lt;/h1&gt;\n                    {list}\n                &lt;/div&gt;\n            )\n        }\n    })\n    ReactDOM.render(&lt;List/&gt;,document.getElementById(&#39;container&#39;))</code></pre><p>数组渲染时，每个数组需要一个key;\n这是一个数组，不要忘记加逗号，并且key值不可以重复，若里面是对象，先用for循环遍历，把它切换成这样的类型;或使用map方法遍历</p>\n<h3 id="react-template">react-template</h3>\n<p>安装react-template\n进入react-template文件夹\nnpm start 默认启动8080端口，在浏览器打开<a href="http://localhost:8080">http://localhost:8080</a></p>\n<p>把要写的页面都放在app/components下，同App同级;\n在里面自定义文件demo1.js，</p>\n<pre><code>import React,{Component} from &#39;react&#39;;\nexport default class extends Compinent{\n    render () {\n        let list=[\n            &lt;h1&gt;小明&lt;/h1&gt;,\n            &lt;h1&gt;小明&lt;/h1&gt;,\n            &lt;h1&gt;小明&lt;/h1&gt;\n        ]\n        return (\n            &lt;div&gt;{list}&lt;/div&gt;\n        )\n    }\n}</code></pre><p>在main.js文件中导入</p>\n<pre><code>import demo1 from &#39;./components/demo1&#39;\n\nrender(&lt;demo1/&gt;, document.getElementById(&#39;root&#39;))\n</code></pre><ul>\n<li>引入css样式</li>\n</ul>\n<p>导入外部样式表\n新建一个css文件,在compponents文件夹下:</p>\n<pre><code>.container{\n    width:400px;\n    height:250px;\n    background-color:#afa;\n}</code></pre><p>在demo.js中</p>\n<pre><code>import Styles from &#39;./demo.css&#39;;\n\nexprot default class extends Component{\n    render (){\n        return (\n            &lt;div className={Styles.container}&gt;&lt;/div&gt;\n        )\n    }\n}</code></pre><p>使用内部样式表\n在demo.js中</p>\n<pre><code>let StyleSheet={\n    title:{\n        fontSize:24,\n        color:&#39;green&#39;\n    }\n}\n要用驼峰命名法，且不加单位</code></pre><p>使用:</p>\n<pre><code>exprot default class extends Component{\n    render (){\n        return (\n            &lt;div className={Styles.container}&gt;\n                &lt;h1 style={StyleSheet.title}&gt;hello&lt;/h1&gt;\n\n                //附带一个行内样式\n                &lt;h3 style={{color:&#39;blue&#39;}}&gt;react&lt;/h3&gt;\n            &lt;/div&gt;\n        )\n    }\n}\n//自定义行内属性用{{}}:外层大括号用来输出，里层大括号是一个对象</code></pre><ul>\n<li>传参</li>\n</ul>\n<pre><code>class Header extends Component{\n    render(){\n        return (\n            &lt;div&gt;你好{this.props.title}&lt;/div&gt;\n        )\n    }\n}\n&lt;Header title=&quot;小明&quot; /&gt;</code></pre><p>通过this.props获取参数\n这样可以传参，但是有一个缺陷\nprops是固定不变的，要想传一个变量，就用到state;</p>\n<p>下面重新写一个demo.js</p>\n<pre><code>export default class exrends Component{\n\n    constructor(props){\n        //构造函数调用\n        super(props);\n        this.state:0\n    }\n\n    componentDidMount(){\n        //这个方法会在组件加载成功之后调用\n        //写一个定时器，让count持续++;\n        //这里的类是_class;\n        let self=this;\n        setInterval(function(){\n            //这里的this就是window\n            self.state.count++;\n            console.log(self.state.count);\n            //这样是不行的，这里不允许直接操作state，提供了一个方法\n            self.setState({\n                count:self.state.count++;\n            })\n        })\n    }\n    render(){\n        //渲染\n        return (\n            &lt;div&gt;\n                &lt;div&gt;{this.state.count}&lt;/div&gt;\n            &lt;/div&gt;\n        )    \n    }\n}</code></pre><blockquote>\n<p>如果想要改变this的指向,有两种方法：\n1用一个变量在外面就收this\n2在函数后面加bind\nsetInterval(function(){\n    this//这样，里面的this就和外面的this一致了\n}.bind(this),1000)</p>\n</blockquote>\n<p>把上面的demo数据换成对象形式:</p>\n<pre><code>export default class extends Component{\n    constructor (props){\n        super(props);\n        this.state={\n            data:[\n                {name:&#39;小明&#39;,id:0},\n                {name:&#39;小红&#39;,id:1}\n            ],\n            renderData:[]//用来接收转换之后的数据\n        }\n    }\n    componentDidMount(){\n        let data=this.state.data;\n        let newdata=[];\n        for(let i=0;i&lt;data.length;i++){\n            let name=data[i].name;\n            let id=data[i].id;\n            let comp=&lt;div key={id}&gt;{name}&lt;/div&gt;\n            newdata.push(comp);\n        }\n        this.setState({\n            renderData:newdata\n        })\n    }\n    render(){\n        return (\n            &lt;div&gt;\n                &lt;h1&gt;列表渲染&lt;/h1&gt;\n                &lt;div&gt;{this.state.renderData}&lt;/div&gt;\n            &lt;/div&gt;\n        )\n    }\n}</code></pre><p>就上面的demo,改变componentDidMount中的for循环，使用map方法</p>\n<pre><code>componentDidMount(){\n    let data=this.state.data;\n    let newdata=[];\n    data.map(function(item){\n        console.log(item);//遍历数组中的每一条元素\n        return (&lt;div key={item.id}&gt;{item.name}&lt;/div&gt;)\n    })\n    this.setState({\n        renderData:newdata\n    })\n}\n</code></pre><ul>\n<li>使用网络请求：</li>\n</ul>\n<p>1.可以使用原生的ajax封装的方法;\n2.也可以使用jq封装的方法;\n3.还可以使用fetch方法，在GitHub上有</p>\n<p><code>npm install whatwg-fetch --save</code>\n<code>cd whatwg-fetch</code>\n<code>import &#39;whatwg-fetch&#39;</code></p>\n<pre><code>使用：\nfetch(url).then(function(res){\n    return res.json()//类似于JSON.parse\n}).then(function(res){\n    console.log(res);\n})\n</code></pre><p>路由\n写到main.js中</p>\n<pre><code>import {Router,Route,IndexRoute,Link,hashHistory,IndexLink,browserHistory} from &#39;react-router&#39;\n\nhashHistory与browserHistory的区别：\n跳转时url是否显示#\n\nconst ACTIVE={color:&#39;red&#39;}//选中的样式\n\nlet App=({children})=&gt;(\n    &lt;div&gt;\n        &lt;h1&gt;APP&lt;/h1&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;Link  to=&quot;/home&quot;  activeStyle={ACTIVE}&gt;home&lt;/Link&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;Link  to=&quot;/list&quot;  activeStyle={ACTIVE}&gt;list&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        {children}\n    &lt;/div&gt;\n)\nlet Home=()=&gt;(\n    &lt;div&gt;\n        &lt;h1&gt;这是home页面&lt;/h1&gt;\n    &lt;/div&gt;\n)\nlet List=()=&gt;(\n    &lt;div&gt;\n        &lt;h1&gt;这是list页面&lt;/h1&gt;\n    &lt;/div&gt;\n)\n\n编辑路由\nlet router=(&lt;Router history={hashHistory})&gt;\n    &lt;Router path=&quot;/&quot; component={App}&gt;\n        &lt;IndexRouter component={Home}/&gt;//默认显示页面\n        &lt;Route path=&quot;/home&quot; component={Home}/&gt;\n        如果有子路由的话，把单标签改为双标签，把子路由插进去\n        &lt;Route path=&quot;/list&quot; component={List}&gt;\n            &lt;IndexRouter component={One}/&gt;\n            &lt;Route path=&quot;/list/one&quot; component={One}/&gt;\n        &lt;/Route&gt;\n    &lt;/Router&gt;\n&lt;/Router&gt;)\n\n</code></pre>'},6910:function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-8090eb10e7aa93f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="谷歌"></p>\n<pre><code>        div {\n            width: 200px;\n            display: -webkit-box;\n            font-size: 14px;\n            line-height: 18px;\n            overflow: hidden;\n            text-overflow: ellipsis; \n            -webkit-line-clamp: 2; //设置行数\n            -webkit-box-orient: vertical;\n        }\n\n\n</code></pre>'},"6a9b":function(n,e,t){},"6b5a":function(n,e){n.exports='<h3 id="-">特殊字符：</h3>\n<ul>\n<li><code>\\b</code>: 只匹配一个位置，（单词分界处）;</li>\n<li><code>.</code>: 匹配除了换行符意外的任意字符;</li>\n<li><code>*</code>: 匹配数量; (<code>.*</code>表示任意数量的不包含换行的字符 <code>&gt;= 0</code>)</li>\n<li><code>+</code>: 同<code>*</code>,(<code>&gt;= 1</code>);</li>\n<li><code>?</code>: 同<code>*</code>,(<code>=== 0 || === 1</code>);</li>\n<li><code>\\d</code>: 匹配一位数字;</li>\n<li><code>\\D</code>: 反义的<code>d</code>,匹配任意非数字;</li>\n<li><code>{2}</code>: 同<code>*</code>表示重复匹配两次(<code>{5, 12}</code>表示5到12位, <code>{2,}</code>表示重复两次以上);</li>\n<li><code>\\s</code>: 匹配任意空白符，包括空格，制表符，换行符，中文全角空格等;</li>\n<li><code>\\S</code>: 反义的<code>\\s</code>,匹配任意不是空白符的字符;</li>\n<li><code>\\w</code>: 匹配字母或数字或下划线或汉字等;</li>\n<li><code>\\W</code>: 反义的<code>\\w</code>,匹配任意的不是字母，数字，下划线，汉字的字符;</li>\n<li><code>^</code>: 匹配字符串的开始;</li>\n<li><code>$</code>: 匹配字符串的结束;</li>\n<li><code>\\B</code>: 匹配不是开头或结束的位置;</li>\n<li><code>\\</code>: 转义符;</li>\n<li><code>[aeiou!%@?]</code>: 匹配数组中任意一个字符;</li>\n<li><code>[0-9]</code>: 匹配0到9之间的一个数字;</li>\n<li><code>[a-z0-9A-Z]</code>: 同上;</li>\n<li><code>|</code>: 分枝条件，或,(使用时，要注意，当满足一个条件时，将不会继续匹配后面的条件是否满足);</li>\n<li><code>()</code>: 分组匹配，常配合重复次数使用;</li>\n<li><code>[^X]</code>: 匹配除了<code>x</code>以外的任意字符;</li>\n<li><code>[^aeiou]</code>: 匹配除了<code>aeiou</code>以外的任意字符;</li>\n<li><code>\\t</code>: 制表符，Tab;</li>\n<li><code>\\r</code>: 回车;</li>\n<li><code>\\v</code>: 竖向制表符;</li>\n<li><code>\\f</code>: 换页符;</li>\n<li><code>\\n</code>: 换行符;</li>\n<li><code>\\e</code>: Escape;</li>\n</ul>\n<h3 id="-regester">工具 <code>Regester</code></h3>\n<h3 id="-">后向引用 <code>(用于重复搜索前面某个分组匹配的文本。)</code></h3>\n<blockquote>\n<p>在用<code>()</code>分组时，每个分组会自动拥有一个组号；<br>规则是从左向右，以分组的左括号为标志,<br>第一个出现的分组的组号为1，第二个为2，以此类推。<br><code>\\1</code>代表分组1匹配的文本。</p>\n</blockquote>\n<blockquote>\n<p>例：</p>\n<pre><code>\\b(\\w+)\\b\\s+\\1\\b; // 用来匹配像&#39;go go&#39;,等重复的单词。</code></pre></blockquote>\n<p> <strong>自定义组名：</strong></p>\n<p> 语法：<code>(?&lt;Word&gt;\\w+)</code>(或者把尖括号换成&#39;也行：<code>(?&#39;Word&#39;\\w+)</code>),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k<Word>,所以上一个例子也可以写成这样：<code>\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b</code>。</p>\n<h3 id="-">零宽断言</h3>\n<blockquote>\n<p>对于像<code>\\b</code>, <code>^</code>, <code>$</code>,那样用于指定一个位置，这个位置应该应该满足一定条件，即断言 <br><code>(?=exp)</code>: 断言自身出现的位置的后面能匹配表达式exp; <br><code>(?&lt;=exp)</code>: 断言自身出现的位置的前面能匹配表达式exp;</p>\n</blockquote>\n<pre><code>\\b\\w+(?=ing\\b); // 匹配以ing结尾的单词的前面部分（除了ing以外的部分）\n\n(?&lt;=\\bre)\\w+\\b; // 匹配re开头的单词，除了re的后半部分。</code></pre><p><strong>负向零宽断言</strong></p>\n<pre><code>\\b\\w*p[^u]\\w*\\b: // 匹配后面不是字母u的字母p</code></pre><p>但是当以p结尾的单词，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词， 于是就匹配出两个单词。</p>\n<pre><code>\\b\\w*p(?!u)\\w*\\b; 解决方法</code></pre><blockquote>\n<p><code>(?!exp)</code>: 断言此位置的后面不能匹配表达式exp;\n<code>(?&lt;!exp)</code>: 断言此位置的前面不能匹配表达式exp;</p>\n</blockquote>\n<pre><code>\\d{3}(?!\\d): 匹配后面不能是数字的三个数字；\n\n(?&lt;![a-z])\\d{7}: 匹配前面不是小写字母的七位数字；\n\n(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;): 匹配不包含属性的简单的HTML标签里的内容；</code></pre><h3 id="-">注释</h3>\n<blockquote>\n<p>(&gt;#注释语句)</p>\n</blockquote>\n<p>使用注释时，最好忽略模式里的空白符，在#后面到这一行结束时，所有的文本都将被当成注释忽略掉。</p>\n<h3 id="-">贪婪匹配</h3>\n<p>当正则中包含能接受重复的限定符时，通常会在使整个表达式能得到匹配的前提下，匹配尽量多的字符，例如用<code>a.*b</code>匹配<code>aabab</code>时，将会匹配到整个字符串。</p>\n<p>要转化为懒惰匹配模式，只需要在前面所有的限定符后面加一个<code>?</code>。</p>\n<pre><code>a.*?b; // 匹配到&#39;aab&#39;, &#39;ab&#39;.</code></pre><h3 id="-">处理选项</h3>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lgnoreCase</td>\n<td>匹配时不区分大小写</td>\n</tr>\n<tr>\n<td>Multiline多行模式</td>\n<td>修改<code>^</code>,<code>$</code>含义，是他们们别在任意一行行首或行尾匹配</td>\n</tr>\n<tr>\n<td>Singleline单行模式</td>\n<td>修改<code>.</code>的含义，使他与每一个字符匹配，包括<code>\\n</code></td>\n</tr>\n<tr>\n<td>IgnorePatternWhitespace</td>\n<td>忽略空白,并启用由#标记的注释</td>\n</tr>\n<tr>\n<td>ExplicitCapture</td>\n<td>仅捕获已被显式命名的组。</td>\n</tr>\n</tbody></table>\n<p>在js中</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>i</td>\n<td>匹配时不区分大小写</td>\n</tr>\n<tr>\n<td>g</td>\n<td>匹配多个</td>\n</tr>\n<tr>\n<td>m</td>\n<td>^ 和 $ 可以匹配每一行的开头。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>String.prototype.match() 中，返回数据的格式会不一样，加 g 会返回数组，不加 g 则返回比较详细的信息</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<pre><code>/a/.test(&#39;A&#39;) // =&gt; false\n/a/i.test(&#39;A&#39;) // =&gt; true\n\n&#39;hello hell hoo&#39;.match(/h.*?\\b/) // =&gt; [ &#39;hello&#39;, index: 0, input: &#39;hello hell hoo&#39; ]\n&#39;hello hell hoo&#39;.match(/h.*?\\b/g) // =&gt; [ &#39;hello&#39;, &#39;hell&#39;, &#39;hoo&#39; ]\n\n&#39;aaa\\nbbb\\nccc&#39;.match(/^[\\s\\S]*?$/g) // =&gt; [ &#39;aaa\\nbbb\\nccc&#39; ]\n&#39;aaa\\nbbb\\nccc&#39;.match(/^[\\s\\S]*?$/gm) // =&gt; [ &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39; ]</code></pre><h3 id="-">平衡组/递归匹配</h3>\n<p>对于需要匹配像<code>(100 * (50 - 15))</code>这样的可嵌套的层次结构。正常匹配只会匹配到最左边的左括号和最右边的右括号之间的内容，</p>\n<p><code>(?&#39;group&#39;)</code>: 把捕获到的内容命名为group，并压入堆栈 <br><code>(?&#39;-group&#39;)</code>: 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 <br><code>(?(group)yes|no)</code>: 如果堆栈上存在以名为group捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 <br><code>(?!)</code>: 零宽负向先断言，由于没有后缀表达式，试图匹配总是失败</p>\n<p>我们需要做的是每碰到了左括号，就在压入一个&quot;Open&quot;,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>\n'},"6cf9":function(n,e){n.exports='<ol>\n<li>访问链接直接加载静态资源</li>\n</ol>\n<p><code>koa-static</code></p>\n<p>index.js</p>\n<pre><code>const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\nconst path = require(&#39;path&#39;);\nconst serve = require(&#39;koa-static&#39;);\n\nconst main = serve(path.join(__dirname));\napp.use(main);\n\napp.listen(3000);\n</code></pre><p>访问<code>http://localhost:3000/index.js</code></p>\n<ol start="2">\n<li>重定向</li>\n</ol>\n<pre><code>ctx.response.redirect(&#39;/&#39;);</code></pre><ol start="3">\n<li>中间件（middleware）</li>\n</ol>\n<p><code>logger日志</code></p>\n<pre><code>const logger = (ctx, next) =&gt; {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  next();\n}\n\napp.use(logger);</code></pre><ul>\n<li><p>在<code>HTTP Request</code> 和 <code>HTTP Response</code>中间，实现某种功能的；</p>\n</li>\n<li><p>用<code>app.use()</code>进行加载；</p>\n</li>\n<li><p>每个中间件有两个参数（context对象，next方法）</p>\n</li>\n</ul>\n<p><code>栈结构</code></p>\n<p>最外层的中间件首先执行。\n调用next函数，把执行权交给下一个中间件。\n...\n最内层的中间件最后执行。\n执行结束后，把执行权交回上一层的中间件。\n...\n最外层的中间件收回执行权之后，执行next函数后面的代码。</p>\n<p>如果没有<code>next()</code>就不会往下传递。</p>\n<ol start="4">\n<li>合并中间件<code>koa-compose</code></li>\n</ol>\n<pre><code>const compose = require(&#39;koa-compose&#39;);\n\n\nconst middlewares = componse([&#39;main, one, two&#39;]);\napp.use(middlewares);</code></pre><ol start="5">\n<li>返回提示</li>\n</ol>\n<pre><code>// 500\nconst err = ctx =&gt; {\n  ctx.throw(500);\n}\n\n// 404\nctx.response.status = 404;</code></pre><ol start="6">\n<li>中间件的错误解决</li>\n</ol>\n<pre><code>const handler = async (ctx, next) =&gt; {\n  try {\n    await next();\n  } catch (e) {\n    ctx.response.status = e.statusCode || e.status || 500;\n    ctx.response.body = {\n      message: e.message\n    };\n  }\n}</code></pre><ol start="7">\n<li>error事件监听</li>\n</ol>\n<pre><code>app.on(&#39;error&#39;, (err, ctx) =&gt; {\n  console.log(&#39;server error&#39;, err)\n})</code></pre><ol start="8">\n<li>使用<code>try catch</code>解决报错就不会触发7error事件监听</li>\n</ol>\n<pre><code>// catch 最下面一行加\nctx.app.emit(&#39;error&#39;, err, ctx);</code></pre><ol start="9">\n<li>读写<code>cookie</code></li>\n</ol>\n<pre><code>const main = function(ctx) {\n  const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;\n  ctx.cookies.set(&#39;view&#39;, n);\n  ctx.response.body = n + &#39; views&#39;;\n}</code></pre><ol start="10">\n<li>接收<code>post</code>请求参数 <code>koa-body</code></li>\n</ol>\n<pre><code>const koaBody = require(&#39;koa-body&#39;);\n\napp.use(koaBody());\n\nconst main = async ctx =&gt; {\n  const body = ctx.request.body;\n  console.log(body);\n  if (!body.name) ctx.throw(400, &#39;name is required&#39;);\n  ctx.body = { name: body.name }\n}</code></pre><blockquote>\n<p>谷歌插件<code>request Maker</code>发送post请求，</p>\n</blockquote>\n<pre><code>http://127.0.0.1:3000\n\ncontent-type: application/x-www-form-urlencoded; charset=utf-8\n\nname: abc123</code></pre>'},"6d66":function(n,e){n.exports="<p>兼容性</p>\n<pre><code>      var EventUtil = {\n        addHandler: function (element, type, handler) {\n          if (element.addEventListener) {\n            element.addEventListener(type, handler, false)\n          } else if (element.attachEvent) {\n            element.attachEvent(&quot;on&quot; + type, handler)\n          } else {\n            element[&quot;on&quot; + type] = handler\n          }\n        },\n        removeHandler: function (element, type, hander) {\n          if (element.removeEventListener) {\n            element.removeEventListener(type, handler, false)\n          } else if (element.detachEvent) {\n            element.detachEvent(&quot;on&quot; + type, handler)\n          } else {\n            element[&quot;on&quot; + type] = null\n          }\n        }\n      }</code></pre><p>DOM2级事件</p>\n<pre><code>addEventListener(&quot;click&quot;, function () {\n  // .\n}, false)\n\nfalse: 冒泡\ntrue: 捕获\n\n\nremoveEventListener(&quot;click&quot;, function () {\n  //  .\n}, false) // 不能是匿名函数\n</code></pre><p>为同一个元素添加事件时，按照加载顺序依次进行。</p>\n<p>IE:</p>\n<pre><code> attachEvent(&quot;onclick&quot;, function () {\n    // .\n})\n只支持冒泡\n第一个参数使用onclick,\n</code></pre><p>与DOM0区别： 作用于不用，DOM0下事件this指向所属元素，\n        <code>attachEvent</code>会在全局作用域中运行， this == window\n与addEventListener区别： 可以为同一个元素添加多个事件处理程序，\n        但attachEvent是以相反的顺序被触发</p>\n"},7140:function(n,e){n.exports='<h2 id="-">聚合</h2>\n<p><code>aggregate()</code></p>\n<pre><code>db.col.aggregate(option)</code></pre><p>eg:</p>\n<pre><code>db.col.aggregate([{$group: {_id:&quot;$by_user&quot;,num_tutorial: {$sum: 1}}}])\n\n通过字段by_user字段对数据进行分组，并计算by_user字段相同值的总和。</code></pre><table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$sum</td>\n<td>计算总和。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : &quot;$likes&quot;}}}])</td>\n</tr>\n<tr>\n<td>$avg</td>\n<td>计算平均值</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$avg : &quot;$likes&quot;}}}])</td>\n</tr>\n<tr>\n<td>$min</td>\n<td>获取集合中所有文档对应值得最小值。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$min : &quot;$likes&quot;}}}]    )</td>\n</tr>\n<tr>\n<td>$max</td>\n<td>获取集合中所有文档对应值得最大值。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$max : &quot;$likes&quot;}}}])</td>\n</tr>\n<tr>\n<td>$push</td>\n<td>在结果文档中插入值到一个数组中。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$push: &quot;$url&quot;}}}])</td>\n</tr>\n<tr>\n<td>$addToSet</td>\n<td>在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$addToSet : &quot;$url&quot;}}}])</td>\n</tr>\n<tr>\n<td>$first</td>\n<td>根据资源文档的排序获取第一个文档数据。</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, first_url : {$first : &quot;$url&quot;}}}])</td>\n</tr>\n<tr>\n<td>$last</td>\n<td>根据资源文档的排序获取最后一个文档数据</td>\n<td>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, last_url : {$last : &quot;$url&quot;}}}])</td>\n</tr>\n</tbody></table>\n<h3 id="-">管道</h3>\n<ul>\n<li><p>$project: 修改输入文档的结构，可以重命名，增删域，也可用于创建计算结果以及嵌套文档</p>\n</li>\n<li><p>$match: 用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p>\n</li>\n<li><p>$limit: 用来限制MongoDB聚合管道返回的文档数。</p>\n</li>\n<li><p>$skip: 在聚合管道中跳过指定数量的文档，并返回余下的文档</p>\n</li>\n<li><p>$unwind: 将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p>\n</li>\n<li><p>$group: 将集合中的文档分组，可用于统计结果。</p>\n</li>\n<li><p>$sort: 将输入文档排序后输出</p>\n</li>\n<li><p>$geoNear: 输出接近某一地理位置的有序文档。</p>\n</li>\n</ul>\n<p>eg:</p>\n<pre><code>$project\n\ndb.col.aggregate({$project: {title: 1, author: 1}})\n\n就只剩下title, author, _id三个参数了， _id默认包含\n\n若不想包含加`_id: 0`</code></pre><pre><code>$match 过滤\n\ndb.col.aggregate([\n  {$match: {score: {$gt: 70, $lte: 90}}},\n  {$group: {_id: null, count: {$sum: 1}}}\n])\n</code></pre><pre><code>db.col.aggregate({$skip: 5})\n\n过滤掉前五个文档</code></pre>'},7626:function(n,e){n.exports=""},"77b2":function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-4dc3d7d78da51d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父元素中"></p>\n<pre><code>&lt;template&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;el-button @click=&quot;click&quot; &gt;调用子元素&lt;/el-button&gt;\n        &lt;child ref=&quot;children&quot;/&gt;&lt;!--子组件--&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport child from &#39;./compponents/child&#39;\nexport default {\n    name: &#39;app&#39;,\n    components: {\n        child\n    },\n    methods: {\n        click () {\n            this.$refs.children.childFn(&#39;父元素传递过来的数据&#39;)\n        }\n    }\n}\n\n&lt;/script&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-f4d5afdc615f6251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子组件中"></p>\n<pre><code>&lt;template&gt;\n    &lt;div id=&quot;hello&quot;&gt;\n\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n    name: &#39;hello&#39;,\n    methods: {\n        childFn (msg) {\n            console.log(msg)\n        }\n    }\n}\n\n&lt;/script&gt;</code></pre>'},7924:function(n,e){n.exports='<h4 id="flex-">flex布局</h4>\n<p>概念：主轴、 交叉轴\n可以让元素在主轴和交叉轴上面任意对齐，宽高占比，顺序排列</p>\n<pre><code>在父元素上设置\ndisplay: flex\n\n\njustify-content\n设置元素在主轴上的对齐方式\n属性值：flex-start;主轴起点对齐\nflex-end主轴终点对齐\ncenter主轴中点对齐\nspace-bewteen把剩余的空间均分给项目与项目之间\nspace-around把剩余的空间均分给项目的两侧\n\nalign-items\n设置项目在交叉轴上的对齐方式\nflex-start交叉轴起点对齐\nflex-end交叉轴终点对齐\ncenter交叉轴中心对齐\nstretch项目高度充满容器\nbaseline基线对齐\n\nflex-direction\n设置主轴方向\ncolumn从上到下\ncolumn-reverse从下到上\nrow代表主轴从左到右\nrow-reverse从右到左\n\nflex-flow  \nflex-direction和flex-wrap的简写 默认row nowrap\n\nflex-wrap\n如果元素过多，默认情况不换行，需要手动设置\nwrap换行后高度均分容器高度。默认，但是换行后，有几行就会有几个主轴\nwrap-reverse换行后上下顺序颠倒\nnowrap不换行\n\nalign-content\n当有多条主轴的情况下，设置项目在交叉轴上的对齐方式\nflex-start/flex-end/center/space-between/space-around/stretch\n针对多条主轴的设置方式，对单轴没用\n\n\n针对单个元素设置的\nflex-grow:占用空间（可以写占几份）\nflex-shrink:缩小比例\nflex-basis设置项目在主轴上占据空间，可以用%\nalign-self单独设置项目在交叉轴上的对齐方式\n（auto | flex-start | flex-end | center | baseline | stretch）\norder设置序号，排序\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</code></pre>'},7985:function(n,e){n.exports='<p>vue2.0基本用法</p>\n<p>(npm run dev)</p>\n<p><code>vue init webpack demo</code></p>\n<p>和angular有许多类似的地方，由于使用了大量ES6语法，所以不支持IE8以下版本</p>\n<h3 id="-">一、基本语法</h3>\n<p>vue实例最外层放一个<div id="app"></div></p>\n<p>1.{{}}:同angular一样，使用{{}}包裹变量</p>\n<pre><code>&lt;h1&gt;{{ name }}&lt;/h1&gt;</code></pre><p>同样，和angular一样，可以在{{}}里面写表达式，{{1+1}}{{Math.random()&gt;0.5}}{{‘abc’.toUpperCase()}}{{ 10&gt;30?30:60 }},注意，这里不能写if()else</p>\n<p>2.v-model\n和angular的ng-model类似，实现数据的双向绑定</p>\n<pre><code>&lt;h1&gt;{{ name }}&lt;/h1&gt;\n&lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt;\n\n使用name变量之前，要先定义\n创建模板对应的vue实例\nvar vm=new Vue({\n    el:&#39;#app&#39;,//el:elements Vue对应的根标签\n    data:{//对应的数据\n        name:&#39;小明&#39;\n    }\n})\n</code></pre><p>在data中可以定义变量数组对象字符串</p>\n<p>3遍历v-for(in/of)\n不仅可以遍历数组元素，还可以遍历数组下标</p>\n<pre><code>    &lt;ul&gt;\n        &lt;li v-for=&quot;(person,i) of people&quot;&gt;{{i+person.name}}&lt;/li&gt;\n    &lt;/ul&gt;\n\nvar vm=new Vue({\n    el:&#39;#app&#39;,\n    data:{\n       people:[\n          {name:&#39;xiaoming&#39;},\n          {name:&#39;xiaohong&#39;},\n        ]\n    }\n})</code></pre><p>使用v-for遍历对象的value；</p>\n<pre><code>&lt;li v-for=&quot;value in mine&quot;&gt;{{value}}&lt;/li&gt;\n\nvar vm=new Vue({\n    el:&#39;#app&#39;,\n    data:{\n       mine:{\n          name:&#39;xiaoming&#39;,\n          age:18\n        }\n    }\n})</code></pre><p>v-for可以遍历对象的value和key值，注意value在前，key在后</p>\n<pre><code>&lt;li v-for=&quot;(value,key) in mine&quot;&gt;{{value}}{{key}}&lt;/li&gt;</code></pre><p>4.点击事件v-on:click=&quot;change&quot;\n无论使用什么事件，都是用v-on指令，后面跟事件名称即可,可以不加()在不传参的情况下</p>\n<pre><code>&lt;h3 v-on:click=&quot;show&quot;&gt;点击显示&lt;/h3&gt;\n\n定义函数时，要使用methods\nvar vm=new Vue({\n    methods:{\n        show:function(){\n            console.log(event);\n        }\n        //可以简写成一下的形式ES6新语法\n        show(){\n            console.log(event)\n        }\n    }\n})</code></pre><blockquote>\n<p>如果想要得到里面的变量，可以直接写vm.变量名，如vm.show或vm.name;</p>\n</blockquote>\n<p>5.v-if决定是否渲染,可以和v-else连用</p>\n<pre><code>&lt;section v-if=&quot;flag&quot;&gt;hhhh&lt;/section&gt;\n&lt;section v-else&gt;lksdjfkaldj&lt;/section&gt;</code></pre><p>6.v-show决定是否显示</p>\n<pre><code>&lt;div v-show=&quot;flag&quot;&gt;h2&lt;/div&gt;</code></pre><p>7.v-on添加事件</p>\n<pre><code>&lt;button v-on:click=&quot;test1&quot;&gt;按钮1&lt;/button&gt;\n\n可以简写成@\n&lt;button @click=&quot;test1&quot;&gt;按钮1&lt;/button&gt;\n\n还可以写其他的事件\n&lt;button @mouseover=&quot;test2&quot;&gt;按钮2&lt;/button&gt;\n&lt;input type=&quot;text&quot; @keyup=&#39;test3&#39; /&gt;\n等等\n\n还可以添加修饰符，针对某一个按键起作用\n&lt;input type=&quot;text&quot; @keyup.enter=&#39;test3&#39; /&gt;\n只用在点击enter键时，才会执行函数，注意，这样的针对某一个按键起作用，就必须绑定在键盘事件上\n&lt;input type=&quot;text&quot; @keyup.up=&#39;test3&#39; /&gt;上下键的上\n\n同样也可以取消默认事件\n&lt;a href=&quot;http://www.baiu.com&quot; @click.prevent=&quot;test4&quot;&gt;baidu&lt;/a&gt;\n\n还可以取消冒泡\n&lt;a href=&quot;http://www.baiu.com&quot; @click.stop=&quot;test4&quot;&gt;baidu&lt;/a&gt;\n</code></pre><blockquote>\n<p>说到这里，可以复习一下原生的取消默认事件的方法，和取消冒泡的方法</p>\n<pre><code>event.stopPropagation取消冒泡事件\nevent.preventDefault;取消默认事件</code></pre></blockquote>\n<p>8.v-bind绑定属性</p>\n<pre><code>&lt;h2 v-bind:class=&quot;class&quot;&gt;&lt;/h2&gt;\n\n同样可以简写成\n&lt;h2 :class=&quot;class&quot;&gt;&lt;/h2&gt;\n\n不光可以写class，其他的属性都可以这样写，\n在使用v-bind简写形式时，\n必须加冒号，不然会把它里面的值当成一个字符串显示，而不是我们要的变量得形式</code></pre><p>9.计算属性computed;</p>\n<pre><code>&lt;h2&gt;{{ aDouble }}&lt;/h2&gt;\n&lt;h2&gt;{{ aPlus }}&lt;/h2&gt;\n&lt;input type=&quot;number&quot; v-model=&quot;aPlus&quot;&gt;\n\n    var vm=new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            a:10,\n        },\n        computed:{//计算属性\n            aDouble:function(){\n                return this.a*2;//这里的this.a==vm.a;\n            },\n            aPlus:{\n                get:function(){\n                    return this.a*2;\n                },\n                set:function(newValue){\n                    console.log(newValue);\n                    if(newValue&gt;100){\n                        this.a=100;\n                    }else if(newValue&lt;=0){\n                        this.a=0;\n                    }else{\n                        this.a=newValue;\n                    }\n                }\n            }\n        }\n    })</code></pre><p>计算属性可以内部编写两个函数，分别是get和set，读取计算属性的时候走get方法，设置计算属性值得时候，就走set方法，set方法中的参数就是要设置的新值，可以再get方法内部进行条件判断，决定是否使用其新值</p>\n<blockquote>\n<p>对于计算属性，直接当成普通属性使用即可\n不能加括号作为函数使用 ，他代表一个函数的返回值\n如果把它写在methods里面，那么他就是一个函数的方法</p>\n</blockquote>\n<p>计算属性实现的效果，使用函数也都可以实现，，但是尽量使用计算属性，计算属性更加加高效，对于取值来说，只有当值发生改变，计算属性内部的函数才会执行一次，而函数会使用几次就执行几次</p>\n<p>9.实例属性\nvm.$data\nvm.$el\nvm.$parent\nvm.$root\nvm.$children\n在路由分级时，会用到children</p>\n<p>10.实例方法vm.$watch\n同angular，</p>\n<pre><code>    // 使用$watch可以监测某个值得变化\n    vm.$watch(&#39;a&#39;,function(newValue,oldValue){\n        console.log(&quot;newValue=&quot;+newValue);\n        console.log(&quot;oldValue=&quot;+oldValue);\n    })\n返回一个函数，用来停止触发回调\nvar unwatch = vm.$watch(‘a’, cb);\nunwatch();</code></pre><h3 id="-">二、组件</h3>\n<p>类似于angular的自定义指令，用来封装重复使用的代码块</p>\n<p>注册组件</p>\n<pre><code>如果需要换行，可以使用普通字符串，后面用\\拼接，或者使用模板字符串\nVue.component(&#39;hello&#39;,{\n        template:&#39;&lt;div&gt;\\\n                        &lt;h1&gt;我是hello&lt;/h1&gt;\\\n                        &lt;p&gt;我是HELLO标签&lt;/p&gt;\\\n                        &lt;p&gt;我是HELLO标签{{msg}}&lt;/p&gt;\\\n                    &lt;/div&gt;&#39;,\n        data(){//组件中的data数据，必须是函数，数据通过return进行返回\n\n\n            // 组件中的data必须是函数的原因是：每个组件欧拥有自己独立的数据，不与其他共享，因为共享数据后，会相互影响，导致数据错乱\n            return {\n                msg:&#39;message&#39;\n            };\n        }\n    })\n\n在html代码中，只需要加入&lt;hello&gt;&lt;/hello&gt;就可以了</code></pre><p>这是一个全局的标签\n其中template对应的是被替换过去的HTMl模板结构；\n必须存在一个跟标签(root element)</p>\n<p>下面创建一个局部的实例</p>\n<pre><code>    var vm=new Vue({\n        el:&#39;#app&#39;,\n        components:{//局部组件直接写在实例的components中，其他实例无法使用。\n            hi:{\n                template:&#39;&lt;h2&gt;我是hi标签&lt;/h2&gt;&#39;\n            }\n        }\n    })</code></pre><p>父组件与子组件的传值props</p>\n<blockquote>\n<p>在这里需要提一下引用类型；\n数组和对象都是引用类型，其他的都是普通的值类型</p>\n</blockquote>\n<pre><code>var arr=[1,2,3,4];\nvar arr2=arr;\narr2.push(5);\n此时arr与arr2同时都变成了[1,2,3,4,5];\n这是因为arr定义一个数组，就会开创一个空间，并把值都传到空间，然后arr指向了这个空间，定义一个arr2,让他等于arr，这时arr2也指向了这个空间，所以通过这两个随意改变指都会影响到另一个，这样的数组就是引用型。此仅为个人理解。</code></pre><p>组件内部的props里面的值都是组件的属性，用于接受外界的值，然后赋值到组件内部</p>\n<pre><code>&lt;my-component :msg=&quot;msg&quot;&gt;&lt;/my-component&gt;\n\n    Vue.component(&#39;my-component&#39;,{\n        props:[&#39;msg&#39;],//props用于接受外界传递的值\n        template:&#39;&lt;p&gt;message={{msg}}&lt;/p&gt;&#39;\n    })</code></pre><pre><code> 父组件与子组件之间的传值</code></pre><pre><code>&lt;my-component :msg=&quot;msg&quot;&gt;&lt;/my-component&gt;\n这里的msg是一个变量\n\n    Vue.component(&#39;my-component&#39;,{\n        props:[&#39;msg&#39;],//props用于接受外界传递的值\n        template:&#39;&lt;p&gt;message={{msg}}&lt;/p&gt;&#39;\n    })\n    var vm=new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            msg:&#39;message&#39;\n        }\n    })\n\n在页面显示的&lt;p&gt;message=message&lt;/p&gt;</code></pre><p>这里的props是单向数据流的，但是对于引用类型的数组对象不能单向；</p>\n<p>使用slot分发\n作用类似于angular的ng-transclude嵌套元素；</p>\n<pre><code>    Vue.component(&#39;my-app&#39;,{\n        template:`\n                &lt;div&gt;\n                    &lt;p&gt;我是my-app&lt;/p&gt;\n                    &lt;slot&gt;如果没有分发内容，显示我&lt;/slot&gt;\n                    &lt;slot name=&quot;header&quot;&gt;如果没有分发内容，显示我&lt;/slot&gt;\n\n                &lt;/div&gt;`\n\n    })\n\n\n具名slot的使用\n        &lt;my-app&gt;\n            &lt;h2 slot=&quot;header&quot;&gt;h2&lt;/h2&gt;\n            &lt;hr&gt;\n            &lt;h3 slot=&quot;footer&quot;&gt;h3&lt;/h3&gt;\n            &lt;hr&gt;\n            &lt;h4&gt;h4&lt;/h4&gt;\n\n        &lt;/my-app&gt;</code></pre><p>如果写两遍slot，那么就会打印两遍，但会报错;但是，如果把他变成具名属性，就可以正常使用了</p>\n<p>// export导出\n// import导入</p>\n<h3 id="-vue-">三、使用vue做一个项目</h3>\n<p>命令行内：\n1.通过命令行安装vue脚手架\nnpm install -g vue-cli</p>\n<p>2设置项目名称\nvue init webpack 项目名</p>\n<p>cd 项目名</p>\n<p>npm install</p>\n<p>npm run dev运行项目默认打开8080端口</p>\n<p>####路由\n路由安装\nnpm install vue-router</p>\n<p>npm run dev</p>\n<p>完成之后进行的步骤：\n在main.js中</p>\n<pre><code>1.import VueRouter from &#39;vue-router&#39;//引入路由文件</code></pre><p>引入home</p>\n<pre><code>import Home from &#39;home&#39;</code></pre><p>//2.安装插件main.js</p>\n<pre><code>Vue.use(VueRouter)</code></pre><p>3.编写页面在app.js</p>\n<pre><code> &lt;router-link to=&quot;/home&quot;&gt;&lt;/router-link&gt;</code></pre><p>4.定义路由main.js</p>\n<pre><code>const routes=[\n    {path:&#39;/home&#39;,component:Home}\n    path对应的是app.js 中to=&quot;/home&quot;\n    components对应的是引入的名称\n]</code></pre><p>其中的</p>\n<pre><code>const routes=[\n    { path: &#39;/&#39;, component: Home }\n      表示打开默认显示home页面\n]</code></pre><p>5创建VueRouter实例main.js</p>\n<pre><code>const router = new VueRouter({\n    routes//这是简写(routes:routes)\n})</code></pre><p>6.在main.js中的</p>\n<pre><code>new Vue({\n  el: &#39;#app&#39;,\n  template: &#39;&lt;App/&gt;&#39;,\n  components: { App },\n添加：\n  router\n})</code></pre><p>添加一个文件夹在src文件夹下，里面添加我们需要的页面，每个页面只需要一个后缀名为vue的文件，里面就包含了html，css和js的所有内容。其中html写在<template></template>内，并且在里面添加一个根标签，把内容都放在我们设置的跟标签里面</p>\n<p>和angular不同的是，路由跳转没有直接使用a标签的锚点，而是有它专用的标签\n<router-link to="/home">首页</router-link>\n，同样，也不需要使用ui-view,而是它专用的\n<router-view></router-view></p>\n<p>replace属性</p>\n<pre><code>&lt;router-link :to=&quot;/home&quot; replace&gt;&lt;/router-link&gt;//页面切换不会留下历史痕迹</code></pre><p>tag属性,会渲染成tag指定的标签</p>\n<pre><code>&lt;router-link :to=&quot;/home&quot; tag=&quot;li&quot;&gt;Home&lt;/router-link&gt;&lt;li&gt;Home&lt;/li&gt;</code></pre><p>active-class属性\n这个属性是设置激活链接时的class属性</p>\n<pre><code>&lt;router-link :to=&quot;/home&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt;</code></pre><blockquote>\n<p>active-class属性的默认值是router-link-active</p>\n</blockquote>\n<p>exact属性\n开启router-link的严格模式</p>\n<pre><code>&lt;router-link :to=&quot;/&quot; exact&gt;home&lt;/router-link&gt;</code></pre><p>二级路由</p>\n<pre><code>先引入\nimport One from &#39;one&#39;,\nimport two from &#39;two&#39;,\n\nconst router=[\n    {path:&#39;/home&#39;,component:Home,children:[\n        {path:&#39;one&#39;,component:One},\n        {path:&#39;two&#39;,component:two},\n    ]}\n]\n\n &lt;router-link to=&quot;/home/one&quot;&gt;One&lt;/router-link&gt;\n&lt;router-view&gt;&lt;/router-view&gt;</code></pre><p>网络请求\nnpm install vue-resource\n安装</p>\n<pre><code>Vue.use(VueResource)\n\n\nexport default{\n    data(){\n        return {\n            data:[]//把返回的数据都放到数组中\n        }\n    },\n    mounted(){\n        this.$http.get().then(function(res){\n            console.log(res);\n            // console.log(JSON.parse(res.body).data);\n            this.data=JSON.parse(res.body).data;\n        })\n    }\n}</code></pre><p>网络请求使用mounted</p>\n<h3 id="-js-">引用第三方js库：</h3>\n<p>在需要的.vue文件中，script里面引入；\nimport $ from &#39;../../static/lib/jquery-3.1.1.min.js&#39;</p>\n<p>就这么简单</p>\n<pre><code>export default{\n    data(){\n        return (\n            //定义的变量写这里\n            data:[];\n            name:&#39;xiaoming&#39;\n        )\n    },\n    mounted(){\n        //js代码写在这里\n       在引用swiper时，把swiper的js代码放到这里，如果是动态创建的元素，\n       建议用setTimeout包住\n           new Swiper (&#39;.swiper-container&#39;, {\n                direction: &#39;horizontal&#39;,\n                loop: true,\n                autoplay:2000,\n                speed:1000,\n                autoplayDisableOnInteraction:false,\n                pagination: &#39;.swiper-pagination&#39;,\n            })\n    }，\n    methods:{//方法写这里\n        get(){}\n    }\n\n}\n</code></pre>'},"7a47":function(n,e){n.exports="<pre><code>if (event.preventDefault) {\n    event.preventDefault()\n} else {\n    event.returnValue = false\n}\n\n\nif (event.stopPropagation) {\n    event.stopPropagetion()\n} else {\n    event.cancelBubble = true\n}</code></pre>"},"7de5":function(n,e){n.exports='<h3 id="-">初始化</h3>\n<pre><code>npm init</code></pre><p>安装一些依赖、包文件</p>\n<p><code>npm install ***</code></p>\n<pre><code>    &quot;koa&quot;: koa 框架\n\n    &quot;bluebird&quot;: 使用`Promise`, `async`\n\n    &quot;crypto&quot;: 加密转码\n\n    &quot;geoip-lite&quot;: 查找IP地址并返回它映射到的国家，地区和城市\n\n    &quot;mongoose&quot;: 使用数据库\n\n    &quot;mongoose-auto-increment&quot;: 自增\n\n    &quot;mongoose-paginate&quot;: 分页\n\n    &quot;jsonwebtoken&quot;: 一种紧凑的URL安全方法，用于在网络通信的双方之间传递\n\n    &quot;koa-body&quot;: 解析请求体中传进的数据\n\n    &quot;koa-cors&quot;: 跨域请求\n\n    &quot;koa-helmet&quot;: 配置请求头\n\n    &quot;koa-json&quot;: 返回json\n\n    &quot;koa-router&quot;: 路由\n\n    &quot;nodemailer&quot;: 发送邮件\n\n    &quot;nodemailer-smtp-transport&quot;: 自动发送给服务器\n\n    &quot;qn&quot;: 七牛upload\n\n    &quot;redis&quot;: 解决重启服务器丢失session问题\n\n    &quot;request&quot;: 我们可以用它来实现HTTP响应流的转接、模拟Form表单提交、支持HTTP认证、OAuth登录、自定义请求头等\n\n    &quot;simple-netease-cloud-music&quot;: 简易的网易云音乐\n\n    &quot;yargs&quot;: 定制化的参数功能\n</code></pre><p><code>.editorconfig</code>文件的作用：</p>\n<blockquote>\n<p>帮助开发人员定义和维护一致的编码风格在不同的编辑器和IDE</p>\n</blockquote>\n<pre><code>属性：\n　　indent_style: 设置缩进风格，tab或者空格。tab是hard tabs，space为soft tabs。\n\n　　indent_size: 缩进的宽度，即列数，整数。如果indent_style为tab，则此属性默认为tab_width。\n\n　　tab_width: 设置tab的列数。默认是indent_size。\n\n　　end_of_line： 换行符，lf、cr和crlf\n\n　　charset： 编码，latin1、utf-8、utf-8-bom、utf-16be和utf-16le，不建议使用utf-8-bom。\n\n　　trim_trailing_whitespace： 设为true表示会除去换行行首的任意空白字符。\n\n　　insert_final_newline: 设为true表明使文件以一个空白行结尾\n\n　　root: 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件。</code></pre>'},8029:function(n,e){n.exports='<p><a href="http://blog.csdn.net/cuixiping/article/details/45966177">http://blog.csdn.net/cuixiping/article/details/45966177</a></p>\n<p><a href="https://elemefe.github.io/image-cropper/">https://elemefe.github.io/image-cropper/</a></p>\n<p><a href="http://www.bcty365.com/content-142-3007-1.html">http://www.bcty365.com/content-142-3007-1.html</a></p>\n'},8115:function(n,e){n.exports='<h3 id="nginx-404">nginx 刷新404</h3>\n<pre><code>    location / {\n            root   d:\\static\\add;\n            index  index.html index.htm;\n        try_files  $uri $uri/ /index.html =404;\n        }</code></pre><p>加<strong>try_files</strong></p>\n'},"84fd":function(n,e){n.exports='<h1 id="-">实例方法</h1>\n<h3 id="watch">watch</h3>\n<p><code>this.$watch(&#39;data&#39;, callback, { ...options })</code></p>\n<p>观察实例变化的一个表达式或计算属性函数</p>\n<blockquote>\n<p>返回一个取消观察的函数，用来停止触发回调：</p>\n</blockquote>\n<pre><code>let unwatch = this.$watch(&#39;a&#39;, cd)\n\nunwatch() // 取消观察</code></pre><ul>\n<li><p>options: { deep: true } 发现对象内部值的变化</p>\n</li>\n<li><p>options: { immediate: true } 立即以表达式的当前值触发回调</p>\n</li>\n</ul>\n<h3 id="set">set</h3>\n<p><code>this.$set(target, key, value)</code></p>\n<h3 id="delete">delete</h3>\n<p><code>this.$delete(target, key)</code></p>\n<h3 id="forceupdate">forceUpdate</h3>\n<p><code>this.forceUpdate() 当前实例，及当前实例引用的子实例  重新渲染</code></p>\n'},"852a":function(n,e){n.exports='<p>#####数组的解构和赋值</p>\n<pre><code>let arr=[1,2,3,4,5,6];\nlet [a,b,c,,,f,g]=arr;\nconsole.log(f);//6\nconsole.log(g);//undefined\n</code></pre><p>二维数组</p>\n<pre><code>let arr=[[1,2,3],4,5];\nlet [[a,b,c],d,e]=arr;\nconsole.log(b);//2\nconsole.log(e);//5</code></pre><ul>\n<li>对象\n定义：一组无序属性的集合</li>\n</ul>\n<pre><code>let obj={name:&#39;薛之谦&#39;,song:&#39;丑八怪&#39;,age:&#39;undefined&#39;}\nlet {name,age,song}=obj;//可以改变顺序\nlet {name}=obj;//也可以像这样，只定义其中的一个\n\nlet obj2={\n    name:&#39;薛之谦&#39;,\n    friends:{\n        name:&#39;xiaoxiao&#39;,\n        name:&#39;xiaoduan&#39;\n    },\n    sing(){\n        console.log(&#39;认真的雪&#39;);\n    },\n    songs:[&#39;丑八怪&#39;,&#39;认真的雪&#39;]\n}\nlet {name,friends,sing}=obj2;\nconsole.log(friends.name);\nlet {songs}=obj2;\nlet [x,y]=songs;\nconsole.log(x,y);\nsing();</code></pre><h5 id="-">箭头函数</h5>\n<pre><code>function add(x){return x+1}\n\n匿名函数x=&gt;x+1;</code></pre><p>有名函数</p>\n<pre><code class="language-`">let add2=x=&gt;x+1;</code></pre>\n<p>加括号的问题：</p>\n<pre><code>let add2=(x)=&gt;x+1;\n当只有一个形参时，不需要加括号，多个时要加，如果不传参，也要加括号();\n\n加{}的情况\nx=&gt;{x+1},这样的话，不会return出来，没有返回值，而像前面那样，不加{}，默认return;</code></pre><p>如果想反回一个对象的情况下：</p>\n<pre><code>let getData=()=&gt;{return {name:&#39;小明&#39;}}</code></pre><p>还可以加一个小括号,就不需要return</p>\n<pre><code>let getData=()=&gt;({name:&#39;小明&#39;})</code></pre><p>函数传参的问题</p>\n<pre><code>function add(x,y){\n    return X+y;\n}\nlet result=ad(2,3);\n不传参的话，结果为NaN;</code></pre><p>在ES5的方法</p>\n<pre><code>function add(x,y){\n    x=x||0;\n    y=y||0;\n    return x+y;\n}</code></pre><p>在ES6中就可以直接写</p>\n<pre><code>function add(x=0,y=0){\n    return x+y;\n}\nlet result=add();//0</code></pre><p>继承</p>\n<pre><code>ES5\nfunction Person(){}\n\nfunction Son(){\n    Person.call(this);\n}\n\nSon.prototype=new Person;</code></pre><p>在ES6中，新增class关键字用来声明 类</p>\n<pre><code>class Animal{\n    如果传参的话，调用构造函数方法\n    constructor(name){//传参、构造函数\n        this.name=name;\n    }\n    say(){\n        console.log(&quot;这是&quot;+this.name)\n    }\n    run(){\n        console.log(&#39;行走&#39;);\n    }\n}\n\nlet ani=new Animal(&#39;猫咪&#39;);\nani.say();\n\n\nclass Pet extends Animal{\n    //创建一个类，继承Animal;\n\n    constructor(name,age){\n        //构造器内，this引用新创建的对象；\n        //所以这里没有this，需要调用父类的构造函数，使用super；\n        super();\n        this.name=name;\n        this.age=age;\n    }\n    say(){\n        console.log(this.name+this.age);\n    }\n}\nlet p=new Pet(&#39;哈士奇&#39;,18)\np.say();//同样也能打印出来\n\nclass P{\n    say(){}\n}\nclass Math{\n    add(){}\n}</code></pre><p>像这样，一个页面可能会有多个class,可以export default Math;\n导出之后，就会在其他页面导入，导入的方法\nimport Math from &#39;路径&#39;;</p>\n<p>####面向对象</p>\n<p>我理解的面向对象：</p>\n<p>键值对；对象；类等；</p>\n<p>具有相同特性数据元素和行为（功能）的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象，类实际上就是一种数据类型。\n类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性。\n类具有操作，它是对象的行为的抽象，用操作名和实现该操作的方法来描述。</p>\n<p>面向对象的三个特性：封装、继承、多态；\n封装实现代码的复用；\n继承实现代码的共用；\n多态是多种样式的实现；</p>\n<p>继承ES5有两种：\n构造函数的继承与原型上的继承；\nES6实现的方法：使用extends；</p>\n<p>构造函数：\n是一种特殊的函数，用于创建同类对象</p>\n<p>构造函数和普通函数的区别：不适用return关键字，构造函数执行时，使用new关键字执行构造函数</p>\n<p>构造函数的特性：与普通函数的区别\n    1构造函数名首字母大写\n    2构造函数内部使用this关键字处理属性赋值逻辑\n    3构造函数不使用return关键字返回新对象\n    4使用new关键字执行函数。</p>\n<p>造函数与实例：实例是new+构造函数创建的对象，新对象叫做构造函数的实例，实例与构造函数之间是多对一的关系</p>\n<p>原型：</p>\n<p>每一个函数都有一个私有的原型属性prototype,这个值是一个object类型；\n原型最重要的作用是为所有实例提供公共的空间，原型内的属性可以提供给构造函数所有的实例复用</p>\n<p>每一个实例都有一个<strong>proto</strong>属性指向构造函数的原型\n每一个函数都有<strong>proto</strong></p>\n'},8535:function(n,e){n.exports='<ol>\n<li>install</li>\n</ol>\n<p><code>cnpm i --save qrcode.vue</code></p>\n<ol start="2">\n<li>import and use</li>\n</ol>\n<pre><code>import QrcodeVue from &#39;qrcode.vue&#39;;\n\ncomponents: {\n  QrcodeVue\n}\n\n\n&lt;qrcode-vue :value=&quot;url&quot;&gt;&lt;/qrcode-vue&gt;</code></pre><table>\n<thead>\n<tr>\n<th>prop</th>\n<th>type</th>\n<th>default value</th>\n<th>expain</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>value</td>\n<td>String</td>\n<td>&#39;&#39;</td>\n<td>qrcode value</td>\n</tr>\n<tr>\n<td>className</td>\n<td>String</td>\n<td>&#39;&#39;</td>\n<td>qrcode element className</td>\n</tr>\n<tr>\n<td>size</td>\n<td>Number</td>\n<td>100</td>\n<td>qrcode element size</td>\n</tr>\n<tr>\n<td>level</td>\n<td>String</td>\n<td>L</td>\n<td>Error correction level (&#39;L&#39;, &#39;M&#39;, &#39;Q&#39;, &#39;H&#39;)</td>\n</tr>\n<tr>\n<td>background</td>\n<td>String</td>\n<td>#fff</td>\n<td>qrcode background color</td>\n</tr>\n<tr>\n<td>foreground</td>\n<td>String</td>\n<td>#000</td>\n<td>qrcode color</td>\n</tr>\n</tbody></table>\n'},8635:function(n,e){n.exports='<h3 id="robo">robo</h3>\n<p>链接：<a href="https://pan.baidu.com/s/1smzwtMP">https://pan.baidu.com/s/1smzwtMP</a> 密码：cu26</p>\n'},8698:function(n,e){n.exports='<h3 id="echarts">echarts</h3>\n<p>echarts是百度公司前端开发的一个图表库。 \n支持柱状图、饼状图、k线图、map图、热导向图、折线图 \n主要采用canvas画图。</p>\n<h3 id="highchart">highchart</h3>\n<p>highcharts是国外的一家公司开发的图表库，主要采用svg画图。 \n支持的图表也很多，功能也比较强大。</p>\n<h3 id="d3js">D3js</h3>\n<p>它不像echarts和highchart那样，提供很多写好的图表，直接拿过来用就行，它很自由，只要你学会它的API，进行自定义。</p>\n'},8742:function(n,e){n.exports="<ul>\n<li>建立与其他属性的联系，</li>\n<li>属性改变后通知计算属性重新计算</li>\n</ul>\n<p>初始化data,使用Object.defineProperty把这些属性转化为getter/setter.</p>\n<p>初始化computed, 遍历computed里每个属性， 每个computed属性都是一个watch实例，每个属性提供的函数作为属性的getter，使用Object.definedProperty转化。</p>\n<p>Object.defineProperty getter依赖收集，用于依赖发生变化时，触发属性重新计算。</p>\n<p>若出现嵌套其他计算属性，先进行其他计算属性依赖收集。</p>\n"},8989:function(n,e){n.exports='<ul>\n<li>every() 对数组每一项运行给定函数，如果该函数每一项返回true，则返回true。</li>\n<li>filter() ------------------------------ 返回该函数会返回true的项。</li>\n<li>forEach() ---------------------------类似于for 没有返回值。</li>\n<li>map() ------------------------------返回每次函数调用的结果组成数组。</li>\n<li>some()------------------------------ 如果该函数<code>有</code>一项返回true，则返回true。</li>\n</ul>\n<blockquote>\n<p>公共：都有两个参数\n要在每一项上运行的函数  ---------  和该函数的作用域</p>\n</blockquote>\n<pre><code>var arr = [1,2,3,4,5,4,3,2,1]</code></pre><p><code>其中every()和some()比较类似，他们都用于查询数组中的某个项是否满足某个条件。\n对于every()来说，传入的参数必须每一项都返回true,这个方法才返回true. 而some()只要有一项返回true，就返回true。</code></p>\n<pre><code>var everyResult = arr.every((item, index, array) =&gt; item &gt; 2})\n\neveryResult  // false</code></pre><pre><code>var someResult = arr.some((item, index, array) =&gt; item &gt; 2})\n\nsomeResult // true</code></pre><p><code>filter() 返回所有满足条件的项</code></p>\n<pre><code>var filterResult = arr.filter((item, index, array) =&gt; item &gt; 2})\n\nfilterResult // 3,4,5,4,3</code></pre><p><code>map 返回一个数组，而这个数组的每一项都是在原始数组的对应项上运行传入函数的结果。</code></p>\n<pre><code>var mapResult = arr.map((item, index, array) =&gt; item * 2})\n\nmapResult// 2,4,6,8,10,8,6,4,2</code></pre><p><strong>indexOf(&#39;bcd&#39;, 2)</strong> --------------- 返回全匹配元素的下标，优先返回第一个\n数组元素不接受对象，没有匹配元素返回-1</p>\n<pre><code>      let arr = [&#39;abc&#39;, &#39;bcd&#39;, &#39;cde&#39;, &#39;def&#39;];\n\n      let result = arr.indexOf(&#39;bcd&#39;, 2); // 返回第二个匹配的元素下标\n      console.log(result); // 没有返回-1</code></pre><p><strong>includes(&#39;bcd&#39;)</strong> --------------- 判断是否有该匹配元素，返回一个boolean值，用法同indexOf.</p>\n<p><strong>find(function(item, index, array) {}, this)</strong> ------ 返回第一个匹配的元素或对象</p>\n<pre><code>      let arr1 = [\n        { name: &#39;abc&#39; },\n        { name: &#39;bcd&#39; },\n        { name: &#39;cde&#39; },\n        { name: &#39;def&#39; },\n        { name: &#39;efg&#39; }\n      ]\n\n      let result2 = arr1.find(item =&gt; item.name === &#39;abc&#39;)\n      console.log(result2); // {name: &#39;abc&#39;}</code></pre><h5 id="-">附：归并</h5>\n<p><code>reduce（）\n从数组的第一项开始逐渐遍历到最后</code>\n<code>reduceRight（）\n从数组的最后一项开始逐渐遍历到第一项</code></p>\n<blockquote>\n<p>都有两个参数，在每一项上调用的函数和   （作为初始值）\n他们的函数接受四个参数，前一个值，当前值，项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一个项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项</p>\n</blockquote>\n<pre><code>使用reduce()求数组中所有值之和\nvar value = [1, 2, 3, 4, 5];\nvar sum = value.reduce((prev, cur, index, array) =&gt; prev + cur);\n\nsum // 15</code></pre>'},"8b11":function(n,e){n.exports="<blockquote>\n<p>事件委托： 通过冒泡机制，把事件加在父元素上，父元素里面的子元素通过异步加载进来，也可以触发事件。</p>\n</blockquote>\n<p>优点：减少内存的占用。</p>\n<pre><code>$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function () {\n\n})</code></pre><ul>\n<li><p><code>live</code>把事件委托给<code>document根节点</code>，document向下寻找符合元素的节点，不需要等document加载完也可以生效；</p>\n</li>\n<li><p><code>delegate</code> 可以指定事件委托对象，比<code>live</code>性能更好；</p>\n</li>\n<li><p><code>on</code> 类似于<code>delegate</code>，委托对象选填，不填默认给自身注册事件；</p>\n</li>\n<li><p><code>bind</code> 只能给调用它时已经存在的元素绑定事件，不能给新增元素绑定。</p>\n</li>\n</ul>\n"},"8d92":function(n,e){n.exports='<h2 id="mapreduce">MapReduce</h2>\n<pre><code>db.col.mapReduce(\n  function () {emit(key, value);},\n  function (key, value) {return reduceFunction},\n  {\n    out: col,\n    query: document,\n    sort: document,\n    limit: number\n  }\n)\n\nmap ：映射函数 (生成键值对序列,作为 reduce 函数参数)。\nreduce 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。\nout 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。\nquery 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）\nsort 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制\nlimit 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）</code></pre><p>eg:</p>\n<pre><code>&gt;db.posts.mapReduce( \n   function() { emit(this.user_name,1); }, \n   function(key, values) {return Array.sum(values)}, \n      {  \n         query:{status:&quot;active&quot;},  \n         out:&quot;post_total&quot; \n      }\n).find()\n\n在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:&quot;active&quot;)，\n并通过user_name分组，计算每个用户的文章数</code></pre>'},"8e7d":function(n,e){n.exports='<h3 id="-">加载文件</h3>\n<pre><code>.load(url, data, callback);\n\n\n把 &quot;demo_test.txt&quot; 文件中 id=&quot;p1&quot; 的元素的内容，\n加载到指定的 &lt;div&gt; 元素中\n\n$(&quot;#div1&quot;).load(&quot;demo_test.txt #p1&quot;);</code></pre><h3 id="get">get</h3>\n<pre><code>$.get(URL, function (data, status) {});\n\n</code></pre><h3 id="post">post</h3>\n<pre><code>$.post(URL, data, callback);\n\n</code></pre>'},9085:function(n,e){n.exports='<ol>\n<li>手机号验证（/^1[34578]\\d{9}$/）</li>\n</ol>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-886818a06460f304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则验证手机号"></p>\n<pre><code>function validatePhone (phoneValue) { \n  phoneValue = valueTrim(phoneValue); \n  var reg = /^[1][0-9]{10}$/; \n  return reg.test(phoneValue); \n} </code></pre><ol start="2">\n<li>邮箱验证/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/</li>\n</ol>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-681408f6894b2c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="邮箱验证"></p>\n<ol start="3">\n<li>输入框不为空</li>\n</ol>\n<pre><code>    trim (s) {\n      return s.replace(/(^\\s*)|(\\s*$)/g, &#39;&#39;)\n    }\n\nif (this.trim(this.templateName) === &#39;&#39; || this.trim(this.templateName) === null) return</code></pre><ol start="4">\n<li>输入金额</li>\n</ol>\n<p><code>/^\\d*(?:\\.\\d{0,2})?$/</code></p>\n<pre><code>\n//第一种在input输入框限制 \n &lt;input type=&quot;text&quot; maxlength=&quot;8&quot; class=&quot;form-control&quot; id=&quot;amount&quot; style=&quot;margin-right: 2px;&quot; value=&quot;&quot; onChange=&quot;count();&quot; onkeyup=&quot;if (this.value==this.value2) return; if (this.value.search(/^\\d*(?:\\.\\d{0,2})?$/)==-1) this.value=(this.value2)?this.value2:&#39;&#39;;else this.value2=this.value;&quot;&gt;元 \n//第二种对于表单动态增加的方式，只能在js方法中验证。 \n var amount=$(&quot;#amount&quot;).val(); \n if (amount.search(/^\\d*(?:\\.\\d{0,2})?$/)==-1) { \n   alert(&quot;金额格式不对，最多有两位小数&quot;); \n   return false; \n}</code></pre><ol start="5">\n<li>输入密码格式为字母数字特殊字符，且长度为8-20位</li>\n</ol>\n<pre><code>function validatePwd (str) { \n  if (/^.*?[\\d]+.*$/.test(str)\n  &amp;&amp; /^.*?[A-Za-z]/.test(str) \n  &amp;&amp; /^.*?[~/`!@#$%^&amp;*()_+|{}?;:&gt;&lt;\\-\\]\\\\[\\/].*$/.test(str)\n  &amp;&amp; /^.{8,20}$/.test(str)) { \n    return true; \n  } \n  return false; \n} </code></pre><ol start="6">\n<li>判断是否为汉字</li>\n</ol>\n<pre><code>function isCharacter (charValue) { \n  var reg = /^[\\u4e00-\\u9fa5]{0,}$/; \n  return reg.test(charValue); \n}\n</code></pre><ol start="7">\n<li>判断是否为字母</li>\n</ol>\n<pre><code>function isChar (charValue) { \n  var charPattern=/^[a-zA-Z]*$/;\n  return charPattern.test(charValue);\n} </code></pre><ol start="8">\n<li>判断是否为数字</li>\n</ol>\n<pre><code>function isNum (numValue) { \n   var numPattern=/^\\d*$/;\n   return numPattern.test(numValue);\n} </code></pre><ol start="9">\n<li>判断整数</li>\n</ol>\n<pre><code>function isInt(intValue){ \n  var intPattern=/^0$|^[1-9]\\d*$/;\n  return intPattern.test(intValue);\n}</code></pre><ol start="10">\n<li>判断字母和数字</li>\n</ol>\n<pre><code>function isCharNum(flagValue){ \n  var flagPattern=/^[a-Z0-9]*$/;\n  return flagPattern.test(flagValue);\n} </code></pre><ol start="11">\n<li>验证18位身份证号</li>\n</ol>\n<pre><code>function idCardVildate(cid) {\n  var arrExp = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ];// 加权因子\n  var arrValid = [ 1, 0, &quot;X&quot;, 9, 8, 7, 6, 5, 4, 3, 2 ];// 校验码\n  var reg = /^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$/;\n\n  if (reg.test(cid)) {\n    let sum = 0;\n    let idx;\n    for (let i = 0; i &lt; cid.length - 1; i++) {\n      // 对前17位数字与权值乘积求和\n      sum += parseInt(cid.substr(i, 1), 10) * arrExp[i];\n    }\n\n    // 计算模（固定算法\n    idx = sum % 11;\n\n    // 检验第18位是否与校验码相等\n    return arrValid[idx] == cid.substr(17, 1).toUpperCase();\n  } else {\n    return false;\n  }\n}</code></pre><ol start="12">\n<li>验证15位身份证号码中，生日是否有效</li>\n</ol>\n<pre><code>function isValidityBrithBy15IdCard(idCard15) { \n  var year = idCard15.substring(6, 8); \n  var month = idCard15.substring(8, 10); \n  var day = idCard15.substring(10, 12); \n  var temp_date = new Date(year, parseFloat(month) - 1, parseFloat(day));\n\n  // 对于老身份证中的你年龄则不需考虑千年虫问题而使用getYear()方法 \n  if (temp_date.getYear() != parseFloat(year) \n    || temp_date.getMonth() != parseFloat(month) - 1 \n    || temp_date.getDate() != parseFloat(day)) { \n    return false; \n  } else { \n    return true; \n  } \n}</code></pre><ol start="13">\n<li>验证18位身份证中，生日是否有效</li>\n</ol>\n<pre><code>function isValidityBrithBy18IdCard(idCard18) { \n  var year = idCard18.substring(6, 10);\n  var month = idCard18.substring(10, 12);\n  var day = idCard18.substring(12, 14);\n  var temp_date = new Date(year, parseFloat(month) - 1, parseFloat(day));\n\n  // 这里用getFullYear()获取年份，避免千年虫问题\n  if (temp_date.getFullYear() != parseFloat(year)\n    || temp_date.getMonth() != parseFloat(month) - 1\n    || temp_date.getDate() != parseFloat(day)) {\n    return false;\n  } else {\n    return true;\n  }\n}</code></pre><ol start="14">\n<li>匹配IP地址的正则</li>\n</ol>\n<p><code>/(d+).(d+).(d+).(d+)/</code></p>\n<pre><code>  function IP2V(ip){\n    re=/(d+).(d+).(d+).(d+)/g;\n    if(re.test(ip)){\n      return RegExp.$1*Math.pow(255,3))+\n      RegExp.$2*Math.pow(255,2))+\n      RegExp.$3*255+RegExp.$4*1;\n    }\n    else{\n      throw new Error(&quot;Not a valid IP address!&quot;);\n    }\n  }\n</code></pre><pre><code>var ip=&quot;10.100.20.168&quot;;\nip=ip.split(&quot;.&quot;);\nalert(&quot;IP值是：&quot;+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1));</code></pre><ol start="15">\n<li>字符串去重 (不适用于要求字符顺序)</li>\n</ol>\n<pre><code>var s=&quot;abacabefgeeii&quot;;\nvar s1=s.replace(/(.).*1/g,&quot;$1&quot;);\nvar re=new RegExp(&quot;[&quot;+s1+&quot;]&quot;,&quot;g&quot;);\nvar s2=s.replace(re,&quot;&quot;);\nalert(s1+s2);</code></pre><ol start="16">\n<li>从字符串中提取文件名</li>\n</ol>\n<pre><code>s=&quot;http://www.9499.net/page1.htm&quot;;\ns=s.replace(/(.*/){0,}([^.]+).*/ig,&quot;$2&quot;);\nalert(s);</code></pre><ol start="17">\n<li>删除字符串中的html标签</li>\n</ol>\n<pre><code>ctx.replace(/&lt;[^&gt;]*&gt;/g, &#39;&#39;)</code></pre>'},"909b":function(n,e){n.exports="<p>非web标准</p>\n<pre><code>-webkit-font-smoothing: antialiased; /*chrome、safari*/\n-moz-osx-font-smoothing: grayscale;/*firefox*/\n\n\n它有三个属性值：\nnone ------ 对低像素的文本比较好\nsubpixel-antialiased------默认值\nantialiased ------消除锯齿效果好</code></pre>"},9121:function(n,e){n.exports='<p><a href="http://www.framework7.cn/">官网</a></p>\n<ol>\n<li>选择最新的版本</li>\n</ol>\n<p><img src="http://p5k2est0u.bkt.clouddn.com/framework7/info20180904161353.png" alt="framework"></p>\n<ol start="2">\n<li>安装</li>\n</ol>\n<p><strong>framework7</strong></p>\n<p><strong>framework7-vue</strong></p>\n<p><code>main.js</code>文件</p>\n<pre><code>import Vue from &#39;vue&#39;\nimport Framework7 from &#39;framework7/dist/framework7.esm.bundle.js&#39;\nimport Framework7Vue from &#39;framework7-vue/dist/framework7-vue.esm.bundle.js&#39;\nimport &#39;framework7/dist/css/framework7.css&#39;\n\nVue.use(Framework7Vue, Framework7)\n\nnew Vue({\n  el: &#39;#app&#39;,\n  template: &#39;&lt;app/&gt;&#39;,\n  router,\n  store,\n  // Init Framework7 by passing parameters here\n  framework7: {\n    id: &#39;io.framework7.testapp&#39;, // App bundle ID\n    name: &#39;Framework7&#39;, // App name\n    theme: &#39;auto&#39; // Automatic theme detection\n    // App routes\n    // routes: Routes, // framework有自带的路由，这里没有引入\n  },\n  components: {\n    app: App\n  }\n})</code></pre><blockquote>\n<p>由于已经初始化了,在页面中可以通过<code>this.$f7</code>代替文档中<code>new Framework7()</code>，一般都会接受一个返回</p>\n</blockquote>\n<ul>\n<li>eg:</li>\n</ul>\n<pre><code>  this.$f7.toast.create({\n    text: message,\n    position: &#39;center&#39;,\n    closeTimeout: 2000\n  }).open()</code></pre><h3 id="-">注</h3>\n<p>在<code>framework7</code>中拦截了一些原生标签，如<code>&lt;a&gt;&lt;/a&gt;</code>,用来做<code>framework7</code>的路由跳转；\n要想正常使用需要加<code>class</code>,</p>\n<p>如<code>&lt;a class=&quot;link external&quot; href=&quot;http://google.com&quot;&gt;Open Google&lt;/a&gt;</code>;</p>\n<p>....</p>\n<p><a href="http://www.framework7.cn/docs/introduction.html">官方文档</a></p>\n'},"91c9":function(n,e){n.exports='<p>一、通过axios插件进行数据请求：</p>\n<ul>\n<li><p>get请求</p>\n<pre><code> this.$https.get(`/msgboard/msgBoardPage\n  ?zoneId=${this.user.id}                     \n  &amp;pageNo=${this.currentPage}\n  &amp;pageSize=10`)\n  .then(res =&gt; {\n      console.log(res)\n  })</code></pre><pre><code>  this.$https.get(`/msgboard/msgBoardPage\n                    ?zoneId=${this.user.id} \n                    &amp;pageNo=${this.currentPage}\n                    &amp;pageSize=10`)\n  .then(res =&gt; {\n      console.log(res)\n  })</code></pre></li>\n<li><p>post请求</p>\n<pre><code>   this.$https.post(`/msgboard/msgBoardAdd`,\n                      querystring.stringify({\n                          message: this.textarea,\n                          state: this.value\n                      }))\n  .then({\n      console.log(res)\n  })</code></pre><pre><code>axios({\n  methods: &#39;get&#39;,\n  url: &#39;/fkasldf&#39;\n})\n.then(res =&gt; {\n  console.log(res)\n})\n.catch(res =&gt; {\n  console.log(res)\n})</code></pre></li>\n</ul>\n<pre><code>axios.post(&#39;url&#39;, {\n    params: &#39;123&#39;\n})\n.then(res =&gt; {\n    console.log(res)\n})\n.catch(res =&gt; {\n    console.log(res)\n})</code></pre><p><strong>配置</strong></p>\n<pre><code>import axios from &#39;axios&#39;\nimport queryString from &#39;queryString&#39;\n\nvar ax = axios.create({\n    baseUrl: &#39;http://..&#39;,\n    timeout: 1000,\n    headers: {},\n    responseType: &#39;json&#39;,\n    params: {},\n    transformRequest: [function (data) {\n        // 发送的数据进行转换\n        return queryString.stringify(data)\n    }],\n    transformResponse: [function (data) {\n        // 返回的数据进行转换\n        return data\n    }],\n    validateStatus (status) {\n        // 判断返回的状态码返回boolean\n    },\n    cancelToken // 取消用户请求\n})\n\nax.get(&#39;/abc&#39;)</code></pre><p><strong>发送多个请求</strong></p>\n<pre><code>function http1 () {\n    return ax.get(&#39;/abc&#39;)\n}\nfunctin http2 () {\n    return ax.post(&#39;bck&#39;)\n}\naxios.all([http1(), http2()])\n.then(res =&gt; {\n    console.log(res)\n})\n.catch(res =&gt; {\n    console.log(res)\n})</code></pre><pre><code>function http1 () {\n    return ax.get(&#39;/abc&#39;)\n}\nfunctin http2 () {\n    return ax.post(&#39;bck&#39;)\n}\naxios.all([http1(), http2()])\n.then(axios.spread((res1, res2) =&gt; {\n    console.log(res1)\n}))\n.catch(res =&gt; {\n    console.log(res)\n})</code></pre><p><strong>拦截器</strong>\n1 请求拦截</p>\n<pre><code>axios.interceptors.request.use((config) =&gt; {\n    // 发送请求之前操作\n    console.log(config)\n    return config\n}, function (error) =&gt; {\n    // 请求错误\n    return Promise.reject(error)\n})</code></pre><p>2 响应拦截</p>\n<pre><code>axios.interceptors.response.use((data) =&gt; {\n    // 发送请求之前操作\n    console.log(data)\n    return data\n})</code></pre><blockquote>\n<p>${}   里面放变量</p>\n</blockquote>\n<p>二、动态添加class</p>\n<pre><code>    :class=&quot;{&#39;class名&#39;: i&gt;1 &amp;&amp; i&lt;5}&quot;\n\n    // 根据条件添加class，注：大括号外面要加引号\n\n    动态添加多个class名\n    :class=&quot;{&#39;class1&#39;: 条件一, &#39;class2&#39;: 条件二}&quot;</code></pre><p>三、vuex</p>\n<p>官方定义：一种集中式的存储管理应用所有组件的状态(状态管理模式)</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-a774b846e866a9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖"></p>\n<p>用来兼容IE不支持store的情况\n在模块化的打包系统中，必须显示的通过</p>\n<pre><code>Vue.use()</code></pre><p>来安装</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-e359a5bcfc7a2486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引入"></p>\n<p><code>也可以通过引用全局的script标签引入</code></p>\n<p>使用场景：开发大型单页应用</p>\n<ul>\n<li>核心就是store仓库，它包含着你的应用中大部分的状态(state)</li>\n</ul>\n<p>vuex 和单纯的全局对象有两点不同</p>\n<p>1.Vuex的状态是响应式的。\n2.不能直接改变store中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。</p>\n<p>在main.js中</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-6d8bf1842831538f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注入"></p>\n<p>把store实例注入到所有的子组件\n并且子组件能够通过this.$store()访问到</p>\n<p>当一个组件需要多个状态时，如果都声明为计算属性会重复冗余。所以引出mapState辅助函数帮助生成计算属性</p>\n<pre><code>import {mapState} from &#39;vuex&#39;\n\ncomputed: mapState({\n    count: state =&gt; state.count\n\n    countAlias: &#39;count&#39; // 等同于 `state =&gt; state.count`\n\n    countState (state) { // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        return state.count + this.localCount\n    }\n})\n\ncomputed: {\n    ...mapState([&#39;count&#39;])\n}</code></pre><p>getters 从store中的state中派生出一些状态；Getters 接受 state 作为其第一个参数</p>\n<p>mapGetters 辅助函数：仅仅是将 store 中的 getters 映射到局部计算属性</p>\n<pre><code>import { mapGetters } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getters 混入 computed 对象中\n    ...mapGetters([\n      &#39;doneTodosCount&#39;,\n      &#39;anotherGetter&#39;,\n      // ...\n    ])\n  }\n}\n</code></pre><p>Mutations\n<code>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数</code></p>\n<pre><code>const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})</code></pre><p>需要以相应的 type 调用 store.commit 方法</p>\n<pre><code>store.commit(&#39;increment&#39;)</code></pre><pre><code>import { mapMatations } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n\n    ...mapMatations({\n        add: addAction\n    })\n  }\n}\n\n传值的时候\n&lt;p @click=&quot;add(传值)&quot;&gt;点击&lt;/p&gt;</code></pre><p><code>mapActions</code></p>\n<pre><code>import { mapActions } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n\n    ...mapActions({\n        add: addAction\n    })\n  }\n}</code></pre><h3 id="-querystring-">四、querystring类</h3>\n<p>node.js原生自带类，直接<code>require(&#39;querystring&#39;)</code>使用</p>\n<pre><code>四个方法：\nquerystring.stringify(obj, [sep], [eq])； // 对象格式化成参数字符串\n\nquerystring.parse(str, [sep], [eq], [options]); // 字符串格式化成对象\n\nquerystring.escape(); // 参数编码\n\nquerystring.unescape(); // 参数解码\n</code></pre><p><strong>1.querystring.stringify(obj, [sep], [eq])；</strong></p>\n<p>接受三个参数\n[sep]: 分隔符，默认<code>&amp;</code>\n[eq]: 分配符，默认<code>=</code></p>\n<pre><code>    let obj = {\n      name: &#39;名字&#39;,\n      age: 12\n    }\n\n    let param = querystring.stringify(obj)\n    console.log(param)\n</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-736b80f9ff96692b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p><strong>2.querystring.parse(str, [sep], [eq], [options])；</strong></p>\n<pre><code>    let a = querystring.parse(param)\n    console.log(a)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-a2ce47e0b208d4c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p><strong>3.querystring.escape</strong></p>\n'},9298:function(n,e){n.exports='<h2 id="-">调用浏览器自带的下载</h2>\n<pre><code>var $a = document.createElement(&#39;a&#39;)\n$a.setAttribute(&#39;href&#39;, this.url)\n$a.setAttribute(&#39;download&#39;, &#39;&#39;)\nvar evObj = document.createEvent(&#39;MouseEvents&#39;)\nevObj.initMouseEvent(&#39;click&#39;, true, true, window, 0, 0, 0, 0, 0, false, false, true, false, 0, null)\n$a.dispatchEvent(evObj)</code></pre><h2 id="a-">a标签</h2>\n<pre><code>      var canvas = document.getElementById(&#39;canvas&#39;)\n      var ctx = canvas.getContext(&#39;2d&#39;)\n      var image = new Image()\n      image.crossOrigin = &#39;*&#39;\n      image.onload = function () {\n        ctx.drawImage(image, 0, 0)\n        let url = canvas.toDataURL(&#39;image/png&#39;)\n        var a = document.createElement(&#39;a&#39;)\n        var event = new MouseEvent(&#39;click&#39;)\n        a.download = name || &#39;下载图片名称&#39;\n        a.href = url\n        a.dispatchEvent(event)\n      }\n      image.src = this.url\n</code></pre><p>或</p>\n<pre><code>      var canvas = document.getElementById(&#39;canvas&#39;)\n      var ctx = canvas.getContext(&#39;2d&#39;)\n      var image = new Image()\n      image.crossOrigin = &#39;*&#39;\n      image.onload = function () {\n        ctx.drawImage(image, 0, 0)\n        let url = canvas.toDataURL(&#39;image/png&#39;).replace(&#39;image/png&#39;, &#39;image/octet-stream&#39;)\n\n        window.location.href = url\n      }\n      image.src = this.info.icode</code></pre><p>html2canvas</p>\n<pre><code>import html2canvas from &#39;html2canvas&#39;\n\n      html2canvas(document.querySelector(&#39;.share-body&#39;)).then(function(canvas) {\n        document.body.appendChild(canvas)\n      })</code></pre><p>下载base64图片</p>\n<pre><code>    saveImg (fileName, img) {\n      let aLink = document.createElement(&#39;a&#39;)\n      let blob = this.base64ToBlob(img)\n      let evt = document.createEvent(&#39;HTMLEvents&#39;)\n      evt.initEvent(&#39;click&#39;, true, true)\n      aLink.download = &#39;code.png&#39;\n      aLink.href = URL.createObjectURL(blob)\n      aLink.click()\n    },\n    base64ToBlob (code) {\n      let parts = code.split(&#39;;base64,&#39;)\n      let contentType = parts[0].split(&#39;:&#39;)[1]\n      let raw = window.atob(parts[1])\n      let rawLength = raw.length\n      let uInt8Array = new Uint8Array(rawLength)\n      for (let i = 0; i &lt; rawLength; ++i) {\n        uInt8Array[i] = raw.charCodeAt(i)\n      }\n      return new Blob([uInt8Array], {type: contentType})\n    }</code></pre>'},"957f":function(n,e){n.exports="<p>有四个属性值：\ntranslate  // 位移(距离，有translateX,translateY)\nrotate // 旋转（角度deg，也有相应的XY方向）\nscale  //缩放 （缩放倍数，有XY方向的）\nskewX  /  skewY // 倾斜</p>\n<p>常用于2d变化中</p>\n<blockquote>\n<p>3D效果</p>\n</blockquote>\n<p>在父元素加</p>\n<pre><code>transform-style: preverse-3d;//开启3d模式</code></pre><p>设置舞台深度</p>\n<pre><code>perspective: 200px;</code></pre><p>设置舞台中心点</p>\n<pre><code>perspective-origin: 0 0;</code></pre><p>设置元素背面不可见，是元素给元素自身上添加</p>\n<pre><code>backface-visibility: hidden;</code></pre><p>使用transform进行设置</p>\n<pre><code>transform: rotate3d(1,1,0,90deg)\n第一个数字表示X轴是否发生旋转，第二个参数表示Y轴是否旋转，第三个Z轴，第四个参数为旋转角度\n\ntransform:translate3d(100px,100px,1000px)\n\ntransform:scale3d(1.5,0.5,1);\n\n\n\n\n\n\n\n</code></pre>"},9656:function(n,e){n.exports='<p>结构如下：</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-5c70f944c943cfec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="他在发呆"></p>\n<p>现在画线的不是固定高度，由内容支撑，有一个最小高度。点击出现输入框和树，绝对定位，不影响下面元素布局，并且根据显示框高度，相对位置不变。\n如果直接设置绝对定位，那么会顶到最上面，挡住显示框。\n如果给显示框绝对定位，那么高度不会自适应。\n所以给输入框和树设置绝对定位，并且设置一个margin-top:0;\n在显示框设置margin-bottom: 0;</p>\n<p>注：不要问我为什么</p>\n'},"975b":function(n,e){n.exports="<blockquote>\n<p>解决移动设备可选中页面文本</p>\n</blockquote>\n<pre><code>p{\n    user-select:none;\n}</code></pre><blockquote>\n<p>解决长时间按住页面闪退现象</p>\n</blockquote>\n<pre><code>p{\n    touch-callout:none;\n}</code></pre>"},"97f7":function(n,e){n.exports='<h4 id="-">文档保存、修改、删除</h4>\n<table>\n<thead>\n<tr>\n<th>常用命令</th>\n<th>解释</th>\n<th>eg</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$set</td>\n<td>用来指定一个键并更新键值，不存在就创建</td>\n<td><code>{$set: {field: value}}</code></td>\n</tr>\n<tr>\n<td>$unset</td>\n<td>用来删除一个键</td>\n<td><code>{$unset: {field: 1}}</code></td>\n</tr>\n<tr>\n<td>$inc</td>\n<td>对某个数字型值的键进行增减操作</td>\n<td><code>{$inc: {field: value}}</code></td>\n</tr>\n<tr>\n<td>$push</td>\n<td>把value追加到field里面去，field一定要是数组类型才行，不存在新增一个数组类型加进去。</td>\n<td><code>{$push: {field: value}}</code></td>\n</tr>\n<tr>\n<td>$pushAll</td>\n<td>同<code>push</code>，一次可以加多个</td>\n<td><code>{$pushAll: {field: value_array}}</code></td>\n</tr>\n<tr>\n<td>$pull</td>\n<td>从field数组中删除一个等于value的值</td>\n<td><code>{$pull: {field: _value}}</code></td>\n</tr>\n<tr>\n<td>$addToSet</td>\n<td>增加一个值到数组，条件是只有这个值不在数组中才增加</td>\n<td><code>{$addToSet: {field: _value}}</code></td>\n</tr>\n<tr>\n<td>$pop</td>\n<td>删除数组的第一个或最后一个元素</td>\n<td><code>{$pop: {field: 1}}</code></td>\n</tr>\n<tr>\n<td>$rename</td>\n<td>修改字段名</td>\n<td><code>{$rename: {old_field_name: new_field_name}}</code></td>\n</tr>\n<tr>\n<td>$bit</td>\n<td>位操作，integer类型</td>\n<td><code>{$bit: {field: {and: 5}}}</code></td>\n</tr>\n</tbody></table>\n'},"99ef":function(n,e){n.exports='<p>实现一个基本功能</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-8098f4917c0cc9ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="画图"></p>\n<p>点击li切换头像，把li中的信息传递到头部</p>\n<pre><code>&lt;script&gt;\n    export default {\n        data() {\n            return {\n                data: {}\n            }\n        },\n        methods: {\n          fetchDate() {\n          //this.$http.get()\n          ......\n          }\n         },\n         created() {\n           this.fetchDate();\n         },\n         watch: {\n           // 如果路由有变化，会调用该函数\n           &quot;$route&quot;: &quot;fetchDate&quot;\n         }\n    }\n&lt;/script&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-a9fa9ecc5efa4109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例"></p>\n<p>#传参</p>\n<p>在要实现点击跳转的页面</p>\n<pre><code>this.$router.push({path: &#39;/personal/default&#39;, query: {id: &#39;id&#39;}})</code></pre><p>在路由页面</p>\n<pre><code>create () {\n    let id =  this.$route.query.id\n    console.log(id)\n}</code></pre>'},"9c26":function(n,e){n.exports='<h3 id="-">端口</h3>\n<p>端口号是从1-65535</p>\n<h3 id="express">express</h3>\n<p>通过listen(8080, function (req, res) {})新建一个8080端口服务</p>\n<p><code>body-parser</code>: 获取浏览器url传进来的参数，通过req.query.参数名获取，\n获取body数据时，express默认不处理，需要引入</p>\n<p><code>superagent</code>: http方面的库，发起get，post请求。抓取网页内容。</p>\n<p><code>cheerio</code>: node版的jquery.</p>\n<p><code>eventproxy</code>: 高等计数器</p>\n<pre><code class="language-js">var ep = new eventproxy();\nep.all(&#39;data1_event&#39;, &#39;data2_event&#39;, &#39;data3_event&#39;, function (data1, data2, data3) {\n  var html = fuck(data1, data2, data3);\n  render(html);\n});\n\n$.get(&#39;http://data1_source&#39;, function (data) {\n  ep.emit(&#39;data1_event&#39;, data);\n  });\n\n$.get(&#39;http://data2_source&#39;, function (data) {\n  ep.emit(&#39;data2_event&#39;, data);\n  });\n\n$.get(&#39;http://data3_source&#39;, function (data) {\n  ep.emit(&#39;data3_event&#39;, data);\n  });</code></pre>\n<p><code>url</code>: node标准库里面的</p>\n<p><code>async</code>: 异步，控制并发，限制并发数量</p>\n<p><code>nodemon</code>: 自动检测node.js代码的改动，然后帮你自动重启应用，在调试时，用nodemon命令代替node命令。</p>\n'},"9d3a":function(n,e){n.exports="<h3 id=\"-\">类型</h3>\n<ol>\n<li><p>UEditor 百度富文本 大</p>\n</li>\n<li><p>quill 轻量级 可自行扩展</p>\n</li>\n<li><p>tinymce 功能齐全 能从word复制过来 需要翻墙 （<a href=\"https://surmon-china.github.io/vue-quill-editor/%EF%BC%89\">https://surmon-china.github.io/vue-quill-editor/）</a>\n（<a href=\"https://github.com/surmon-china/vue-quill-editor%EF%BC%89\">https://github.com/surmon-china/vue-quill-editor）</a></p>\n</li>\n</ol>\n<h4 id=\"tinymce-vue-components\">tinymce vue components</h4>\n<ol>\n<li>create <code>editor.vue</code>\n```<template>\n<textarea :id=\"id\" :value=\"value\"></textarea>\n</template>\n<script>\n import tinymce from 'tinymce/tinymce';\n import 'tinymce/themes/modern/theme';\n import 'tinymce/plugins/paste';\n import 'tinymce/plugins/link';\n const INIT = 0;\n const CHANGED = 2;\n var EDITOR = null;\n export default {\n     props: {\n         value: {\n             type: String,\n             required: true\n         },\n         setting: {}\n     },\n     watch: {\n         value: function (val) {              \n             console.log('init ' + val)\n             if (this.status == INIT || tinymce.activeEditor.getContent() != val){\n                 tinymce.activeEditor.setContent(val);\n             }\n             this.status = CHANGED\n         }\n     },\n     data: function () {\n         return {\n             status: INIT,\n             id: 'editor-'+new Date().getMilliseconds(),\n         }\n     },\n     mounted: function () {\n         const _this = this;\n         const setting =\n             {\n                 selector:'#'+_this.id,\n                 language:\"zh_CN\",\n                 language_url: '../../static/tinymce/zh_CN.js',\n                 skin_url: '../../static/tinymce/skins/lightgray',\n                 init_instance_callback:function(editor) {\n                     EDITOR = editor;\n                     console.log(\"Editor: \" + editor.id + \" is now initialized.\");\n                     editor.on('input change undo redo', () => {\n                         var content = editor.getContent()\n                         _this.$emit('input', content);\n                     });\n                 },\n                 plugins:[]\n             };\n         Object.assign(setting,_this.setting)\n         tinymce.init(setting);\n     },\n     beforeDestroy: function () {\n         tinymce.get(this.id).destroy();\n     }\n }\n\n</li>\n</ol>\n<p><\/script></p>\n<pre><code>\n2. `npm i tinymce -S`\n\n3. `node_modules/tinymce/skins`文件夹 粘出来 放在`static/tinymce/`文件加下\n\n翻墙（https://www.tinymce.com/download/language-packages/）下载中文包放在该目录下\n\n4. use\n</code></pre><template>\n  <div class=\"home\">\n    Home\n\n<pre><code>&lt;editor class=&quot;editor&quot; ref=&quot;ue1&quot; :value=&quot;content1&quot;  :setting=&quot;editorSetting&quot; @input=&quot;contentUe&quot;&gt;&lt;/editor&gt;</code></pre>  </div>\n</template>\n\n<script>\nimport editor from '../components/editor'\nexport default {\n  name: 'home',\n  data () {\n    return {\n      content1: '',\n      editorSetting: {}\n    }\n  },\n  components: {\n    editor\n  },\n  methods: {\n\n  }\n}\n<\/script>\n\n<style lang=\"scss\" scoped>\n\n</style>\n\n<p>```</p>\n"},"9e93":function(n,e){n.exports='<h2 id="objectid">ObjectId</h2>\n<p>12个字节</p>\n<ul>\n<li><p>前四个表示时间戳</p>\n</li>\n<li><p>接下来3个字节是机器识别码</p>\n</li>\n<li><p>紧接着的两个字节由进程Id组成（PID）</p>\n</li>\n<li><p>最后三个字节是随机数</p>\n</li>\n</ul>\n<blockquote>\n<p>MongoDB采用ObjectId，而不是其他比较常规的做法（比如自动增加的主键）的主要原因，因为在多个 服务器上同步自动增加主键值既费力还费时。</p>\n</blockquote>\n<p><strong>获取创建文档保存的时间戳</strong></p>\n<pre><code>ObjectId(&quot;nnnnnn&quot;).getTimestamp()\n\n返回ISO格式的文档创建时间</code></pre><p><strong>转换为字符串</strong></p>\n<pre><code>new ObjectId().str</code></pre><h1 id="-">自动增长</h1>\n<ol>\n<li><p>创建一个counters集合，\n<code>db.createCollection(&quot;counters&quot;)</code></p>\n</li>\n<li><p>向counters中插入数据，使productid作为key\n<code>db.counters.insert({_id:&quot;productid&quot;,sequence_value:0})</code></p>\n</li>\n<li><p>创建一个Javascript函数</p>\n<pre><code>function getNextSequenceValue(sequenceName){\nvar sequenceDocument = db.counters.findAndModify(\n   {\n      query:{_id: sequenceName },\n      update: {$inc:{sequence_value:1}},\n      new:true\n   });\nreturn sequenceDocument.sequence_value;\n}</code></pre></li>\n<li><p>使用getNextSequenceValue函数创建新文档</p>\n<pre><code>db.products.insert({\n&quot;_id&quot;:getNextSequenceValue(&quot;productid&quot;),\n&quot;product_name&quot;:&quot;Apple iPhone&quot;,\n&quot;category&quot;:&quot;mobiles&quot;})</code></pre></li>\n<li><p>查看\n<code>db.products.find()</code></p>\n</li>\n</ol>\n<p><img src="https://github.com/Heisinadaze/mynotes/blob/master/MongoDB/id++.png" alt="_"></p>\n'},"9ec1":function(n,e){n.exports="<table>\n<thead>\n<tr>\n<th>中文名</th>\n<th>英文名</th>\n<th>Unicode</th>\n<th>Unicode 2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mac OS</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>华文细黑</td>\n<td>STHeiti Light [STXihei]</td>\n<td>\\534E\\6587\\7EC6\\9ED1</td>\n<td>华文细黑</td>\n</tr>\n<tr>\n<td>华文黑体</td>\n<td>STHeiti</td>\n<td>\\534E\\6587\\9ED1\\4F53</td>\n<td>华文黑体</td>\n</tr>\n<tr>\n<td>华文楷体</td>\n<td>STKaiti</td>\n<td>\\534E\\6587\\6977\\4F53</td>\n<td>华文楷体</td>\n</tr>\n<tr>\n<td>华文宋体</td>\n<td>STSong</td>\n<td>\\534E\\6587\\5B8B\\4F53</td>\n<td>华文宋体</td>\n</tr>\n<tr>\n<td>华文仿宋</td>\n<td>STFangsong</td>\n<td>\\534E\\6587\\4EFF\\5B8B</td>\n<td>华文仿宋</td>\n</tr>\n<tr>\n<td>丽黑 Pro</td>\n<td>LiHei Pro Medium</td>\n<td>\\4E3D\\9ED1 Pro</td>\n<td>丽黑 Pro</td>\n</tr>\n<tr>\n<td>丽宋 Pro</td>\n<td>LiSong Pro Light</td>\n<td>\\4E3D\\5B8B Pro</td>\n<td>丽宋 Pro</td>\n</tr>\n<tr>\n<td>标楷体</td>\n<td>BiauKai</td>\n<td>\\6807\\6977\\4F53</td>\n<td>标楷体</td>\n</tr>\n<tr>\n<td>苹果丽中黑</td>\n<td>Apple LiGothic Medium</td>\n<td>\\82F9\\679C\\4E3D\\4E2D\\9ED1</td>\n<td>苹果丽中黑</td>\n</tr>\n<tr>\n<td>苹果丽细宋</td>\n<td>Apple LiSung Light</td>\n<td>\\82F9\\679C\\4E3D\\7EC6\\5B8B</td>\n<td>苹果丽细宋</td>\n</tr>\n<tr>\n<td>Windows</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>新细明体</td>\n<td>PMingLiU</td>\n<td>\\65B0\\7EC6\\660E\\4F53</td>\n<td>新细明体</td>\n</tr>\n<tr>\n<td>细明体</td>\n<td>MingLiU</td>\n<td>\\7EC6\\660E\\4F53</td>\n<td>细明体</td>\n</tr>\n<tr>\n<td>标楷体</td>\n<td>DFKai-SB</td>\n<td>\\6807\\6977\\4F53</td>\n<td>标楷体</td>\n</tr>\n<tr>\n<td>黑体</td>\n<td>SimHei</td>\n<td>\\9ED1\\4F53</td>\n<td>黑体</td>\n</tr>\n<tr>\n<td>宋体</td>\n<td>SimSun</td>\n<td>\\5B8B\\4F53</td>\n<td>宋体</td>\n</tr>\n<tr>\n<td>新宋体</td>\n<td>NSimSun</td>\n<td>\\65B0\\5B8B\\4F53</td>\n<td>新宋体</td>\n</tr>\n<tr>\n<td>仿宋</td>\n<td>FangSong</td>\n<td>\\4EFF\\5B8B</td>\n<td>仿宋</td>\n</tr>\n<tr>\n<td>楷体</td>\n<td>KaiTi</td>\n<td>\\6977\\4F53</td>\n<td>楷体</td>\n</tr>\n<tr>\n<td>仿宋_GB2312</td>\n<td>FangSong_GB2312</td>\n<td>\\4EFF\\5B8B_GB2312</td>\n<td>仿宋_GB2312</td>\n</tr>\n<tr>\n<td>楷体_GB2312</td>\n<td>KaiTi_GB2312</td>\n<td>\\6977\\4F53_GB2312</td>\n<td>楷体_GB2312</td>\n</tr>\n<tr>\n<td>微软正黑体</td>\n<td>Microsoft JhengHei</td>\n<td>\\5FAE\\x8F6F\\6B63\\9ED1\\4F53</td>\n<td>微软正黑体</td>\n</tr>\n<tr>\n<td>微软雅黑</td>\n<td>Microsoft YaHei</td>\n<td>\\5FAE\\8F6F\\96C5\\9ED1</td>\n<td>微软雅黑</td>\n</tr>\n<tr>\n<td>Office</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>隶书</td>\n<td>LiSu</td>\n<td>\\96B6\\4E66</td>\n<td>隶书</td>\n</tr>\n<tr>\n<td>幼圆</td>\n<td>YouYuan</td>\n<td>\\5E7C\\5706</td>\n<td>幼圆</td>\n</tr>\n<tr>\n<td>华文细黑</td>\n<td>STXihei</td>\n<td>\\534E\\6587\\7EC6\\9ED1</td>\n<td>华文细黑</td>\n</tr>\n<tr>\n<td>华文楷体</td>\n<td>STKaiti</td>\n<td>\\534E\\6587\\6977\\4F53</td>\n<td>华文楷体</td>\n</tr>\n<tr>\n<td>华文宋体</td>\n<td>STSong</td>\n<td>\\534E\\6587\\5B8B\\4F53</td>\n<td>华文宋体</td>\n</tr>\n<tr>\n<td>华文中宋</td>\n<td>STZhongsong</td>\n<td>\\534E\\6587\\4E2D\\5B8B</td>\n<td>华文中宋</td>\n</tr>\n<tr>\n<td>华文仿宋</td>\n<td>STFangsong</td>\n<td>\\534E\\6587\\4EFF\\5B8B</td>\n<td>华文仿宋</td>\n</tr>\n<tr>\n<td>方正舒体</td>\n<td>FZShuTi</td>\n<td>\\65B9\\6B63\\8212\\4F53</td>\n<td>方正舒体</td>\n</tr>\n<tr>\n<td>方正姚体</td>\n<td>FZYaoti</td>\n<td>\\65B9\\6B63\\59DA\\4F53</td>\n<td>方正姚体</td>\n</tr>\n<tr>\n<td>华文彩云</td>\n<td>STCaiyun</td>\n<td>\\534E\\6587\\5F69\\4E91</td>\n<td>华文彩云</td>\n</tr>\n<tr>\n<td>华文琥珀</td>\n<td>STHupo</td>\n<td>\\534E\\6587\\7425\\73C0</td>\n<td>华文琥珀</td>\n</tr>\n<tr>\n<td>华文隶书</td>\n<td>STLiti</td>\n<td>\\534E\\6587\\96B6\\4E66</td>\n<td>华文隶书</td>\n</tr>\n<tr>\n<td>华文行楷</td>\n<td>STXingkai</td>\n<td>\\534E\\6587\\884C\\6977</td>\n<td>华文行楷</td>\n</tr>\n<tr>\n<td>华文新魏</td>\n<td>STXinwei</td>\n<td>\\534E\\6587\\65B0\\9B4F</td>\n<td>华文新魏</td>\n</tr>\n</tbody></table>\n"},"9f7a":function(n,e){n.exports="<pre><code>    print () {\n      const newWindow = window.open(&#39;打印窗口&#39;, &#39;_blank&#39;)\n      const doStr = document.querySelector(&#39;#preview&#39;).innerHTML\n      newWindow.document.write(doStr)\n      const noprint = newWindow.document.querySelectorAll(&#39;.print&#39;)\n      Array.from(noprint).forEach(item =&gt; {\n        item.style.display = &#39;none&#39;\n      })\n      const cell = newWindow.document.querySelectorAll(&#39;.cell&#39;)\n      Array.from(cell).forEach(item =&gt; {\n        item.style.lineHeight = &#39;40px&#39;\n      })\n      const ar = newWindow.document.querySelectorAll(&#39;tr&#39;)\n      Array.from(ar).forEach(item =&gt; {\n        item.style.border = &#39;1px solid #dfe6ec&#39;\n      })\n      newWindow.document.close()\n      newWindow.print()\n      newWindow.close()\n    }\n</code></pre>"},a194:function(n,e){n.exports='<p>使用$emit</p>\n<p>在父组件中引用子组件</p>\n<pre><code>&lt;child @from-child-msg=&quot;方法名&quot;&gt;&lt;/child&gt;</code></pre><p>在子组件中使用$emit</p>\n<pre><code>this.$emit(&#39;from-child-msg&#39;, 子组件传递的值)</code></pre><p>传进去的值，会变成改方法名的第一个默认参数\neg:</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-04a9f998df107ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="子组件中"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-4063bbf3fc604225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="父组件中"></p>\n<p>getNums是在父组件methods中定义的方法</p>\n'},a2e7:function(n,e){n.exports='<h3 id="-">一、属性类型</h3>\n<ul>\n<li><p>数据属性</p>\n</li>\n<li><p>访问器属性</p>\n</li>\n</ul>\n<h6 id="1-">1、数据属性</h6>\n<table>\n<thead>\n<tr>\n<th align="center">描述行为：</th>\n<th align="center">通过Object.defineProperty()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align="center">Configurable</td>\n<td align="center">可删</td>\n</tr>\n<tr>\n<td align="center">Enumerable</td>\n<td align="center">可遍历</td>\n</tr>\n<tr>\n<td align="center">Writable</td>\n<td align="center">可写</td>\n</tr>\n<tr>\n<td align="center">Value</td>\n<td align="center">值</td>\n</tr>\n</tbody></table>\n<h6 id="2-">2、访问器属性</h6>\n<table>\n<thead>\n<tr>\n<th align="center">描述行为：</th>\n<th align="center">通过Object.defineProperty()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align="center">Configurable</td>\n<td align="center">可删</td>\n</tr>\n<tr>\n<td align="center">Enumerable</td>\n<td align="center">可遍历</td>\n</tr>\n<tr>\n<td align="center">Get</td>\n<td align="center">读 默认值是undefined</td>\n</tr>\n<tr>\n<td align="center">Set</td>\n<td align="center">写 默认值是undefined</td>\n</tr>\n</tbody></table>\n<p>例： 定义单个访问器属性</p>\n<pre><code>        var book = {\n            _year: 2004,\n            edition: 1\n        }\n        Object.defineProperty(book, &#39;year&#39;, {\n            get: () =&gt; {\n                return this._year;\n            },\n            set: () =&gt; {\n                // 操作\n            }\n        })</code></pre><p>定义多个属性</p>\n<pre><code>        var book = {};\n        Object.defineProperties(book, {\n            _year: { // 数据属性\n                configurable: false,\n                enumerable: true,\n                value: 2017\n            },\n            edition: { // 数据属性\n                value: 1\n            },\n            _year: { // 访问器属性\n                get: () =&gt; {\n                    return this._year;\n                },\n                set: () =&gt; {\n                    // 操作\n                }\n            }\n        })</code></pre><h3 id="-">二、创建对象</h3>\n<ol>\n<li>工厂模式</li>\n<li>构造函数</li>\n<li>原型模式</li>\n<li>组合使用构造函数和原型模式</li>\n<li>动态原型模式</li>\n<li>寄生构造函数模式</li>\n<li>稳妥构造函数模式</li>\n<li>单例模式 (只有一个实例对象)</li>\n</ol>\n<h5 id="1-">1.工厂模式</h5>\n<pre><code>        function createPerson (name, age) {\n            var obj = new Object();\n            obj.name = name;\n            obj.age = age;\n            return obj;\n        }\n\n        var person1 = createPerson(&#39;mark&#39;, 29);\n        var person2 = createPerson(&#39;lili&#39;, 25);</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-a8e08a817761f377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工厂模式"></p>\n<blockquote>\n<p>优点： 解决了创建多个相似对象的问题\n    缺点： 未解决对象识别问题(即对象类型)</p>\n</blockquote>\n<h5 id="2-">2.构造函数</h5>\n<pre><code>        function Person (name, age) {\n            this.name = name;\n            this.age = age;\n            this.sayName = () =&gt; {\n                alert(this.name)\n            }\n        }\n        var person2 = new Person(&#39;mark&#39;, 25);</code></pre><ul>\n<li><p>和工厂模式区别：\n未显式地创建对象；\n直接将属性方法赋给this;\n无return；\n大写开头；</p>\n</li>\n<li><p>调用步骤</p>\n</li>\n<li><p>创建一个新对象；</p>\n</li>\n<li><p>将构造函数作用域赋给this;</p>\n</li>\n<li><p>执行构造函数中的代码；</p>\n</li>\n<li><p>返回新对象。</p>\n</li>\n</ul>\n<blockquote>\n<p>新创建的person2存着一个实例，\n有一个constructor（构造器）属性，指向Person.\n用来检测对象类型</p>\n</blockquote>\n<p>检测对象类型</p>\n<pre><code>1&gt;. person2.constructor === Person // true\n2&gt;. person2 instanceof Person // true 常用\n    person2 instanceof Object // true</code></pre><blockquote>\n<p>构造函数优缺点\n优： 将来可以将他的实例标识为一种特殊类型。\n缺： 每个方法都要在实例上重新创建一遍。</p>\n</blockquote>\n<p>解决缺点的一个方法：</p>\n<pre><code>        function Person (name, age) {\n            this.name = name;\n            this.age = age;\n            this.sayName = sayName;\n        }\n        function sayName () { // 把方法写全局\n            alert(this.name)\n        }\n        var person2 = new Person(&#39;mark&#39;, 25);</code></pre><p>引申：call方法</p>\n<pre><code>var o = new Object();\nPerson.call(o, &#39;marry&#39;, 29);\no.sayName() // marry</code></pre><h5 id="3-">3.原型模式</h5>\n<p>通过prototype</p>\n<p>不必在构造函数中定义对象实例的信息，而是直接将这些信息添加到原型对象中</p>\n<pre><code>function Person () {}\nPerson.prototype.name = &#39;mark&#39;;\nPerson.prototype.age = 25;\nPerson.prototype.sayName = function () {\n    alert(this.name)\n};\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.sayName(); // &#39;mark&#39;</code></pre><blockquote>\n<p>与构造函数的区别：新对象的这些属性和方法是由所有实例共享的\nPerson的每个实例person1，person2都包含一个内部属性(<strong>proto</strong>)，该属性仅仅指向了Person.prototype；即与构造函数没有直接关系</p>\n</blockquote>\n<pre><code>person1.__proto__ === Person.prototype // true</code></pre><p>若判断有没有这层关系，可以通过isPrototypeOf()来确定；</p>\n<pre><code>Person.prototype.isPrototypeOf(person1) // true\n\n新增Object.getPrototypeOf()\nObject.getPrototypeOf(person1) === Person.prototype</code></pre><h5 id="4-">4.组合使用构造函数和原型模式</h5>\n<p>常用来定义引用类型</p>\n<pre><code>        function Person (name, age) {\n            this.name = name;\n            this.age = age;\n        }\n        Person.prototype = {\n            constructor: Person,\n            sayName: function () {\n            // 这里不能使用箭头函数，否则this始终指向window对象\n                alert(this.name)\n            }\n        }\n        var person1 = new Person(&#39;mark&#39;, 25);\n        person1.sayName()</code></pre><h5 id="5-">5.动态原型模式</h5>\n<blockquote>\n<p>把所有信息封装在构造函数中，在构造函数中初始化原型</p>\n</blockquote>\n<pre><code>        function Person (name, age) {\n            this.name = name;\n            this.age = age;\n            if (typeof this.sayName != &#39;function&#39;) {\n                Person.prototype.sayName = () =&gt; {\n                    alert(this.name)\n                }\n            }\n        }\n        var person1 = new Person(&#39;mark&#39;, 29);\n        person1.sayName()</code></pre><h5 id="6-">6.单例模式</h5>\n<pre><code>        var singleton = function () {\n            var privateVariable = 10; // 私有变量\n            function pricateFunction () { // 私有函数\n                return false;\n            }\n            return { // 特权 共有\n                publicProperty: true,\n                publicMethod: function () {\n                    privateVariable++;\n                    return pricateFunction();\n                }\n            }\n        }\n</code></pre><h3 id="-">三、继承</h3>\n<ol>\n<li>通过原型链</li>\n</ol>\n<pre><code>        function SuperType () {\n            this.property = true;\n        }\n        SuperType.prototype.getSuperValue = () =&gt; {\n            return this.property;\n        }\n        function SubType () {\n            this.subproperty = false\n        }\n        SubType.prototype = new SuperType();\n        SubType.prototype.getSubValue = function () {\n            return this.subproperty;\n        }\n        var instance = new SubType();\n        instance.getSubValue();\n        instance.getSubValue(); // false</code></pre><blockquote>\n<p>在通过原型链实现继承时，不能使用对象字面量创建原型方法，\n否则会重写原型链</p>\n</blockquote>\n<pre><code>        SubType.prototype = {\n            getSubValue: function () {\n                return this.subproperty;\n            }\n        }</code></pre><blockquote>\n<p>通过原型链实现继承的缺点：</p>\n<ol>\n<li>包含引用类型值的原型（会被所有实例共享）；</li>\n<li>创建子类实例时，无法向超类构造函数传参，\n（即/：不能在不影响所有对象的实例下给超类传参）</li>\n</ol>\n</blockquote>\n<p>为了解决这样的缺点，就出现了借用构造函数</p>\n<p>2.借用构造函数\n（在子类构造函数内部调用超类构造函数）</p>\n<pre><code>        function SuperType () {\n            this.colors = [&#39;red&#39;, &#39;blue&#39;];\n        }\n        function SubType () {\n            SuperType.call(this) // 调用超类型\n        }\n        var instance1 = new SubType();\n        instance1.colors.push(&#39;black&#39;);\n        console.log(instance1.colors);\n        var instance2 = new SubType();\n        console.log(instance2.colors);</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-6ee420438de7a2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="借用构造函数"></p>\n<p>传参：</p>\n<pre><code>        function SuperType (name) {\n            this.name = name;\n        }\n        function SubType () {\n            SuperType.call(this, &#39;mark&#39;);\n            this.age = 29;\n        }\n        var instance = new SubType();\n        instance.name // &#39;mark&#39;\n        instance.age // 29</code></pre><blockquote>\n<p>缺点：无法避免构造函数模式存在的问题， 不能复用。</p>\n</blockquote>\n<p>3.组合继承 （伪经典继承）\n原型链(原型属性和方法) + 构造函数(实例属性)</p>\n<pre><code>        function SuperType (name) {\n            this.name = name;\n            this.colors = [&#39;red&#39;, &#39;blue&#39;];\n        }\n        SuperType.prototype.sayName = function () {\n            alert(this.name)\n        }\n        function SubType (name, age) {\n            SuperType.call(this, name); // (2)\n            this.age = age;\n        }\n        SubType.prototype = new SuperType();  // (1)\n        SubType.prototype.constructor = SubType;\n        SubType.prototype.sayAge = function () {\n            alert(this.age);\n        }\n        var instance1 = new SubType(&#39;mark&#39;, 25);\n        instance1.colors.push(&#39;black&#39;);\n        instance1.colors // &#39;red&#39;, &#39;blue&#39;, &#39;black&#39;\n        var instance2 = new SubType(&#39;marry&#39;, 29);\n        instance2.colors // &#39;red&#39;, &#39;blue&#39;</code></pre><blockquote>\n<p>最常用的继承模式，结合了两者的有点\n缺点：无论什么情况下，都会调用两次超类型构造函数\n一次是创建子类时，即 (1)\n一次是子类内部，即 (2)</p>\n</blockquote>\n<p>4.原型式继承</p>\n<pre><code>        function obj (o) {\n            function F () {};\n            F.prototype = o;\n            return new F();\n        }</code></pre><blockquote>\n<p>先创建一个临时构造函数，并将传入的对象作为这个构造函数的原型。\n使用场景： 在不必要使用构造函数，只想让一个对象与另一个对象保持类似。\n包含引用类型的属性都会共享相应的值</p>\n</blockquote>\n<p>5.寄生式继承  (不能复用)</p>\n<pre><code>        function createAnother (original) {\n            var clone = object(original);\n            clone.sayHi = function () {\n                alert(&#39;hi&#39;)\n            }\n            return clone;\n        }</code></pre><blockquote>\n<p>创建一个仅用于封装继承过程的函数。\n适用于任何能返回新对象的函数</p>\n</blockquote>\n<p>6.寄生组合式继承\n解决组合式继承调用两次超类型的缺陷\n用寄生式继承超类的原型，将结果指定给子类型的原型。</p>\n<pre><code>        function inheritPrototype (subType, superType) {\n            var prototype = Object(subType.prototype); // 创建超类副本\n            prototype.constructor = subType;\n            // 为创建副本加constructor（弥补因重写原型失去了默认的constructor）\n            subType.prototype = prototype;\n            // 将创建的对象赋给子类的原型\n        }\n\n        function SuperType (name) {\n            this.name = name;\n            this.colors = [&#39;red&#39;, &#39;blue&#39;];\n        }\n        SuperType.prototype.sayName = function () {\n            alert(this.name);\n        }\n        function SubType (name, age) {\n            SuperType.call(this.name);\n            this.age = age;\n        }\n        inheritPrototype(SuperType, SubType);\n        SubType.prototype.sayAge = function () {\n            alert(this.age)\n        }</code></pre><h3 id="-">总结</h3>\n<p>工厂模式： 简单的函数创建对象，为对象添加属性和方法，返回对象。\n构造函数：创建自定义引用类型，无法复用。\n原型模式：prototype属性。</p>\n<p>js主要通过原型链实现继承\n(通过一个类型的实例赋值给另一个构造函数的原型) 不适宜单独引用\n解决方法： 借用构造函数\n让每个实例都有自己的属性\n组合继承使用最多。</p>\n<h3 id="-">四。函数表达式</h3>\n<p>argument.callee指向一个正在执行的函数的指针\n递归时不直接使用函数名</p>\n<p>递归</p>\n<pre><code>        function factorial (num) {\n            if (num &lt;= 1) {\n                return 1;\n            } else {\n                return num * arguments.callee(num - 1)\n            }\n        }</code></pre><p>严格模式下不能通过脚本使用。</p>\n<h5 id="-">闭包</h5>\n<p><code>指有权访问另一个函数作用域中变量的函数</code></p>\n<p>缺点： 会定义一个全局变量，只能取得包含函数中任何变量的最后一个值</p>\n'},a395:function(n,e){n.exports='<h3 id="-">向上遍历</h3>\n<pre><code>.parent(); // 返回被选元素的直接父元素。\n\n.parents(&#39;ul&#39;); // 返回被选元素的所有祖先元素\n            // 也可以使用可选参数来过滤对祖先元素的搜索。\n\n.parentsUntil(); // 返回介于两个给定元素之间的所有祖先元素。\n\n</code></pre><h3 id="-">向下遍历</h3>\n<pre><code>.children(); // 返回被选元素的所有直接子元素。\n\n.find(&#39;*&#39;); // 一路向下直到最后一个后代。\n\n\n</code></pre><h3 id="-">同级 水平遍历</h3>\n<pre><code>.siblings(); // 返回被选元素的所有同胞元素。\n\n.next(); // 返回被选元素的下一个同胞元素。\n\n.nextAll(); // 返回介于两个给定参数之间的所有跟随的同胞元素。\n\n.nextUntil();\n\n.prev();\n\n.prevAll();\n\n.prevUntil();\n\n</code></pre><pre><code>\n$(&quot;h2&quot;).siblings(&quot;p&quot;); // 返回属于 &lt;h2&gt; 的同胞元素的所有 &lt;p&gt; 元素：</code></pre><h3 id="-">搜索元素 过滤</h3>\n<pre><code>.first(); 选取元素内部的第一个元素\n\n.last();\n\n.eq(1); // 返回被选元素中带有指定索引号的元素。\n\n.filter(); // 不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。\n\n.not(); // 返回不匹配标准的所有元素。</code></pre>'},a400:function(n,e){n.exports="<pre><code>function getStyle(obj,attr){\n    if(obj.currentStyle){\n        return obj.currentStyle[attr];\n    }\n    else{\n        return getComputedStyle(obj,false)[attr];\n    }\n}</code></pre>"},a41b:function(n,e,t){},a534:function(n,e){n.exports='<h3 id="-">理解</h3>\n<p>函数调用函数\n引出了全局变量和局部变量的概念</p>\n<p>闭包只能获取到函数中变量的最后一个值</p>\n<pre><code>function test () {\n    var arr = []\n    for (var i = 0; i &lt; 10; i++) {\n        arr[i] = function () {\n            return i\n        }\n    }\n    for (var j = 0; j &lt; 10; j++) {\n        console.log(arr[j]())\n    }\n}\ntest() // 10个10\n</code></pre><p>解决方法1： for循环var换成let</p>\n<pre><code>\nvar name = &#39;Windows&#39;\n\nvar obj = {\n    name: &#39;Object&#39;,\n    getName: function () {\n        console.log(this)\n        return function () {\n            console.log(this)\n        }\n    }\n}\n\nobj.getName()() // window\n</code></pre><h2 id="-">匿名函数的执行环境指向创建函数的作用域。</h2>\n'},a597:function(n,e){n.exports='<pre><code>npm i -global ***\n</code></pre><p>在使用安装全局的时候，提示\n<code>Please try running this command again as root/Administrator.</code>\n需要管理员权限</p>\n<ul>\n<li>$ su root</li>\n</ul>\n<p>启动管理员权限，提示输入密码（Password）\n不知道啊，随便输入1，提示：su:Sorry</p>\n<ul>\n<li>sudo passwd root</li>\n</ul>\n<p>重置管理员密码\n<img src="https://github.com/Heisinadaze/notes/blob/master/mac/WechatIMG1.jpeg" alt="输入"></p>\n<p>然后重新<code>npm i -g</code></p>\n'},a78f:function(n,e){n.exports="<blockquote>\n<p>设置表格标题位置caption-side</p>\n</blockquote>\n<pre><code>caption-side:left,top,right,bottom</code></pre><blockquote>\n<p>单元格间距border-spacing，属性值为像素值</p>\n</blockquote>\n<pre><code>border-spacing:5px;</code></pre><blockquote>\n<p>设置单元格边框是否合并border-collapse,属性值默认seperate不合并，collapse合并</p>\n</blockquote>\n<pre><code>border-collapse:collapse;</code></pre><blockquote>\n<p>对空单元格的处理方式empty-cell,默认显示show,hide不显示；</p>\n</blockquote>\n<pre><code>empty-cell:hide;</code></pre><blockquote>\n<p>设置内容和边框的关系 table-layout  属性值auto，fixed（固定大小）</p>\n</blockquote>\n<p>#####注：\n给表格加边框时，在td 上加；\ntr不能使用padding和border;</p>\n"},a7da:function(n,e){n.exports='<pre><code>let array = [1,2,3,3,4,2,4,5];</code></pre><blockquote>\n<p>方法一（通过indexOf，返回该数组下表）</p>\n<pre><code>        Array.prototype.unique = function()\n        {\n            var n = [this[0]]; //结果数组\n            for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历\n            {\n            //     //如果当前数组的第i项在当前数组中第一次出现的位置不是i，\n            //     //那么表示第i项是重复的，忽略掉。否则存入结果数组\n                if (this.indexOf(this[i]) == i) n.push(this[i]);\n                console.log(this.indexOf(this[i]),i);\n            }\n            return n;\n        }\n调用\n    array.unique()</code></pre></blockquote>\n<hr>\n<blockquote>\n<p>方法二(通过sort从小到大排序，然后遍历数组比较相邻元素是否相等)</p>\n<pre><code>    Array.prototype.unique = function()\n        {\n            this.sort();\n            var re=[this[0]];\n            for(var i = 1; i &lt; this.length; i++)\n            {\n                if( this[i] !== re[re.length-1])\n                {\n                    re.push(this[i]);\n                }\n            }\n            return re;\n        }\n        调用\n        array.unique();</code></pre></blockquote>\n<hr>\n<blockquote>\n<p>方法三（通过哈希表）</p>\n<pre><code>        Array.prototype.unique = function()\n        {\n            var n = {},r=[]; //n为hash表，r为临时数组\n            for(var i = 0; i &lt; this.length; i++) //遍历当前数组\n            {\n                console.log(n[this[i]])\n                if (!n[this[i]]) //如果hash表中没有当前项\n                {\n                    n[this[i]] = true; //存入hash表\n                    r.push(this[i]); //把当前数组的当前项push到临时数组里面\n                }\n            }\n            return r;\n        }\n        array.unique()</code></pre></blockquote>\n<p><a href="">散列表</a>（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的<a href="http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="http://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数</a>，存放记录的<a href="http://baike.baidu.com/item/%E6%95%B0%E7%BB%84">数组</a>叫做<a href="http://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a>。</p>\n<hr>\n<blockquote>\n<p>方法四（类似于方法一）\n方法一是假设当前元素的下标是否是重复的\n方法四是判断有没有这个下标，没有返回-1；</p>\n<pre><code>        Array.prototype.unique = function()\n        {\n            var n = []; //一个新的临时数组\n            for(var i = 0; i &lt; this.length; i++) //遍历当前数组\n            {\n                //如果当前数组的第i已经保存进了临时数组，那么跳过，\n                //否则把当前项push到临时数组里面\n                console.log(n.indexOf(this[i]),n);\n                if (n.indexOf(this[i]) == -1) n.push(this[i]);\n            }\n            return n;\n        }\n        array.unique()</code></pre></blockquote>\n<hr>\n'},a82a:function(n,e){n.exports="<p><strong>Vue.nextTick</strong></p>\n<pre><code>Vue.nextTick(_ =&gt; {\n\n})\n下次Dom更新循环结束之后，执行延迟回调。\n在修改数据之后，立即使用这个方法，获取更新后的DOM。\n\nVue.nextTick()\n  .then(_ =&gt; {\n    // 返回一个Promise函数\n  })</code></pre><p><strong>Vue.set</strong></p>\n<pre><code>Vue.set(target, key, value)</code></pre><p><strong>Vue.delete</strong></p>\n<pre><code>Vue.delete(target, key)\n\n删除对象的属性</code></pre><p><strong>Vue.directive</strong></p>\n<pre><code>注册或获取全局指令\n\nVue.directive(id, {Function | Object})</code></pre><p><strong>Vue.filter</strong></p>\n<pre><code>过滤器\nVue.filter(id, Function)\n\nVue.filter(&#39;dataFormat&#39;, value =&gt; {\n  // do that\n})</code></pre><p><strong>Vue.component</strong></p>\n<pre><code>全局组件\nVue.component(id, {Function | Object})</code></pre><p><strong>Vue.use</strong></p>\n<pre><code>安装插件</code></pre><p><strong>Vue.compile</strong></p>\n<pre><code>在render函数中编译模板字符串。\n\nvar res = Vue.compile(&#39;&lt;div&gt;{{ msg }}&lt;/div&gt;&#39;)\n\nnew Vue({\n  data: {\n    msg: &#39;hello&#39;\n  },\n  render: res.render,\n  staticRenderFns: res.staticRenderFns\n})</code></pre>"},aaa1:function(n,e){n.exports='<ol>\n<li><p>找到谷歌浏览器，右键&lt;打开文件所在位置&gt;</p>\n</li>\n<li><p>在文件夹中，复制一下快捷方式到桌面(位置随便)</p>\n</li>\n<li><p>创建一个文件夹，用来存储数据（如： <code>I:\\chromeData</code>）</p>\n</li>\n<li><p>在新复制的谷歌快捷方式，右键&lt;属性&gt; --- 头部菜单&lt;快捷方式&gt; --- 设置&lt;目标&gt;</p>\n</li>\n</ol>\n<p>+= <code>--allow-file-access-from-files --user-data-dir=&quot;I:\\chromeData&quot; --disable-web-security</code></p>\n<ol start="5">\n<li><p>点击确定</p>\n</li>\n<li><p>打开新的快捷方式，第一次进入会提示（您使用的是不受支持的命令行标记，--disable-web-security 什么什么东西会下降设么的）</p>\n</li>\n</ol>\n'},ab6a:function(n,e){n.exports='<h1 id="-"><del>平台架构 学习 （扯淡）</del> 云计算</h1>\n<ol>\n<li><p>架构 概念 （略）</p>\n</li>\n<li><p>云计算概念、技术理念</p>\n</li>\n<li><p>IaaS</p>\n</li>\n<li><p>PaaS</p>\n</li>\n<li><p>技术发展趋势</p>\n</li>\n<li><p>more...</p>\n</li>\n</ol>\n<blockquote>\n<p>云计算可以认为包括以下几个层次的服务：\n基础设施即服务（IaaS），平台即服务（PaaS）和软件即服务（SaaS）。</p>\n</blockquote>\n<ul>\n<li>IaaS：基础设施即服务\nIaaS(Infrastructure-as-a- Service)：基础设施即服务。\n消费者通过Internet可以从完善的计算机基础设施获得服务。例如：硬件服务器租用。</li>\n</ul>\n<ul>\n<li><p>PaaS：平台即服务\nPaaS(Platform-as-a- Service)：平台即服务。\nPaaS实际上是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。\n因此，PaaS也是SaaS模式的一种应用。\n但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。例如：软件的个性化定制开发。</p>\n</li>\n<li><p>SaaS：软件即服务\nSaaS(Software-as-a- Service)：软件即服务。\n它是一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。例如：阳光云服器</p>\n</li>\n</ul>\n<h1 id="-">一、 概念</h1>\n<p><a href="./2%E4%BA%91%E8%AE%A1%E7%AE%97.md">云计算概念</a></p>\n<blockquote>\n<p>一种对IT资源的使用模式，它是对共享的可配置的计算资源提供无所不在的、方便的、随需的网络访问。</p>\n</blockquote>\n<p>计算资源： 如网络、服务器、存储、应用和服务</p>\n<ul>\n<li><p>资源的使用和释放可以快速进行，不需要多少的管理代价。</p>\n</li>\n<li><p>与电力产业的发展过程类似</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>初级阶段</th>\n<th align="left">初步整合</th>\n<th>高度整合</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>电力系统</td>\n<td>自行购买发电机，自行发电。电力系统稳定性差，缺乏标准。</td>\n<td align="left">企业运营覆盖小区域的发电机构，周围用户从企业买电</td>\n<td>大规模的发电厂和电网覆盖全国用户可以方便的用电，用按使用量付费（当前）</td>\n</tr>\n<tr>\n<td>计算系统</td>\n<td>个人拥有计算机完成大部分计算</td>\n<td align="left">企业维护资料中心，使用者访问数据中心，进行计算</td>\n<td>企业或机构运营云计算资料中心，个人和中小企业通过网络访问数据中心进行计算，并按需提供服务</td>\n</tr>\n</tbody></table>\n<ol start="2">\n<li><p>特点</p>\n</li>\n<li><p>虚拟化资源</p>\n</li>\n<li><p>位置独立</p>\n</li>\n<li><p>自动化服务管理</p>\n</li>\n<li><p>快速可扩展性</p>\n</li>\n<li><p>标准化服务</p>\n</li>\n<li><p>自助服务</p>\n</li>\n</ol>\n<h1 id="-">二、 分类</h1>\n<p><strong>按照使用范围分类</strong></p>\n<p><code>公有云</code> ------ <code>私有云</code></p>\n<p><strong>按照服务层次分类</strong></p>\n<ul>\n<li>IaaS: 基础设施即服务</li>\n</ul>\n<blockquote>\n<p>一套物理架构支持多个应用，基于服务器切分，物理层面资源调度，应用不需要改写</p>\n</blockquote>\n<ul>\n<li>PaaS: 平台即服务</li>\n</ul>\n<blockquote>\n<p>一套中间件架构，支持多个应用，基于应用并行化与切分，中间件层面资源调度</p>\n</blockquote>\n<ul>\n<li>SaaS: 软件即服务</li>\n</ul>\n<blockquote>\n<p>一套应用支持多个用户，应用按照特定规范进行开发，满足用户在界面、业务逻辑、数据结构上的差异性需求</p>\n</blockquote>\n<h1 id="-">三、技术和应用</h1>\n'},ad47:function(n,e){n.exports="<p>优化代码的目的：提高运行速度；</p>\n<blockquote>\n<p>js代码优化：</p>\n</blockquote>\n<ul>\n<li>代码重用</li>\n<li>避免全局变量(全局变量，封闭空间，模块化，mvc..)</li>\n<li>拆分函数避免函数过于臃肿</li>\n<li>注释</li>\n<li>减少HTTP请求</li>\n<li>减少DOM操作</li>\n<li>使用json对数据进行操作</li>\n<li>使用语义化标签</li>\n<li>使用CDN加速</li>\n<li>压缩代码</li>\n<li>使用垃圾回收、脏机制查询</li>\n<li>异步加载第三方资源；动态创建script、defer;</li>\n<li>设置本地缓存；</li>\n<li>避免iframe\\img等src属性为空</li>\n<li>点击事件优化；没用就清除；</li>\n<li>注意scroll、resize事件绑定的时机；</li>\n</ul>\n<blockquote>\n<p>HTML</p>\n</blockquote>\n<ul>\n<li>使用压缩后的第三方库，带min的文件；</li>\n<li>js代码在页面最后加载；</li>\n<li>图片使用JPG优于png;png8优于png24；</li>\n<li>使用懒加载；</li>\n</ul>\n<blockquote>\n<p>CSS</p>\n</blockquote>\n<ul>\n<li>使用合并属性：margin/background等；</li>\n<li>移除空的CSS规则；</li>\n<li>去掉0的单位；</li>\n<li>不要声明过多的font-size;</li>\n</ul>\n<blockquote>\n<p>渲染优化</p>\n</blockquote>\n<ul>\n<li>动画优化：使用CSS3动画，使用requestAnimationFrame替代setInterval;</li>\n<li>高频事件优化：touch事件、scroll事件；</li>\n<li>图片优化：优化图片、webp优于jpg\\png8优于gif、对图片使用lazyload；</li>\n<li>使用transition触发、transform触发、opacity；</li>\n<li>js主动释放内存；</li>\n</ul>\n<blockquote>\n<p>meta标签优化</p>\n</blockquote>\n<p>向数组中插入元素</p>\n<pre><code>var arr=[1,2,3,4,5];\narr.push(6);\n换成\narr[arr.length]=6;\n\narr.unshift(0);\n改为\n[0].concat(arr);</code></pre><p>优化嵌套的条件语句</p>\n<pre><code>    if (color) {\n        if (color === &#39;black&#39;) {\n            getBlack();\n        } else if (color === &#39;red&#39;) {\n            getRed();\n        } else if (color === &#39;blue&#39;) {\n            getBlue();\n        } else if (color === &#39;green&#39;) {\n            getGreen();\n        } else {\n            printYellowBackground();\n        }\n    }\n\n优化：\n\n    var colorObj = {\n        &#39;black&#39;: getBlack,\n        &#39;red&#39;: getRed,\n        &#39;blue&#39;: getBlue,\n        &#39;green&#39;: getGreen,\n        &#39;yellow&#39;: getYellow\n    };\n    if (color in colorObj) {\n        colorObj[color]();\n    }\n\n</code></pre><pre><code>undefined==null;//true;\nundefined===null;//fallse;</code></pre><p>undefined与null的区别</p>\n<ul>\n<li>undefined表示一个变量没有被声明，或者被声明了但没有被赋值；</li>\n<li>null是一个表示“没有值”的值,但是他是一个值；</li>\n<li>Javascript将未赋值的变量默认值设为undefined；</li>\n<li>undefined不是一个有效的JSON，而null是；</li>\n<li>undefined的类型(typeof)是undefined；</li>\n<li>null的类型(typeof)是object；</li>\n<li>他们是基本类型；</li>\n</ul>\n<p>检查某对象是否有某属性：</p>\n<pre><code> var obj={\n     name:&#39;hello&#39;\n }\n if(obj.name){\n     console.log(&#39;obj has name&#39;);\n }\n\n转换\n\n var obj={\n     name:&#39;world&#39;\n }\nobj.hasOwnProperty(&quot;name&quot;)//true\n&quot;name&quot; in obj//true\n\nobj.hasOwnProperty(&#39;valueOf&#39;)//false;继承自原型链(__proto__属性)\n&quot;valueOf&quot; in obj//true\n</code></pre><p>区分与检查属性的深度不同，换言之hasOwnProperty只在本身有此属性时返回true,而in操作符不区分属性来自于本身或继承自原型链。</p>\n<p>快速测量js代码性能，使用console的timeEnd方法</p>\n<pre><code>    console.time(&quot;Array initialize&quot;);\n   var arr = new Array(100),\n       len = arr.length,\n       i;\n\n   for (i = 0; i &lt; len; i++) {\n       arr[i] = new Object();\n   };\n   console.timeEnd(&quot;Array initialize&quot;);</code></pre>"},ae1b:function(n,e){n.exports='<p>1 官网注册</p>\n<p>2 跳转链接\n<a href="https://dashboard.ngrok.com/get-started">https://dashboard.ngrok.com/get-started</a></p>\n<p>3\nngrok authtoken <my token></p>\n<p>ngrok start -config ngrok.yml jsan</p>\n<ol start="4">\n<li><p>访问（会很慢）</p>\n</li>\n<li><p>查看记录\n<a href="http://localhost:4040/inspect/http">http://localhost:4040/inspect/http</a></p>\n</li>\n</ol>\n'},ae55:function(n,e){n.exports="<p>caller 返回一个函数的引用，这个函数调用了当前函数；</p>\n<blockquote>\n<p>这个函数只有执行时才有用\n如果在js中是由顶层调用的，返回null；</p>\n</blockquote>\n<pre><code>    let a = function () {\n        alert(a.caller);\n    }\n    a(); // null\n    let b = function () {\n        a();\n    }\n\n    b(); // function () {alert(a.caller);}</code></pre><p>callee 返回正在执行的函数本身的引用</p>\n<blockquote>\n<p>只有在函数执行的时候才有效\n有length属性，可以用来获取形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length\n用来递归匿名函数</p>\n</blockquote>\n<pre><code>    let a = function (a, b, c) {\n        console.log(arguments.callee.length); // 3\n        console.log(arguments.length); // 2\n    }\n    a(1, 2);</code></pre>"},b16d:function(n,e){n.exports='<p>行内样式有设置变量的情况下</p>\n<pre><code> &lt;section class=&quot;index-header-container&quot; :style=&quot;{background: swoperColor}&quot;&gt;&lt;/section&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-0f54330359819445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},b1c3:function(n,e){n.exports='<p>function jsonp(url,parameter,callback){\n    // 生成一个script\n    var script=document.createElement(&#39;script&#39;);\n    // 生成一个随机字符串作为回调函数名\n    var randomKey=&quot;cbf&quot;+new Date().getTime();\n    // 将callback以生成的随机串为属性名添加到window对象上，这样，在页面的任意位置都能以window<a href="">randomkey</a>形式访问回调函数\n    window[randomKey]=callback;\n    url+=&quot;?callback=&quot;+randomKey;</p>\n<pre><code>// 拼接参数\nif(parameter){\n    for(var p in parameter){\n        url+=(&quot;&amp;&quot;+p+&quot;=&quot;+parameter[p]);\n    }\n}\n\n// 设置script节点的src属性\nscript.src=url;\n// 拼接到dom结构中\ndocument.body.appendChild(script);\n\n// 操作完成后移除script标签\nscript.onload = function () {\n    document.body.removeChild(script);\n};</code></pre><p>}</p>\n'},b2e1:function(n,e){n.exports="<pre><code>proxy_connect_timeout 1; \nproxy_send_timeout 30; \nproxy_read_timeout 60;\n</code></pre>"},b3bf:function(n,e){n.exports='<p>基本语法： </p>\n<pre><code>  class Point {\n    constructor (x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    toString () {\n      return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n    }\n\n    toValue() {\n      // ...\n    }\n  }</code></pre><p>用ES5语法可以替代为</p>\n<pre><code>function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n};\n\nvar p = new Point(1, 2);</code></pre><blockquote>\n<p>在类的实例上面调用方法，其实就是调用原型上的方法。\n```\nclass B {}\nlet b = new B();</p>\n</blockquote>\n<p>b.constructor === B.prototype.constructor // true</p>\n<pre><code>\n\n###### 类的属性名，可以采用表达式。</code></pre><p>let methodName = &#39;getArea&#39;;</p>\n<p>class Square {\n  constructor(length) {\n    // ...\n  }</p>\n<p>  <a href="">methodName</a> {\n    // ...\n  }\n}</p>\n<pre><code>\n##### 类和模块的内部，默认就是严格模式\n\n\n### constructor 方法\n\n`constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。`\n</code></pre><p>class Point {\n}</p>\n<p>// 等同于\nclass Point {\n  constructor() {}\n}</p>\n<pre><code>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\n</code></pre><p>class Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}</p>\n<p>new Foo() instanceof Foo  // false</p>\n<pre><code>###### 类必须要用`new`调用\n\n&gt; 使用`Object.getPrototypeOf`而不用`__proto__`的原因：\n`__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\n#### 类的表达式\n</code></pre><pre><code>const MyClass = class Me {\n  getClassName () {\n    console.log(Me.name);\n  }\n}\n\nlet inst = new MyClass();\ninst.getClassName(); // Me\n\nconsole.log(Me)</code></pre><pre><code>这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。在函数外面使用则报错。\n\n如果内部没有用到的话，可以省略Me:</code></pre><p>const MyClass = class { /* ... */ };</p>\n<pre><code>\n* 一个立即执行的class：</code></pre><pre><code>let person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}(&#39;张三&#39;);\n\nperson.sayName(); // &quot;张三&quot;</code></pre><pre><code>\n##### 不可以变量提升\n\n##### Class内部的getter，和setter函数\n</code></pre><p>class MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return &#39;getter&#39;;\n  }\n  set prop(value) {\n    console.log(&#39;setter: &#39;+value);\n  }\n}</p>\n<p>let inst = new MyClass();</p>\n<p>inst.prop = 123;\n// setter: 123</p>\n<p>inst.prop\n// &#39;getter&#39;</p>\n<pre><code>\n##### Class 的静态方法\n\n`类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。`\n</code></pre><pre><code>  class Foo {\n    static classMethod () {\n      return &#39;hello&#39;;\n    }\n  }\n\n  Foo.classMethod(); // &#39;hello&#39;</code></pre><pre><code>如果静态方法包含this关键字，这个this指的是类，而不是实例。\n</code></pre><pre><code>  class Foo {\n    static bar () {\n      this.baz();\n    }\n\n    static baz () {\n      console.log(&#39;hello&#39;);\n    }\n\n    baz () {\n      console.log(&#39;word&#39;);\n    }\n  }\n\n  Foo.bar(); // &#39;hello&#39;</code></pre><pre><code>\n父类的静态方法，可以被子类继承。\n静态方法也是可以从super对象上调用的。\n</code></pre><pre><code>class Foo {\n  static classMethod () {\n    return &#39;hello&#39;;\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod () {\n    console.log(super.classMethod() + &#39;, too&#39;);\n  }\n}\n\nBar.classMethod();</code></pre><pre><code>\n# 继承 `extends`\n\n</code></pre><pre><code>  class Point {\n  }\n\n  class ColorPoint extends Point {\n    constructor (x, y, name) {\n      super(x, y); // 调用父类的constructor(x, y)\n      this.name = name;\n    }\n\n    toString () {\n      return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n    }\n  }</code></pre><pre><code>`super`关键字，表示父类的构造函数，用来新建父类的this对象。\n\n如果子类显示写出constructor方法，则子类必须调用super()方法，否则子类因为没有自己的this对象儿报错。如果子类没有定义constructor方法，这个方法被默认添加。\n\nES5继承的实质： 先创建子类的实例对象this，然后将父类的方法添加到this上面。\n\nES6继承： 先创建父类的实例（super），然后调用子类的构造函数修改this。\n\n父类的静态方法也会被子类继承\n\n##### super 关键字\n\n既可以当作函数使用，也可以当作对象使用。\n\n* `super `作为函数调用时\n代表父类的构造函数。</code></pre><pre><code>  class Point {\n  }\n\n  class P extends Point {\n    constructor () {\n      super()  // `super`代表父类的构造函数，返回子类的实例\n    }\n  }\n\n  let cp = new P();</code></pre><pre><code>\n</code></pre><pre><code>  class A {\n    constructor() {\n      console.log(new.target.name); // 指向当前正在执行的函数\n    }\n  }\n\n  class B extends A {\n    constructor() {\n      super();\n    }\n  }\n\n  new A() // A\n  new B() // B</code></pre><p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>\n<pre><code>\n* `super `作为对象时\n在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n</code></pre><pre><code>  class A {\n    p() {\n      return 2;\n    }\n  }\n\n  class B extends A {\n    constructor() {\n      super();\n      console.log(super.p()); // 2 相当于A.prototype.p()\n    }\n  }\n\n  let b = new B();</code></pre><pre><code></code></pre><pre><code>  class A {\n    constructor() {\n      this.p = 2;\n    }\n  }\n\n  class B extends A {\n    get m() {\n      return super.p;\n    }\n  }\n\n  let b = new B();\n  b.m // undefined</code></pre><p>由于super指向父类的原型对象，\n所以定义在父类实例上的方法或属性，\n是无法通过super调用的</p>\n<pre><code></code></pre><pre><code>  class A {\n    constructor() {\n      this.x = 1;\n      console.log(this.x)\n    }\n  }\n  A.prototype.x = 4\n\n  class B extends A {\n    constructor() {\n      super();\n      this.x = 2;\n      super.x = 3; \n      console.log(super.x); // 4\n      console.log(this.x); // 3\n    }\n  }\n\n  let b = new B();</code></pre><p>赋值时返回的子类对象，取值时还是父类的原型对象。</p>\n<pre><code>&gt; 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n</code></pre><pre><code>  class Parent {\n    static myMethod(msg) {\n      console.log(&#39;static&#39;, msg);\n    }\n\n    myMethod(msg) {\n      console.log(&#39;instance&#39;, msg);\n    }\n  }\n\n  class Child extends Parent {\n    static myMethod(msg) {\n      super.myMethod(msg);\n    }\n\n    myMethod(msg) {\n      super.myMethod(msg);\n    }\n  }\n\n  Child.myMethod(1); // static 1\n\n  var child = new Child();\n  child.myMethod(2); // instance 2</code></pre><pre><code>\n使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。\n\n类的 prototype 属性和`__proto__`属性\n</code></pre><p>class A {\n}</p>\n<p>class B extends A {\n}</p>\n<p>B.<strong>proto</strong> === A // true\nB.prototype.<strong>proto</strong> === A.prototype // true</p>\n<pre><code>\n\n\n### Mixin 模式\n多个对象合成一个新的对象\n</code></pre><pre><code>  function mix(...mixins) {\n    class Mix {}\n\n    for (let mixin of mixins) {\n      copyProperties(Mix, mixin); // 拷贝实例属性\n      copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n    }\n\n    return Mix;\n  }\n\n  function copyProperties(target, source) {\n    for (let key of Reflect.ownKeys(source)) {\n      if ( key !== &quot;constructor&quot;\n        &amp;&amp; key !== &quot;prototype&quot;\n        &amp;&amp; key !== &quot;name&quot;\n      ) {\n        let desc = Object.getOwnPropertyDescriptor(source, key);\n        Object.defineProperty(target, key, desc);\n      }\n    }\n  }</code></pre><pre><code>\n\n使用</code></pre><p>class DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n```</p>\n'},ba93:function(n,e){n.exports="<ul>\n<li>iphone边框问题</li>\n</ul>\n<pre><code>\ninput {\n    outline: none;\n    -webkit-appearance: none; \n    -webkit-appearance: none;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n</code></pre><ul>\n<li>number\n```</li>\n</ul>\n<p>input 为number 在火狐浏览器下的bug\ninput::-webkit-outer-spin-button,\ninput::-webkit-inner-spin-button {\n    -webkit-appearance: none !important;\n    margin: 0; \n}</p>\n<p>input[type=&quot;number&quot;]{ -moz-appearance:textfield; }</p>\n<pre><code>* scroll\n</code></pre><p>// 滚动条样式\n::-webkit-scrollbar-track-piece {\n    background-color: #f5f5f5;\n    border-left: 1px solid #d2d2d2;\n}</p>\n<p>::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n    background: #fff;\n}</p>\n<p>::-webkit-scrollbar-button {\n  height: 0;\n  width: 0;\n  display: none;\n}</p>\n<p>::-webkit-scrollbar-thumb {\n    padding-top: 100px;\n    background-color: #dadada;\n    background-clip: padding-box;\n    min-height: 28px;\n    border-radius: 4px;\n}</p>\n<p>::-webkit-scrollbar-thumb:hover {\n    background-color: #929292;\n}</p>\n<p>```</p>\n"},bb40:function(n,e){n.exports='<p>使用谷歌<code>google-analytics</code></p>\n<p>在vue中，有</p>\n<pre><code>npm i vue-analytics</code></pre><p>在<a href="https://analytics.google.com/analytics/web/#/report-home/a123176893w181413199p179312965">官网</a>使用gmail邮箱注册一个账号。</p>\n<p>main.js</p>\n<pre><code>import VueAnalytics from &#39;vue-analytics&#39;\nimport router from &#39;./router&#39;\n\nVue.use(VueAnalytics, {\n  id: &#39;UA-**********&#39;, // 注册时给的id.\n  router // 跟踪路由\n  // debug: {\n  //   enabled: true // 本地调试的时候可以打开，提交正式环境前，注释掉\n  // }\n})</code></pre><p>跟踪按钮事件</p>\n<pre><code>在事件中加一个调用\n\n      this.$ga.event({\n        eventCategory: &#39;btn&#39;,\n        eventAction: &#39;index&#39;,\n        eventLabel: this.$route.path,\n        eventValue: r\n      })\n      // 或\n      this.$ga.event(&#39;randomClicks&#39;, &#39;click&#39;, &#39;name&#39;, name)</code></pre><p>24小时后可在官网上查看分析结果。</p>\n<p><a href="https://matteogabriele.gitbooks.io/vue-analytics/content/docs/v-ga.html">查看更多文档</a>\n<a href="https://github.com/MatteoGabriele/vue-analytics">git地址</a></p>\n'},bce5:function(n,e){n.exports='<h2 id="-">把一段内容，里面的回车替换成换行在页面正常显示出来</h2>\n<pre><code>content:&quot;1.阿斯顿发科技↵2.时候↵3.沙发垫hi↵4.第三方hi&quot;;\n\ncontent.replace(/(\\r\\n)|(\\n)/g, &#39;&lt;br&gt;&#39;);</code></pre>'},bd1d:function(n,e){n.exports='<h3 id="mongodb-">Mongodb固定集合</h3>\n<p>给集合设置上限</p>\n<ul>\n<li>创建固定集合\n```</li>\n</ul>\n<p>db.createCollection(&quot;cappedLogCollection&quot;,{capped:true,size:10000,max:1000})</p>\n<p>size 是整个集合空间大小，单位为【KB】\nmax 是集合文档个数上线，单位是【个】</p>\n<pre><code>\n* 判断集合是否为固定集合\n</code></pre><p>db.cappedLogCollection.idCapped()</p>\n<pre><code>\n* 将已知集合转换为固定集合</code></pre><p>db.runCommand({&quot;convertTooCapped&quot;:&quot;col&quot;,size:10000})\n```</p>\n'},c0be:function(n,e){n.exports='<h1 id="em-rem-">em和rem笔记</h1>\n<h2 id="-">简单介绍</h2>\n<h3 id="-">单位</h3>\n<blockquote>\n<p>在编写网页过程中，需要对元素（标签）进行宽高、\n颜色、字体等的设置，这些需要使用单位。\n在CSS中，设置字体和宽高使用的单位可以一致，例如\n：<code>px</code>/<code>rem</code>/<code>em</code>/</p>\n</blockquote>\n<h3 id="rem-">rem来源</h3>\n<blockquote>\n<p>rem是CSS3中的单位</p>\n</blockquote>\n<h3 id="-px-">和px关系</h3>\n<p><code>px</code>是使用最多的单位，\nem和rem可以和px 单位进行换算，就如<code>克和千克</code>之间可以换算一样。\n具体换算规则，如下。</p>\n<h3 id="-">建议</h3>\n<blockquote>\n<p>在做移动端项目的时候，建议使用rem作为单位\n可以方便快捷、容易的实现响应式效果</p>\n</blockquote>\n<h2 id="em-">em详细说明</h2>\n<blockquote>\n<p>em参照父级元素大小\n如果父元素<code>font-size:20px</code>,给子元素设置字体<code>font-size:1em;</code>,\n子元素就是<code>20px</code>的大小</p>\n</blockquote>\n<p><strong>示例：</strong></p>\n<ul>\n<li>设置1e=20px</li>\n<li>2em=40px;</li>\n<li>2.5em=50px;</li>\n<li>0.5em=10px;</li>\n</ul>\n<blockquote>\n<p><code>em</code>合适的使用场景是:text-indent(首行缩进）/\nline0height(行高)</p>\n</blockquote>\n<h2 id="rem-">rem详细说明</h2>\n<blockquote>\n<p>rem参照的是html标签字体大小</p>\n</blockquote>\n<p>rem 和 em 不同点就是em参考各自的父元素，如果父元素没有设置字体大小，则继续向上查找(父父元素)，直至最后\n<code>rem</code>直接参照html标签字体大小，并且是所有使用rem单位都是参照html标签\n所以只需要更改html标签字体大小，就可以影响全部使用<code>rem</code>单位的标签</p>\n<p><strong>代码示例</strong></p>\n<pre><code class="language-CSS">html{\nfont-size:100px;\n}\n.title{\n    width:5rem;/*500px*/\n    height:5rem;/*500px*/\n    font-zize:.3rem;/*30px*/</code></pre>\n<blockquote>\n<p>在做响应式网址时，可以根据媒体查询去调节<code>html</code>标签的字体大小，实现共同调节其他标签大小的效果\n使用媒体查询调节<code>html</code>字体大小，效果不够精细（大小是分段改变的），可以使用JavaScript动态计算<code>html的font-size</code></p>\n</blockquote>\n<h2 id="-">使用注意点</h2>\n<p>在rem的使用过程中，要刻意注意<code>字体最小12px</code>的问题\n设置html的font-size属性时，<code>最好不要小于12px</code>\n如果设置了<code>10px</code>,使用<code>1rem</code>的时候，<code>其实就是12px,因为最小12px</code></p>\n'},c194:function(n,e){n.exports='<h3 id="vuex-">VUEX 状态管理仓库</h3>\n<p>应用于大型的单页应用</p>\n<blockquote>\n<p>类似于全局变量，和全局变量的区别: \n1.vuex是动态的；\n2 不能直接赋值和取值；\n附：不能用全局变量的原因------因为每个单文件组件都是一个VUE实例，不能跨域访问</p>\n</blockquote>\n<p>四个部分： <code>state</code>, <code>action</code>, <code>mutation</code>,<code>getter</code></p>\n<blockquote>\n<p>过程：\n1通过组件触发action方法，（this.$store.dispath触发，或init）\naction默认第一个参数是context\n通过context.commit()可以触发mutation\n2 mutation默认接受的第一个参数是state\n可以直接访问state里面的变量如state.user\n3 然后通过getter获取参数\n这四个部分都属于自己的辅助函数\n辅助函数更加方便精简</p>\n</blockquote>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-97aa86b2857d8082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小香香"></p>\n<h3 id="-">组件传值的方法</h3>\n<ul>\n<li>props 父组件给子组件传值</li>\n<li>$emit 子组件给父组件传值</li>\n<li>router 路由传参</li>\n<li>vuex 传值</li>\n<li>$ref 父组件给子组件传值</li>\n<li>离线缓存</li>\n</ul>\n<h3 id="-">箭头函数和普通函数的区别</h3>\n<ul>\n<li><p>更简洁， 没有this</p>\n</li>\n<li><p>箭头函数不可以使用类似于arguments对象（super(ES6)，new.target(ES6)……），该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。（async）</p>\n</li>\n<li><p>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n</ul>\n<p>绑定this方法：</p>\n<pre><code>function make () {\n  var self = this;\n  return function () {\n    console.log(self);\n  }\n}\n\n方法二\nfunction make () {\n  return function () {\n    console.log(this);\n  }.bind(this);\n}</code></pre><h3 id="-">垃圾回收机制</h3>\n<p>标记清除（常用）   和    引用计数</p>\n<p>标记清除：垃圾收集器在运行时给存储在内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中变量引用的变量的标记。在此之后，再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存收集工作。销毁那些带标记的值，并回收他们所占用的内存。</p>\n<p>引用计数：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值引用次数减1.当这个值得引用次数变为0时，说明没办法再访问这个值了，就将其占用的内存空间回收回来。当垃圾收集器再次运行时，释放那些引用次数为零的值所占用的内存。</p>\n<h3 id="set-">set对象</h3>\n<p>类似于数组，但是成员的值都是唯一的，没有重复的值。\n Set的遍历顺序就是插入顺序。</p>\n<p>一个最简单的应用：数组去重</p>\n<pre><code>    let arr1 = [1, 3, 2, 4, 5, 3, 1, 4, 2];\n    const result = [...new Set(arr1)];\n    console.log(result); // [1, 3, 2, 4, 5]</code></pre><h3 id="map-">Map对象</h3>\n<p>Object只能用字符串当作键。\nMap各种类型的值（包括对象）都可以当作键</p>\n<pre><code>    const m = new Map();\n    const o = {p: &#39;Hello World&#39;};\n    m.set(o, &#39;content&#39;);\n    m.get(o); // content\n    m.has(o) // true\n    m.delete(o)\n    m.has(o) // false\n    const map = new Map([\n         [&#39;name&#39;, &#39;张三&#39;],\n         [&#39;title&#39;, &#39;Author&#39;]\n    ]);\n\n     map.size // 2\n     map.has(&#39;name&#39;) // true\n     map.get(&#39;name&#39;); // &quot;张三&quot;\n     map.has(&#39;title&#39;) // true\n     map.get(&#39;title&#39;) // &quot;Author&quot;</code></pre><blockquote>\n<p> 如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n</blockquote>\n<h3 id="-">循环的缺点</h3>\n<ul>\n<li><p>forEach循环无法中途跳出，break和return 都不能奏效。但for-of可以</p>\n</li>\n<li><p>for--in缺点：主要用于便利对象</p>\n</li>\n<li><p>数组键名是Number，但for--in是以字符串作为键名；</p>\n</li>\n<li><p>for--in不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</p>\n</li>\n<li><p>有时for--in会以任意顺序遍历。</p>\n</li>\n</ul>\n<h3 id="vue-">vue响应式原理</h3>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-bd143f62c920604a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<p>1通过 Observer 对 data 做监听，并且提供了订阅某个数据项变化的能力。</p>\n<p>2template 编译，解析其中的 Directive，得到每一个 Directive 所依赖的数据项和update方法。</p>\n<p>3通过Watcher把上述两部分结合起来，即把Directive中的数据依赖通过Watcher订阅在对应数据的 Observer 的 Dep 上。当数据变化时，就会触发 Observer 的 Dep 上的 notify 方法通知对应的 Watcher 的 update，进而触发 Directive 的 update 方法来更新 DOM 视图，最后达到模型和视图关联起来。</p>\n'},c1ec:function(n,e){n.exports='<h3 id="-name-nuxt-js-">新建一个项目名为name的nuxt.js项目</h3>\n<p><strong>一.基础</strong></p>\n<ol>\n<li><p>安装全局脚手架\n<code>npm i -g vue-cli</code></p>\n</li>\n<li><p>安装官方给出的模板\n<code>vue init nuxt-community/starter-template name</code></p>\n</li>\n<li><p>进入该项目\n<code>cd name</code></p>\n</li>\n<li><p>安装包文件\n<code>npm i</code></p>\n</li>\n<li><p>开发环境跑项目\n<code>npm run dev</code></p>\n</li>\n</ol>\n<p><strong>二.常用配置</strong></p>\n<ol>\n<li>修改端口<code>package.js</code>文件下</li>\n</ol>\n<pre><code>&quot;config&quot;: {\n  &quot;nuxt&quot;: {\n    &quot;host&quot;: &quot;0.0.0.0&quot;,\n    &quot;port&quot;: &quot;443&quot;\n  }\n},\n&quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;nuxt&quot;,\n    ...\n},</code></pre>'},c428:function(n,e){n.exports="<p>去掉删除按钮</p>\n<pre><code>input::-ms-clear{display:none;}</code></pre>"},c739:function(n,e){n.exports="<p>ru: 自定义一个<code>qqq.io</code></p>\n<p><code>/config/index.js</code></p>\n<pre><code>host: &#39;qqq.io&#39;</code></pre><p><code>webpck.dev.conf.js</code></p>\n<pre><code>  devServer: {\n    clientLogLevel: &#39;warning&#39;,\n    historyApiFallback: true,\n    hot: true,\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    },\n    disableHostCheck: true // 添加这一行\n  },</code></pre><p><code>hosts</code>文件</p>\n<pre><code>127.0.0.1 qqq.io</code></pre>"},c740:function(n,e){n.exports='<h2 id="mongodb-">Mongodb 概念</h2>\n<p>文档型数据库</p>\n<table>\n<thead>\n<tr>\n<th>SQL术语/概念</th>\n<th>MongoDB术语/概念</th>\n<th>解释/说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>database</td>\n<td>database</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>table</td>\n<td>collection</td>\n<td>数据库表/集合</td>\n</tr>\n<tr>\n<td>row</td>\n<td>document</td>\n<td>数据记录行/文档</td>\n</tr>\n<tr>\n<td>column</td>\n<td>field</td>\n<td>数据字段/域</td>\n</tr>\n<tr>\n<td>index</td>\n<td>index</td>\n<td>索引</td>\n</tr>\n<tr>\n<td>table joins</td>\n<td></td>\n<td>表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td>primary key</td>\n<td>primary key</td>\n<td>主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody></table>\n<h3 id="-">数据库</h3>\n<blockquote>\n<p>一个mongodb中可以建立多个数据库。</p>\n</blockquote>\n<blockquote>\n<p>MongoDB的默认数据库为&quot;db&quot;，该数据库存储在data目录中。</p>\n</blockquote>\n<blockquote>\n<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中</p>\n</blockquote>\n<blockquote>\n<p>Mongodb的命令行  &quot;show dbs&quot; 命令可以显示所有数据的列表。</p>\n</blockquote>\n<blockquote>\n<p>执行 &quot;db&quot; 命令可以显示当前数据库对象或集合。</p>\n</blockquote>\n<blockquote>\n<p>运行&quot;use&quot;命令，可以连接到一个指定的数据库。</p>\n</blockquote>\n<h3 id="-">数据库命名</h3>\n<ul>\n<li>不能是空字符串</li>\n<li>不含特殊字符， 0， $, / ...</li>\n<li>全部小写</li>\n<li>最多64字节</li>\n<li>utf-8字符串</li>\n</ul>\n<h4 id="-">保留 数据库(可以直接访问)</h4>\n<ul>\n<li><p>admin: root</p>\n</li>\n<li><p>local: 用来存储限于本地单台服务器的任意集合</p>\n</li>\n<li><p>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</p>\n</li>\n</ul>\n<h2 id="-">文档</h2>\n<table>\n<thead>\n<tr>\n<th>RDBMS</th>\n<th>MongoDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库</td>\n<td>数据库</td>\n</tr>\n<tr>\n<td>表格</td>\n<td>集合</td>\n</tr>\n<tr>\n<td>行</td>\n<td>文档</td>\n</tr>\n<tr>\n<td>列</td>\n<td>字段</td>\n</tr>\n<tr>\n<td>表联合</td>\n<td>嵌入文档</td>\n</tr>\n<tr>\n<td>主键</td>\n<td>主键 (MongoDB 提供了 key 为 _id )</td>\n</tr>\n</tbody></table>\n<p>  数据库服务和客户端\n  | 数据库服务和客户端 | 数据库服务和客户端 |\n  | --- | --- |\n|Mysqld/Oracle|    mongod|\n|mysql/sqlplus|    mongo|</p>\n<blockquote>\n<p>文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>\n</blockquote>\n<pre><code>{&quot;site&quot;:&quot;www.baidu.com&quot;, &quot;name&quot;:&quot;百度&quot;}</code></pre><ul>\n<li><p>文档中的键/值对是有序的。</p>\n</li>\n<li><p>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</p>\n</li>\n<li><p>MongoDB区分类型和大小写。</p>\n</li>\n<li><p>MongoDB的文档不能有重复的键。</p>\n</li>\n<li><p>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</p>\n</li>\n</ul>\n<h4 id="-">文档键命名规范：</h4>\n<ul>\n<li><p>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</p>\n</li>\n<li><p><code>.</code>和<code>$</code>有特别的意义，只有在特定环境下才能使用。</p>\n</li>\n<li><p>以下划线<code>_</code>开头的键是保留的(不是严格要求的)。</p>\n</li>\n</ul>\n<h2 id="-">数据类型</h2>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>\n</tr>\n<tr>\n<td>Integer</td>\n<td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔值。用于存储布尔值（真/假）。</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>双精度浮点值。用于存储浮点值。</td>\n</tr>\n<tr>\n<td>Min/Max keys</td>\n<td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>\n</tr>\n<tr>\n<td>Array</td>\n<td>用于将数组或列表或多个值存储为一个键。</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>时间戳。记录文档修改或添加的具体时间。</td>\n</tr>\n<tr>\n<td>Object</td>\n<td>用于内嵌文档。</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>用于创建空值。</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>\n</tr>\n<tr>\n<td>Object ID</td>\n<td>对象 ID。用于创建文档的 ID。</td>\n</tr>\n<tr>\n<td>Binary Data</td>\n<td>二进制数据。用于存储二进制数据。</td>\n</tr>\n<tr>\n<td>Code</td>\n<td>代码类型。用于在文档中存储 JavaScript 代码。</td>\n</tr>\n<tr>\n<td>Regular expression</td>\n<td>正则表达式类型。用于存储正则表达式。</td>\n</tr>\n</tbody></table>\n<h2 id="mongodb-">Mongodb连接</h2>\n<pre><code>Mongodb://admin:123456@localhost/test\n\ntest: 数据库名\n\n没有的部分可以省略</code></pre><p>连接到本地默认的数据库</p>\n<pre><code>Mongodb://localhost</code></pre><p>连接两个服务器的时候</p>\n<pre><code>mongodb://example1:27017,example2.com:27017</code></pre><p>连接三台服务器</p>\n<pre><code>mongodb://localhost,localhost:27018,localhost:27019</code></pre><p>连接三台服务器, 写入操作应用在主服务器 并且分布查询到从服务器。</p>\n<pre><code>mongodb://host1,host2,host3/?slaveOK=true</code></pre><p>安全模式连接到localhost</p>\n<pre><code>mongodb://localhost/safe=true</code></pre><p>以安全模式连接到replica set，并且等待至少两个复制服务器成功写入，超时时间设置为2秒。</p>\n<pre><code>mongodb://host1,host2,host3/?safe=true;w=2;wtimeoutMS=2000</code></pre>'},c7b0:function(n,e){n.exports='<h3 id="prop-">prop验证</h3>\n<pre><code>props: {\n  propA: Number,\n  propB: [String, Number],\n  propC: {\n    type: String,\n    require: true\n  },\n  propD: {\n    type: Number,\n    default: 100\n  },\n  propE: { // 自定义验证函数\n    validator (value) {\n      return value &gt; 10\n    }\n  }\n}\n</code></pre><blockquote>\n<p>type: String, Number, Boolean, Function, Object, Array, Symbol\ntype也可以是自定义构造器函数，使用<code>instanceof</code></p>\n</blockquote>\n'},cd49:function(n,e,t){"use strict";t.r(e);t("cadf"),t("551c"),t("097d");var o=t("2b0e"),r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{directives:[{name:"loading",rawName:"v-loading.fullscreen.lock",value:n.fullscreenLoading,expression:"fullscreenLoading",modifiers:{fullscreen:!0,lock:!0}}],attrs:{id:"app","element-loading-spinner":"el-icon-loading","element-loading-text":"加载中"}},[n.fullscreenLoading?n._e():t("router-view",{staticClass:"app-main"})],1)},p=[],l=(t("7f7f"),t("7514"),t("28a5"),t("ac6a"),t("456d"),t("ac4d"),t("8a81"),t("53ca")),i=(t("fd24"),t("65d9")),a=t.n(i),d=(t("a481"),t("1a37")),c={};d.keys().forEach(function(n){c[n.replace(/(\.\/|\.md)/g,"")]=d(n)});var s=c,u=function(){var n=function(e,t){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])},n(e,t)};return function(e,t){function o(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}}(),g=function(n,e,t,o){var r,p=arguments.length,i=p<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,t):o;if("object"===("undefined"===typeof Reflect?"undefined":Object(l["a"])(Reflect))&&"function"===typeof Reflect.decorate)i=Reflect.decorate(n,e,t,o);else for(var a=n.length-1;a>=0;a--)(r=n[a])&&(i=(p<3?r(i):p>3?r(e,t,i):r(e,t))||i);return p>3&&i&&Object.defineProperty(e,t,i),i},m=function(n,e,t,o){return new(t||(t=Promise))(function(r,p){function l(n){try{a(o.next(n))}catch(e){p(e)}}function i(n){try{a(o["throw"](n))}catch(e){p(e)}}function a(n){n.done?r(n.value):new t(function(e){e(n.value)}).then(l,i)}a((o=o.apply(n,e||[])).next())})},h=function(n,e){var t,o,r,p,l={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return p={next:i(0),throw:i(1),return:i(2)},"function"===typeof Symbol&&(p[Symbol.iterator]=function(){return this}),p;function i(n){return function(e){return a([n,e])}}function a(p){if(t)throw new TypeError("Generator is already executing.");while(l)try{if(t=1,o&&(r=2&p[0]?o["return"]:p[0]?o["throw"]||((r=o["return"])&&r.call(o),0):o.next)&&!(r=r.call(o,p[1])).done)return r;switch(o=0,r&&(p=[2&p[0],r.value]),p[0]){case 0:case 1:r=p;break;case 4:return l.label++,{value:p[1],done:!1};case 5:l.label++,o=p[1],p=[0];continue;case 7:p=l.ops.pop(),l.trys.pop();continue;default:if(r=l.trys,!(r=r.length>0&&r[r.length-1])&&(6===p[0]||2===p[0])){l=0;continue}if(3===p[0]&&(!r||p[1]>r[0]&&p[1]<r[3])){l.label=p[1];break}if(6===p[0]&&l.label<r[1]){l.label=r[1],r=p;break}if(r&&l.label<r[2]){l.label=r[2],l.ops.push(p);break}r[2]&&l.ops.pop(),l.trys.pop();continue}p=e.call(n,l)}catch(i){p=[6,i],o=0}finally{t=r=0}if(5&p[0])throw p[1];return{value:p[0]?p[1]:void 0,done:!0}}},f=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e.file=s,e.fullscreenLoading=!0,e}return u(e,n),e.prototype.setList=function(n){var e=this,t=Object.keys(n),o=t.map(function(n){return n.split("/")}),r=[];return o.forEach(function(n,o){r.find(function(e){return e.name===n[0]})||r.push({name:n[0],children:e.child(t,n[0],o)})}),r},e.prototype.child=function(n,e,t){var o=n.filter(function(n){return n.indexOf(e+"/")>-1});return o=o.map(function(n){return{name:n.split(e+"/")[1],parent:e}}),o},e.prototype.mounted=function(){return m(this,void 0,void 0,function(){var n;return h(this,function(e){return this.fullscreenLoading=!1,this.$store.commit("LIST",this.file),this.$store.commit("TREELIST",this.setList(this.file)),n=document.querySelector("link[rel*='icon']")||document.createElement("link"),n.type="image/x-icon",n.rel="shortcut icon",n.href="http://cdn.jsan.top/favicon.ico",document.getElementsByTagName("head")[0].appendChild(n),[2]})})},e=g([a.a],e),e}(o["default"]),b=f,q=b,y=(t("453c"),t("2877")),v=Object(y["a"])(q,r,p,!1,null,null,null);v.options.__file="App.vue";var k=v.exports,w=t("8c4f"),x=t("323e"),j=t.n(x);t("a5d8");o["default"].use(w["a"]);var S=function(){return t.e("chunk-bbc910ea").then(t.bind(null,"0462"))},$=function(){return t.e("chunk-9385f998").then(t.bind(null,"eea6"))},E=function(){return t.e("chunk-26fcfe48").then(t.bind(null,"9261"))},M=function(){return t.e("chunk-b73103de").then(t.bind(null,"e4be"))},_=function(){return t.e("chunk-2b7c2472").then(t.bind(null,"c6a8"))},C=function(){return t.e("chunk-4b1b6550").then(t.bind(null,"ee5d"))},O=[{path:"/",name:"welcome",component:S},{path:"/home",name:"home",component:$,redirect:"/index",children:[{path:"/index",name:"首页",component:E},{path:"/artlist",name:"列表",component:M},{path:"/article",name:"详情",component:_}]},{path:"*",component:C}],A=new w["a"]({mode:"hash",routes:O});A.beforeEach(function(n,e,t){j.a.start(),t()}),A.afterEach(function(n){j.a.done()});var D=A,P=t("2f62");o["default"].use(P["a"]);var T={list:{},treeList:[]},V={},B={LIST:function(n,e){n.list=e},TREELIST:function(n,e){n.treeList=e}},N=new P["a"].Store({state:T,actions:V,mutations:B}),I=t("5c96"),R=t.n(I);function F(){o["default"].use(R.a)}var L=t("0284"),z=t.n(L);t("a41b");function H(n){document.body.clientWidth&&document.body.clientWidth<754?I["Message"].success(n):I["Notification"].success({title:"成功",duration:2e3,message:n})}function U(n){document.body.clientWidth&&document.body.clientWidth<754?I["Message"].warning(n):I["Notification"].warning({title:"提示",duration:2e3,message:n})}o["default"].prototype.$success=H,o["default"].prototype.$notice=U,o["default"].config.productionTip=!1,F(),o["default"].use(z.a,{id:"UA-131011679-1",router:D}),new o["default"]({router:D,store:N,render:function(n){return n(k)}}).$mount("#app")},ce62:function(n,e){n.exports='<blockquote>\n<p>概念:找出那些不再继续使用的变量，然后释放其占用的内存。他会按照固定的时间间隔，或代码执行中预定的收集时间，周期性的执行这一操作。</p>\n</blockquote>\n<h4 id="-">标记清除</h4>\n<ul>\n<li>最常用的\n<code>当变量进入环境（例如在函数中声明一个变量）时，就将这个变量标记为进入环境。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，可以使用任何方式来标记变量</code>\n垃圾收集器在运行时给存储在内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中变量引用的变量的标记。在此之后，再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存收集工作。销毁那些带标记的值，并回收他们所占用的内存。</li>\n</ul>\n<h4 id="-">引用计数</h4>\n<p><code>跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值引用次数减1.当这个值得引用次数变为0时，说明没办法再访问这个值了，就将其占用的内存空间回收回来。当垃圾收集器再次运行时，释放那些引用次数为零的值所占用的内存。</code></p>\n<p>限制：循环引用 =&gt; 指对象A中包含一个指向对象B的指针，而对象B中也包含了一个指向对象A的引用。</p>\n<pre><code>function problem () {\n    var objA = new Object();\n    var objB = new Object();\n    objA.otherObj = objB;\n    objB.anotherObj = objA;\n}</code></pre><p>上面例子中，两个对象的引用次数都是2,。若是标记清除，由于函数执行后，两个对象都离开了作用域，因此这样合理。但在计数策略实现中，他们的引用次数永远不会是0.加入这个函数被多次调用，会导致大量内存得不到回收。</p>\n<p>解决：在不适用他们时，手动断开引用。\n = null;赋值为null.</p>\n<p>在IE中</p>\n<pre><code>window.CollectGarbage();</code></pre><p>会立即执行立即回收机制。</p>\n<p>opera中，</p>\n<pre><code>window.opera.collect();</code></pre>'},d00b:function(n,e){n.exports='<p><a href="https://www.iviewui.com/">官网</a></p>\n'},d263:function(n,e){n.exports='<h3 id="-">冒泡排序</h3>\n<blockquote>\n<p>一种排序算法</p>\n</blockquote>\n<p>一次比较两个元素（大的右边，小的左边）。一个把大的元素慢慢浮出到数组边缘，即冒泡排序。</p>\n<p>第一轮先把最大的放到右边\n然后比较把第二大的数字放到右边第二个\n依次到最后</p>\n<pre><code>    function sort (arr) {\n        for (let i = 0; i &lt; arr.length - 1; i++) {\n            for (let j = 0; j &lt; arr.length - i - 1; j++) {\n                if (arr[j] &gt; arr[j + 1]) {\n                    [ arr[j], arr[j + 1] ] = [ arr[j + 1], arr[j] ]\n                }\n            }\n        }\n    }\n\n    let arr = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8];\n    console.log(&#39;before&#39; + arr);\n    sort(arr);\n    console.log(&#39;after &#39; + arr);</code></pre><h3 id="-">快速排序</h3>\n<p>从数组中间分来，一边的数字全部小于右边，递归下来。</p>\n<pre><code>\nfunction quickSort (a) {\n  // a表示传进来的数组\n  if (a.length &lt;= 1) return a\n\n  let mid = ~~(a.length / 2)\n  let midItem = a.splice(mid, 1)[0]\n  let left = []\n  let right = []\n\n  a.forEach(item =&gt; {\n    if (item &lt;= midItem) left.push(item)\n    else right.push(item)\n  })\n\n  let _left = quickSort(left)\n  let _right = quickSort(right)\n\n  return _left.concat(midItem, _right)\n}\n</code></pre><p><strong>如果出现较多重复元素</strong></p>\n<pre><code>    function quickSort (a) {\n      if (a.length &lt;= 1) return a\n\n      let last = a.pop()\n      let left = []\n      let right = []\n      let mid = [last]\n\n      a.forEach(item =&gt; {\n        if (item &lt; last) {\n          left.push(item)\n        } else if (item &gt; last) {\n          right.push(item)\n        } else {\n          mid.push(item)\n        }\n      })\n\n      let _left = quickSort(left)\n      let _right = quickSort(right)\n\n      return _left.concat(mid, _right)\n    }\n\n</code></pre><pre><code>function quickSort (a) {\n      return a.length &lt;= 1 ? a\n                          : quickSort(a.slice(1).filter(item =&gt; item &lt;= a[0]))\n                                      .concat(a[0],\n                                              quickSort(a.slice(1).filter(item =&gt; item &gt; a[0])))\n    }</code></pre>'},d288:function(n,e){n.exports='<h2 id="-">这里是大部分图片</h2>\n'},d2f1:function(n,e){n.exports='<ul>\n<li><p>border-radius // 圆角 （最多八个值，前四个和后四个中间用“/”线分隔）</p>\n</li>\n<li><p>box-shadow // 盒阴影 (inset 20px 20px 30px blue)</p>\n</li>\n<li><p>text-shadow // 字阴影 （当需要添加多个阴影的时候，中间用&#39;,&#39;分隔，box-shadow一样）</p>\n</li>\n<li><p>background-size // 设置背景图片大小（contain / cover）</p>\n</li>\n<li><p>background-origin // 设置背景图原点 (border-box / padding-box / content-box)</p>\n</li>\n<li><p>background-clip // 设置背景图的裁剪</p>\n</li>\n<li><p>线性渐变\nbackground: linear-gradient() // 线性渐变 (to right, red, blue) (45deg, red, blue)</p>\n</li>\n</ul>\n<pre><code>        div{\n            width: 200px;\n            height: 200px;\n            background: linear-gradient(45deg,red 30%,lightskyblue,blue);\n        }\n\n    &lt;div&gt;&lt;/div&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-e5621b2f2229fa2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性渐变"></p>\n<blockquote>\n<p>百分比写不写都行</p>\n</blockquote>\n<ul>\n<li><p>径向渐变\nbackground: radial-gradient() // 径向渐变 (at 100px 100px, red, blue)</p>\n<pre><code>      div{\n          width: 200px;\n          height: 200px;\n          background: radial-gradient(at  50px 50px,red 10%,blue,gold)\n      }\n\n  &lt;div&gt;&lt;/div&gt;</code></pre></li>\n</ul>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-7954f24c37681418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="径向渐变 他在发呆"></p>\n'},d418:function(n,e){n.exports="<p>object的每个实例都有下列属性和方法</p>\n<pre><code>var obj = new Object();</code></pre><ul>\n<li><p>constructor 保存着用于创建当前对象的函数。对于前面的例子而言，就是Object（）；</p>\n</li>\n<li><p>hasOwnProperty： 用于检查给定的属性在当前对象的实例中（不是实例的原型中）是否存在。作为参数的属性名必须以字符串的形式指定。</p>\n<pre><code>obj.hasOwnProperty(&quot;name&quot;)</code></pre></li>\n<li><p>isPrototype(): 用于检测传入的对象是否是传入对象的原型</p>\n</li>\n<li><p>propertyIsEnumerable(): 用于检测给定的属性是否能够使用for-in语句来枚举。用法同hasOwnProperty；</p>\n</li>\n<li><p>toLocaleString(): 返回对象的字符串表示，该字符串与指定环境的地区对应。</p>\n</li>\n<li><p>toString(): 返回对象的字符串表示</p>\n</li>\n<li><p>valueOf(): 返回对象的字符串、数值、布尔表示</p>\n</li>\n</ul>\n"},d42c:function(n,e){n.exports="<pre><code>const _ = {}\n\n// Similar to ES6&#39;s rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n// This accumulates the arguments passed into an array, after a given index.\nvar restArgs = function (func, startIndex) {\n  startIndex = startIndex == null ? func.length - 1 : +startIndex\n  return function () {\n    var length = Math.max(arguments.length - startIndex, 0)\n    var rest = Array(length)\n    var index = 0\n    for (; index &lt; length; index++) {\n      rest[index] = arguments[index + startIndex]\n    }\n    switch (startIndex) {\n      case 0: return func.call(this, rest)\n      case 1: return func.call(this, arguments[0], rest)\n      case 2: return func.call(this, arguments[0], arguments[1], rest)\n    }\n    var args = Array(startIndex + 1)\n    for (index = 0; index &lt; startIndex; index++) {\n      args[index] = arguments[index]\n    }\n    args[startIndex] = rest\n    return func.apply(this, args)\n  }\n}\n\n// A (possibly faster) way to get the current timestamp as an integer.\n_.now = Date.now || function () {\n  return new Date().getTime()\n}\n\n// Delays a function for the given number of milliseconds, and then calls\n// it with the arguments supplied.\n_.delay = restArgs(function (func, wait, args) {\n  return setTimeout(function () {\n    return func.apply(null, args)\n  }, wait)\n})\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n_.debounce = function (func, wait, immediate) {\n  var timeout, result\n\n  var later = function (context, args) {\n    timeout = null\n    if (args) result = func.apply(context, args)\n  }\n\n  var debounced = restArgs(function (args) {\n    if (timeout) clearTimeout(timeout)\n    if (immediate) {\n      var callNow = !timeout\n      timeout = setTimeout(later, wait)\n      if (callNow) result = func.apply(this, args)\n    } else {\n      timeout = _.delay(later, wait, this, args)\n    }\n\n    return result\n  })\n\n  debounced.cancel = function () {\n    clearTimeout(timeout)\n    timeout = null\n  }\n\n  return debounced\n}\n\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you&#39;d like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\n_.throttle = function (func, wait, options) {\n  var timeout, context, args, result\n  var previous = 0\n  if (!options) options = {}\n\n  var later = function () {\n    previous = options.leading === false ? 0 : _.now()\n    timeout = null\n    result = func.apply(context, args)\n    if (!timeout) context = args = null\n  }\n\n  var throttled = function () {\n    var now = _.now()\n    if (!previous &amp;&amp; options.leading === false) previous = now\n    var remaining = wait - (now - previous)\n    context = this\n    args = arguments\n    if (remaining &lt;= 0 || remaining &gt; wait) {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      previous = now\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    } else if (!timeout &amp;&amp; options.trailing !== false) {\n      timeout = setTimeout(later, remaining)\n    }\n    return result\n  }\n\n  throttled.cancel = function () {\n    clearTimeout(timeout)\n    previous = 0\n    timeout = context = args = null\n  }\n\n  return throttled\n}\n\nmodule.exports = _\n</code></pre>"},d476:function(n,e){n.exports='<p>类似于<code>window.onload</code></p>\n<pre><code>$(document).ready(function() {\n\n\n});\n</code></pre><p>解决<code>\\$</code>符号冲突的方法</p>\n<pre><code>var _ = jQuery.noConflict();\n</code></pre><h3 id="-">事件函数</h3>\n<pre><code>$(document).ready(function)\n\n$(selector).click(function)\n\n$(selector).dblclick(function)\n\n$(selector).focus(function)\n\n$(selector).mouseover(function)\n</code></pre>'},d651:function(n,e){n.exports='<h1 id="-">条件操作符</h1>\n<pre><code>$gt -------- greater than  &gt;\n\n$gte --------- gt equal  &gt;=\n\n$lt -------- less than  &lt;\n\n$lte --------- lt equal  &lt;=\n\n$ne ----------- not equal  !=\n\n$eq  --------  equal  =</code></pre><p>eg:</p>\n<pre><code>db.col.find({\n  likes: {$lt: 200, $gt: 100}\n})</code></pre><h3 id="-type">$type</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>数字</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Double</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>Object</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>Array</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>Binary data</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>6</td>\n<td>已废弃。</td>\n</tr>\n<tr>\n<td>Object id</td>\n<td>7</td>\n<td></td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>8</td>\n<td></td>\n</tr>\n<tr>\n<td>Date</td>\n<td>9</td>\n<td></td>\n</tr>\n<tr>\n<td>Null</td>\n<td>10</td>\n<td></td>\n</tr>\n<tr>\n<td>Regular Expression</td>\n<td>11</td>\n<td></td>\n</tr>\n<tr>\n<td>JavaScript</td>\n<td>13</td>\n<td></td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>14</td>\n<td></td>\n</tr>\n<tr>\n<td>JavaScript (with scope)</td>\n<td>15</td>\n<td></td>\n</tr>\n<tr>\n<td>32-bit integer</td>\n<td>16</td>\n<td></td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>17</td>\n<td></td>\n</tr>\n<tr>\n<td>64-bit integer</td>\n<td>18</td>\n<td></td>\n</tr>\n<tr>\n<td>Min key</td>\n<td>255</td>\n<td>Query with -1.</td>\n</tr>\n<tr>\n<td>Max key</td>\n<td>127</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>eg:</p>\n<pre><code>db.col.find({&quot;title&quot;: {$type: 2}})\n\ntitle为String的数据</code></pre>'},d6e7:function(n,e){n.exports='<p><strong>多选列表</strong></p>\n<ul>\n<li><input checked="" disabled="" type="checkbox"> 项目一<ul>\n<li><input checked="" disabled="" type="checkbox"> 项目1.1</li>\n<li><input checked="" disabled="" type="checkbox"> 项目1.2</li>\n</ul>\n</li>\n<li><input disabled="" type="checkbox"> 项目二</li>\n</ul>\n<hr>\n<h3 id="-">流程图</h3>\n<pre><code>graph TD\n    A[firstLine] --&gt; B(TwoLine)\n    B --&gt; C{judge?}\n    C --&gt; D[demo1]\n    C --&gt; |two| E[demo2]\n    C --&gt; |three| F[demo3]\n\n\n\n\n</code></pre><hr>\n<h3 id="-">序列图</h3>\n<pre><code>sequenceDiagram\n    loop every day\n        A-&gt;&gt;B: Hello John, how are you?\n        B--&gt;&gt;A: Great!\n    end\n</code></pre><hr>\n<h3 id="-">表格</h3>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>age</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>jake</td>\n<td>022</td>\n<td>12345</td>\n</tr>\n<tr>\n<td>lucy</td>\n<td>032</td>\n<td>45678</td>\n</tr>\n</tbody></table>\n<hr>\n'},d7a9:function(n,e){n.exports='<p><code>js</code>  <code>以太坊</code> </p>\n<p>操作以太坊的js</p>\n<blockquote>\n<p>推荐使用<code>google chrome</code>，安装扩展程序<code>main metaMask</code>(一个网页钱包)\n<img src="https://upload-images.jianshu.io/upload_images/2941543-ce6f35d96e211a76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狐狸">\n前期测试可以使用测试环境\n<img src="https://upload-images.jianshu.io/upload_images/2941543-d973f16696de6ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狐狸"></p>\n</blockquote>\n<h4 id="-js">一、 安装包 / 引入js</h4>\n<pre><code>// node\nnpm i web3\n\n// yarn\nyarn add web3\n\n// cdn\n&lt;script src=&quot;https://cdn.jsdelivr.net/gh/ethereum/web3.js/dist/web3.min.js&quot;&gt;&lt;/script&gt;</code></pre><h4 id="-vue-">二、 使用（vue）</h4>\n<ol>\n<li>引入<code>web3</code>对象</li>\n</ol>\n<pre><code>import Web3 from &#39;web3&#39;\n\n// new一个实例对象，并设置服务器\n// var web3 = new Web3(&#39;http://localhost:8545&#39;);\n// 或\nvar web3 = new Web3(Web3.givenProvider || &#39;ws://remotenode.com:8546&#39;);</code></pre><ol start="2">\n<li>设置自己的默认账户，即有些方法的<code>from</code>参数</li>\n</ol>\n<pre><code>web3.eth.defaultAccount = &#39;0x0d97b58930abdc14ac8c2aa80ab8e82928c6def1&#39;;\n\n// 在以下方法中如果没有指定from属性， 将使用该属性的值作为默认的from\n// web3.eth.sendTransaction()\n// web3.eth.call()\n// new web3.eth.Contract() -&gt; myContract.methods.myMethod().call()\n// new web3.eth.Contract() -&gt; myContract.methods.myMethod().send()</code></pre><ol start="3">\n<li>向以太坊提交一个交易</li>\n</ol>\n<pre><code>    var code = &quot;603d80600c6000396000f3007c01000000000000000000000000000000000000000000000000000000006000350463c6888fa18114602d57005b6007600435028060005260206000f3&quot;;\n    var from = &#39;0x0d97b58930abdc14ac8c2aa80ab8e82928c6def1&#39;\n    var to = &#39;0x81b7e08f65bdf5648606c89998a9cc8164397647&#39;\n    web3.eth.sendTransaction({data: code, from, to}, function(err, address) {\n      if (err) {\n        console.log(err)\n        return\n      }\n      console.log(address);\n    });</code></pre><blockquote>\n<p>from: 交易发送方的账户地址\nto: 目标地址\nvalue: 交易值\ndata 可以是包含合约方法数据的ABI字符串，或者是合约创建交易中的初始化代码\ncallback: 第一个参数为错误信息，第二个参数为结果\n返回值：返回一个32字节的交易哈希值\n成功调用，会弹出<code>metamask</code>弹框，如果账户没有余额，会出现充值页面\n<img src="https://upload-images.jianshu.io/upload_images/2941543-ce94eca3aa04dfc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狐狸">\n正常会出现的页面为\n<img src="https://upload-images.jianshu.io/upload_images/2941543-86e19b059cfc3c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小狐狸"></p>\n</blockquote>\n<p><a href="http://cw.hubwiz.com/card/c/web3.js-1.0/1/2/19/">中文文档地址 - 推荐</a></p>\n<p><a href="http://web3.tryblockchain.org/">api - 不完整</a></p>\n<p><a href="https://github.com/ethereum/web3.js/tree/master">git地址</a></p>\n<p><a href="https://ropsten.etherscan.io/tx/">网页查询交易信息</a>\n<code>https://ropsten.etherscan.io/tx/</code></p>\n<p>测试环境数据（0x7bcc6bf0efe54b3aa4d87a025625c1f5e2ef67771e316844d2c6e4b8eacd6920）</p>\n<p>正式环境数据(0x54b51a36760ea922e0d4e9f96c0db1d70d1758bcefa9dbcac5101aaed544b86d)</p>\n'},d81a:function(n,e){n.exports='<ul>\n<li><p>所有的引用类型都有一个<code>__proto__</code>属性</p>\n</li>\n<li><p>所有函数都拥有<code>prototype</code>属性</p>\n</li>\n</ul>\n<h1 id="-">从构造函数开始</h1>\n<pre><code>\nfunction Word (words) {\n  this.words = words\n}\n\nWord.prototype = {\n  alert () {\n    console.log(this.words) // hello world\n  }\n}\n\nvar w = new Word(&#39;hello world&#39;);\nw.print = function () {\n  console.log(this.words) // hello world\n  console.log(this) // { words: &#39;hello world&#39;, print: [Function] }\n}\n\nw.print()\nw.alert()\n</code></pre><pre><code>w.__proto__ === Word.prototype</code></pre>'},d8d5:function(n,e){n.exports='<h3 id="new-date-">new Date()</h3>\n<p>返回调用这个方法的时间</p>\n<pre><code>    if (!Date.now) {\n        Date.now = function now() {\n             return new Date().getTime();\n        }\n    }</code></pre><p>在不兼容的浏览器中</p>\n<pre><code>let start = +new Date()</code></pre><h3 id="-">转换</h3>\n<p>Date.parse(new Date()) // 返回毫秒数</p>\n<ul>\n<li><p>getTime()  返回时间的毫秒数</p>\n</li>\n<li><p>setTime(毫秒数) 通过毫秒设置时间</p>\n</li>\n</ul>\n<p>*setFullYear(2017) 设置年份，必须是4位数</p>\n<ul>\n<li><p>setMonth(月份) 设置月    超过的话，年+1</p>\n</li>\n<li><p>getDate 天数（1-31） </p>\n</li>\n<li><p>setDate()超过的话，月+1</p>\n</li>\n<li><p>setDay() 星期（0表示星期日）</p>\n</li>\n<li><p>setMilliseconds () 设置日期中的毫秒数</p>\n</li>\n<li><p>getTimezoneOffset() 返回本地时间与UTC时间相差分钟数。</p>\n</li>\n</ul>\n'},da6d:function(n,e){n.exports='<h2 id="-">全文索引</h2>\n<p>创建</p>\n<pre><code>db.col.ensureIndex({name:&quot;text&quot;})</code></pre><p>使用索引搜索关键字</p>\n<pre><code>db.col.find({$text:{$search:&quot;Tom&quot;}})</code></pre><p>删除全文索引</p>\n<pre><code>db.col.getIndexes() // 先获取索引名\n\ndb.col.dropIndex(&quot;name_text&quot;)\n</code></pre><h3 id="-">使用正则表达式通过关键字查找</h3>\n<pre><code>db.col.find({name:{$regex:&quot;Thorin&quot;}})\n\n等同于\n\ndb.col.find({name:/Thorin/})</code></pre><ul>\n<li>不区分大小写的正则表达式： 设置<code>$options:&quot;$i&quot;</code></li>\n</ul>\n<pre><code>db.col.find({name:{$regex:&quot;Thorin&quot;,$options:&quot;$i&quot;}})\ndb.col.find({name:/Thorin/i})</code></pre><h6 id="-">数组元素也可以使用正则</h6>\n<pre><code>db.col.find({tags:{$regex:&quot;Th&quot;}}) // 包含th的， 也可以`^Th`表示开头</code></pre><p>如果正则中使用变量，用<code>eval</code></p>\n<pre><code>var name = eval(&quot;/&quot; + 变量值key + &quot;/i&quot;);\n\neg:\ndb.col.find({title:eval(&quot;/&quot; + title + &quot;/i&quot;)})\n\ndb.col.find({title:{$regex:title,$option:&quot;$i&quot;}})</code></pre><ul>\n<li><p>i 忽略大小写</p>\n</li>\n<li><p>m 多行匹配</p>\n</li>\n<li><p>x 忽略非转义的空白字符</p>\n</li>\n<li><p>s 单行匹配模式</p>\n</li>\n</ul>\n'},de4f:function(n,e){n.exports='<h1 id="what-s-happened-">What`s happened ?</h1>\n'},e096:function(n,e){n.exports="<blockquote>\n<p>column:3;表示均分三列</p>\n</blockquote>\n<pre><code>column-width     设置列宽（建议使用em为单位）,不加单位表示均分几列，加单位表示一列有多少字  \n\ncolumn //设置列数\n\ncolumns: 5em 5; // 复合属性（优先选择较少列数的进行使用）\n\ncolumn-gap // 列缝隙之间的宽度\n\ncolumn-rule // 设置缝隙中的线的样式\n\n* column-rule-style\n* column-rule-color\n* column-rule-width\n\ncolumn-span // 跨列（FF模式不支持）\n\n\n\n    -moz-column\n    -webkit-column\n    -ms-column\n    -o-column\n    column</code></pre><p>```</p>\n"},e2c2:function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-aaa2a1c5292dfd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n<pre><code>    beforeUpload (file) {\n      return new Promise((resolve, reject) =&gt; {\n        let arr = file.name.split(&#39;.&#39;)\n        //  || arr[arr.length - 1] === &#39;xlsx&#39;\n        if (arr[arr.length - 1] === &#39;xls&#39;) {\n          resolve()\n        } else {\n          notice(this, &#39;请上传正确格式文件&#39;, 2000)\n          reject()\n        }\n      })\n    }\n</code></pre>'},e36f:function(n,e){n.exports='<h3 id="dbrefs">DBRefs</h3>\n<blockquote>\n<p>当一个文档从多个集合引用文档。</p>\n</blockquote>\n<pre><code>{$ref: , $id: , $db: }\n\n$ref: 集合名称\n\n$id: 引用的id\n\n$db: 可选，数据库名</code></pre><p>eg:</p>\n<pre><code>在用户数据中使用DBRef,字段address\n\n{\n  &quot;_id&quot;: ObjectId(&quot;nnnnnnnnnnnnnn&quot;),\n  &quot;address&quot;: {\n    &quot;$ref&quot;: &quot;address_home&quot;,\n    &quot;$id&quot;: ObjectId(&quot;mmmmmmmm&quot;),\n    &quot;$db&quot;: &quot;test&quot;\n  },\n  &quot;contact&quot;: &quot;987654321&quot;,\n  &quot;name&quot;: &quot;Tom Thorin&quot;\n}\n\n\nvar user = db.user.findOne({&quot;name&quot;:&quot;Tom Thorin&quot;})\nvar dbRef = user.address\ndb[dbRef.$ref].findOne({&quot;_id&quot;:(dbRef.$id)})\n\n就可以返回address_home集合中的地址数据。</code></pre>'},e4a8:function(n,e){n.exports='<h3 id="-">隐藏和显示</h3>\n<pre><code>.hide(speed,callback); // 隐藏\n\n.show(speed,callback); // 显示\n\n.toggle(speed,callback); // 切换显示或隐藏的状态\n\nspeed: 隐藏或显示的速度（&#39;slow&#39;, &#39;fast&#39;, 或毫秒数）\n\ncallback: 隐藏或显示之后执行的函数名称\n\n</code></pre><h3 id="-">淡入淡出</h3>\n<pre><code>.fadeIn(speed,callback);\n\n.fadeOut(speed,callback);\n\n.fadeToggle(speed,callback);\n\n.fadeTo(speed,opacity,callback); // 允许渐变为给定的不透明度（值介于 0 与 1 之间）。\n</code></pre><h3 id="-">滑动</h3>\n<pre><code>.slideDown(speed,callback);\n\n.slideUp(speed,callback);\n\n.slideToggle(speed,callback);\n\n</code></pre><h3 id="-">创建自定义动画</h3>\n<pre><code>.animate({params}, speed, callback);\n\n注：对元素移动位置时，需要先给元素设置position;\n    使用驼峰命名法： paddingLeft...\n\n\n使用相对值&#39;+=, -=&#39;\n$(&#39;div&#39;).animate({\n    left: &#39;250px&#39;,\n    paddingLeft: &#39;10px&#39;,\n    height: &#39;+=150px&#39;\n})\n\n使用预定义的值show,hide,toggle\n\n$(&#39;div&#39;).animate({\n    height: &#39;toggle&#39;\n})\n\n队列功能\n  var div=$(&quot;div&quot;);\n  div.animate({height:&#39;300px&#39;,opacity:&#39;0.4&#39;},&quot;slow&quot;);\n  div.animate({width:&#39;300px&#39;,opacity:&#39;0.8&#39;},&quot;slow&quot;);\n  div.animate({height:&#39;100px&#39;,opacity:&#39;0.4&#39;},&quot;slow&quot;);\n  div.animate({width:&#39;100px&#39;,opacity:&#39;0.8&#39;},&quot;slow&quot;);</code></pre><h3 id="-">停止动画</h3>\n<pre><code>.stop(stopAll,goToEnd); // 用于停止动画或效果，在它们完成之前\n\n适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。\n\n可选的 stopAll 参数规定是否应该清除动画队列。\n默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。\n\n可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。\n</code></pre>'},e632:function(n,e){n.exports='<h3 id="-">打包</h3>\n<p><code>npm run build</code></p>\n<p><strong>Appache配置</strong></p>\n<p>本机模拟服务器软件<code>WMP Server</code></p>\n<p><code>httpd.conf</code>文件下</p>\n<pre><code>1. \nLoadModule rewrite_module modules/mod_rewrite.so\n\n这一行取消注释\n\n2.\n\n&lt;Directory /&gt;\n  Options FollowSymLinks\n  AllowOverride none (=&gt; all 两个这种地方，都改成all)\n  Order deny.all\n  Deny from all\n&lt;/Directory&gt;</code></pre><ol start="3">\n<li><code>/www/.htaccess</code>文件<pre><code>&lt;IfModule mod_rewrite.c&gt;\nRewriteEngine On\nRewriteBase /\nRewriteRule ^index\\.html&amp; [L]\nRewriteCond %{REQUEST_FiLENAME} !-f\nRewriteCond %{REQUEST_FiLENAME} !-d\nRewriteRule . index.html [L]\n&lt;/IfModule&gt;</code></pre></li>\n</ol>\n'},e69f:function(n,e){n.exports='<h3 id="1-this-">1. this指向</h3>\n<p>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n<pre><code>        function make () {\n            return () =&gt; {\n                console.log(this)\n            }\n        }\n        make()() // window\n        const testFunc = make.call({ name: &#39;foo&#39; });\n        testFunc(); // { name: &#39;foo&#39; }\n        testFunc.call({ name: &#39;bar&#39; }); // { name: &#39;foo&#39; }\n        testFunc(); // { name: &#39;foo&#39; }\n        const testFunc2 = make.call({ name: &#39;too&#39; });\n        testFunc2() // { name: &#39;too&#39; }</code></pre><p>如果要绑定this对象</p>\n<pre><code>function make () {\n  var self = this;\n  return function () {\n    console.log(self);\n  }\n}\n\n方法二\nfunction make () {\n  return function () {\n    console.log(this);\n  }.bind(this);\n}</code></pre><ul>\n<li><p>箭头函数不可以使用类似于arguments对象（super(ES6)，new.target(ES6)……），该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n</li>\n<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>\n</li>\n<li><p>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>\n</li>\n</ul>\n'},e759:function(n,e){n.exports='<p>非数值，一种特殊的数值</p>\n<pre><code>console.log(+0 === -0) // true\nconsole.log(0 / 0) // NaN\nconsole.log(1 / 0) // Infinity\nconsole.log(-1 / 0) // -Infinity\nconsole.log(1 == true);  // true</code></pre><blockquote>\n<p>NaN特点\n任何涉及NaN的操作都会返回NaN；\nNaN与任何值都不相等，包括自己。</p>\n</blockquote>\n<pre><code>console.log(NaN == NaN)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-176eccfcc43512b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">\n针对这两个特点，ECMAScript定义了isNaN()函数。这个函数可以接受一个参数，帮我们确定这个参数是否“不是数值”，这个函数在接受一个参数值后，会尝试把它转换为数值，不能转换为数值的值，在这个函数中会返回true。</p>\n<pre><code>    console.log(isNaN(NaN));  // true\n    console.log(isNaN(10)); // false\n    console.log(isNaN(&quot;10&quot;)); // false\n    console.log(isNaN(&quot;red&quot;)); // true\n    console.log(isNaN(true)); //false(可以被转换成数值1)</code></pre><h5 id="-number-parseint-parsefloat-">数值转换（Number / parseInt / parseFloat）</h5>\n<p>Number可以用于任何数据类型，另外两个专门用于转换字符串</p>\n<pre><code>Number(true) === 1 // true\nNumber(null) === 0 // true\nNumber(undefined) // NaN\n\nparseInt(&#39;123abl&#39;) // 123\nNumber(&#39;123abl&#39;) // NaN\n\nconsole.log(parseInt(&#39;&#39;)) // NaN\nconsole.log(Number(&#39;&#39;)) // 0\n\nconsole.log(parseInt(22.3)) // 22\nconsole.log(Number(22.3)) // 22.3\n\n对于八进制，ECMAScript3 和ECMAScript 5有争议\nparseInt(070)  --&gt; 56(ECMAScript3)\nparseInt(070)  --&gt; 70(ECMAScript5)\n\nparseInt有两个参数，第二个参数表示使用多少进制\n\nparseFloat只用于十进制，如果是十六进制，转为0\n\n</code></pre><h4 id="tostring">toString</h4>\n<p>null和undefined没有这个方法，默认一个参数，表示转换为多少进制的数，如果不知道是不是null或undefined，使用String方法</p>\n<p>加法</p>\n<pre><code>Infinity + (-Infinity) // NaN\n5 - true // 4\nNaN - 1 // NaN\n5 - &#39;&#39; // 0 (空被转换成0)\n5 - null // 5 (null被转换成0)\n\nundefined == 0  // false\nnull == 0 // false</code></pre><ul>\n<li>扩展：</li>\n</ul>\n<p>由于内存的限制，，js的数值中正负无穷分别保存在<code>Number.MAX_VALUE</code>和<code>Number.MIN_VALUE</code>中</p>\n<pre><code>console.log(Number.MAX_VALUE)\n</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-e28570ef9024f2ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正无穷"></p>\n'},ebeb:function(n,e){n.exports='<p><img src="http://upload-images.jianshu.io/upload_images/2941543-cf39b2ab7343b89c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="for"></p>\n<pre><code>    var num = 0;\n    outermost:\n    for (let i = 0; i &lt; 10; i++) {\n        for (let j = 0; j &lt; 10; j++) {\n            if (i == 5 &amp;&amp; j == 5) {\n                break outermost;\n            }\n            num++;\n        }\n    }\n    console.log(num) // 5</code></pre><p>outermost表示外部的for语句。如果每个循环正常执行10次，则num++会执行100次。但内部break带了一个参数，即要返回的标签。添加这个标签的结果将导致break语句不仅退出当前循环，还会退出外部循环。</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-82f2a296e2f1ba11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="continue"></p>\n<pre><code>    var num = 0;\n    outermost:\n    for (let i = 0; i &lt; 10; i++) {\n        for (let j = 0; j &lt; 10; j++) {\n            if (i == 5 &amp;&amp; j == 5) {\n                continue outermost;\n            }\n            num++;\n        }\n    }\n    console.log(num) // 95</code></pre><h4 id="switch">switch</h4>\n<pre><code>    var i = 100\n    switch (i) {\n        case 25: \n            alert(&#39;25&#39;);\n            break;\n        case 35:\n            alert(&#39;35&#39;);\n            break;\n        case 45:\n            alert(&#39;45&#39;);\n            break;\n        default: \n            alert(&#39;other&#39;)\n    }</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-ba72d164dd0d2f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},ec44:function(n,e){n.exports='<ul>\n<li>正则表达式：专门用来验证字符串的一种规则，我们可以自由的编写我们想要的验证规则，然后通过相关方法让这个正则去验证指定的字符串，并返回我们希望得到的结果</li>\n</ul>\n<p>创造一个正则表达式</p>\n<pre><code>var regExp = new RegExp(&#39;sdvsv&#39;,&#39;gi&#39;);\n// 第一个参数是正则表达式的主体内容\n// 第二个参数是正则的修饰符</code></pre><p>使用字面量创建正则：两个斜杠之间是正则主体，最后一个斜杠后是正则修饰符</p>\n<pre><code>var regExp1 = /\\d{2,3}/g;\n\n例如：\nvar str = &#39;dcfwe34r4566dg&#39;;\nstr.match(regExp1)</code></pre><p>2、如何用正则去验证字符串\n使用正则对象下的方法调用正则</p>\n<pre><code>var regExp2 = /[0-9]{1,}/;\nvar str1 = &#39;ascsvs797/a/ew7SaDCSCscac&#39;;</code></pre><ul>\n<li><p>test()方法：如果找到正则规则中匹配的字符，返回true。参数是要验证的字符串</p>\n<pre><code>alert( regExp2.test(str1) );</code></pre></li>\n<li><p>exec()方法：搜索字符串中符合正则规则的字符并把第一个匹配的字符返回出来,如果没有，返回unll</p>\n<pre><code>alert( regExp2.exec(str1) );</code></pre></li>\n</ul>\n<p>字符串对象下的正则验证方法\n&#39;&#39;：在引号中出现的字符是字符串\n// ：在两个斜杠之间出现的是正则\n字符串方法</p>\n<ul>\n<li><p>search()：字符串下的方法，找到参数指定的字符并返回下标，如果没找到，就返回-1。参数可以使字符串，也可以是正则表达式</p>\n<pre><code>alert(    str1.search(/a/) );</code></pre></li>\n<li><p>replace()关键字替换</p>\n<pre><code>var str2 = &#39;没有共产党，就没有新中国,警察，简称条子&#39;\nalert( str2.replace(/共产党|中国|警察/g,&#39;***&#39;) );</code></pre></li>\n<li><p>math() 找到匹配的字符并返回，返回一个数组形式</p>\n<pre><code>var str3 = &#39;hello, my name is liLei&#39;;\nalert(str3.match(/e/g));</code></pre></li>\n</ul>\n<p>3、正则语法\n修饰符：用来修饰正则表达式的字符\ni：让正则表达式不区分大小写匹配\ng: 让正则在匹配是全局匹配，而不是找到一个符合规则的后停止</p>\n<pre><code>var str = &#39;AacgeaAArdAad&#39;;\nvar regExp = /a/ig;\nalert(str.match(regExp));</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-b1db6b7bbc56ae0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="match"></p>\n<p>小括号:\n<img src="http://upload-images.jianshu.io/upload_images/2941543-b6ffbc2b8a1c26c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小括号"></p>\n<p>中括号</p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-07af2af21beeca8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中括号"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-97f9f08cbdf39d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="元字符"></p>\n<p><img src="http://upload-images.jianshu.io/upload_images/2941543-ef1bea18a33d8699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="量词"></p>\n'},f1a8:function(n,e){n.exports='<h4 id="-">跨域资源共享</h4>\n<p>克服了ajax同源限制，跨域发出xhr(XMLHttpRequert)请求</p>\n<ul>\n<li>兼容： 需要浏览器和服务器同时支持；\n   不支持IE10及以下版本;</li>\n</ul>\n<p>整个过程都是浏览器自动完成，不需要用户参与；\n对开发，代码同AJAX一样；\n浏览器会自动识别AJAX跨域请求，并自动添加请求头信息，有时会多出一次请求。</p>\n<p>需要服务器实现cors接口，就可以跨域通信。</p>\n<p>请求分类：\n<code>简单请求</code>和<code>非简单请求</code></p>\n<ul>\n<li>简单请求： 请求方法head,get,post.</li>\n</ul>\n'},f3e8:function(n,e){n.exports='<p>防止用户很快来回滑动，导致请求频繁，从而导致一些不必要的问题。\n<img src="http://upload-images.jianshu.io/upload_images/2941543-bcf42528b8d3a3c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现"></p>\n<p>npm install lodash 安装</p>\n<pre><code>import _ from &#39;lodash&#39;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/2941543-0191d4a34ec08764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>\n'},f538:function(n,e){n.exports='<p><img src="http://p5k2est0u.bkt.clouddn.com/bar3D2.png" alt="bar3D"></p>\n<h4 id="-">引入</h4>\n<pre><code>import echarts from &#39;echarts&#39;\nimport &#39;echarts-gl&#39; // 引入3d\nimport SimplexNoise from &#39;simplex-noise&#39; // A fast simplex noise implementation in Javascript.\nimport html2canvas from &#39;html2canvas&#39;</code></pre><h4 id="html">html</h4>\n<pre><code>    &lt;section class=&quot;table&quot; id=&quot;preview&quot;&gt;\n        &lt;tr&gt;\n          &lt;td colspan=&quot;4&quot; style=&quot;padding: 10px; width: 50px;&quot; class=&quot;chart-td&quot;&gt;\n            &lt;section style=&quot;width: 100%;&quot; class=&quot;charts-box&quot;&gt; // 第一个echarts\n              &lt;div class=&quot;bar3d&quot; id=&quot;bar3d1&quot; style=&quot;width:100%; height:400px;&quot;&gt;&lt;/div&gt;\n            &lt;/section&gt;\n          &lt;/td&gt;\n          &lt;td colspan=&quot;4&quot; style=&quot;padding: 10px; width: 50px;&quot; class=&quot;chart-td&quot;&gt;\n            &lt;section style=&quot;width: 100%;&quot; class=&quot;charts-box&quot;&gt; // 第二个echarts\n              &lt;div class=&quot;bar3d&quot; id=&quot;bar3d2&quot; style=&quot;width:100%; height:400px;&quot;&gt;&lt;/div&gt;\n            &lt;/section&gt;\n          &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/section&gt;\n\n    &lt;!-- 打印显示 --&gt;\n    &lt;aside class=&quot;print-box&quot;&gt;\n      &lt;img :src=&quot;src&quot; alt=&quot;&quot;&gt;\n    &lt;/aside&gt;</code></pre><h4 id="js">js</h4>\n<pre><code>  data () {\n    return {\n      bar3d1: null,\n      bar3d2: null,\n      src: &#39;&#39;\n    }\n  },\n  methods: {\n    print () { // 定义的打印方法\n      this.$store.dispatch(&#39;inspection/print&#39;, &#39;.print-box&#39;)\n    },\n    drawColumnChart () { // 第一个charts 定义\n      this.bar3d1 = echarts.init(document.getElementById(&#39;bar3d1&#39;));\n      let noise = new SimplexNoise(Math.random);\n      function generateData (theta, min, max) {\n        let data = []\n        for (let i = 0; i &lt;= 50; i++) {\n          for (let j = 0; j &lt;= 50; j++) {\n            let value = noise.noise2D(i / 20, j / 20)\n            valMax = Math.max(valMax, value)\n            valMin = Math.min(valMin, value)\n            data.push([i, j, value * 2 + 4])\n          }\n        }\n        return data\n      }\n      let valMin = Infinity;\n      let valMax = -Infinity;\n      let data = generateData(2, -5, 5);\n      console.log(valMin, valMax);\n      this.bar3d1.setOption({\n        visualMap: {\n          show: false,\n          min: 2,\n          max: 6,\n          inRange: {\n            color: [&#39;#313695&#39;, &#39;#4575b4&#39;, &#39;#74add1&#39;, &#39;#abd9e9&#39;, &#39;#e0f3f8&#39;, &#39;#ffffbf&#39;, &#39;#fee090&#39;, &#39;#fdae61&#39;, &#39;#f46d43&#39;, &#39;#d73027&#39;, &#39;#a50026&#39;]\n          }\n        },\n        xAxis3D: {\n          type: &#39;value&#39;\n        },\n        yAxis3D: {\n          type: &#39;value&#39;\n        },\n        zAxis3D: {\n          type: &#39;value&#39;,\n          max: 10,\n          min: 0\n        },\n        grid3D: {\n          axisLine: {\n            lineStyle: { color: &#39;#fff&#39; }\n          },\n          axisPointer: {\n            lineStyle: { color: &#39;#fff&#39; }\n          },\n          viewControl: {\n            // autoRotate: true\n          },\n          light: {\n            main: {\n              shadow: true,\n              quality: &#39;ultra&#39;,\n              intensity: 1.5\n            }\n          }\n        },\n        series: [{\n          type: &#39;bar3D&#39;,\n          data: data,\n          shading: &#39;lambert&#39;,\n          label: {\n            formatter: function (param) {\n              return param.value[2].toFixed(1);\n            }\n          }\n        }]\n      })\n    },\n    drawCharts () { // 渲染到页面\n      this.$nextTick(() =&gt; {\n        // 由于是在一个大的table中用的，两边一样大小\n        // 但是echarts会自定义宽高，不自适应，所以js定义一个宽高,每次刷新页面进来都是ok的\n        let wi = this.getStyle(document.querySelector(&#39;.axis&#39;), &#39;width&#39;).width.split(&#39;px&#39;)[0];\n        wi = (Number(wi) - 40) / 2\n        document.querySelectorAll(&#39;.chart-td&#39;).forEach(item =&gt; {\n          item.style.width = wi + &#39;px&#39;\n          item.querySelector(&#39;.charts-box&#39;).style.width = wi + &#39;px&#39;\n        })\n        this.drawColumnChart()\n        // this.drawBarChart()\n      })\n\n      // 给打印做准备\n      let _th = this\n      this.$nextTick(() =&gt; {\n        setTimeout(() =&gt; {\n          html2canvas(document.querySelector(&#39;.table&#39;)).then(canvas =&gt; {\n            _th.src = canvas.toDataURL(&#39;image/png&#39;)\n          })\n        }, 2000)\n      })\n    },\n    getStyle(el, name) {　　\n      if (window.getComputedStyle) {　　　\n        return window.getComputedStyle(el, null);　　\n      } else {　　　\n        return el.currentStyle;　　\n      }　\n    }\n  },\n  // 调用\n  mounted () {\n    this.drawCharts()\n  },\n  updated () {\n    this.drawCharts()\n  }</code></pre><p><img src="http://p5k2est0u.bkt.clouddn.com/bar3D1.png" alt="bar3D"></p>\n'},f923:function(n,e){n.exports="<ul>\n<li><p>云物联</p>\n</li>\n<li><p>云存储</p>\n</li>\n<li><p>云安全</p>\n</li>\n<li><p>云游戏</p>\n</li>\n<li><p>云计算</p>\n</li>\n</ul>\n"},fbe2:function(n,e){n.exports='<h4 id="-">一、四种数据集合</h4>\n<p>Array  Object Map Set</p>\n<h5 id="1-set-">1. Set：类似于数组，但是成员的值都是唯一的，没有重复的值。</h5>\n<pre><code>| 方法：|             |\n| :--------: | :---------: |\n| add  | 添加 |\n| clear | 清空 |\n | delete | 删除 |\n | has | 如果集包含指定元素，则返回 true。 |\n | valueOf | 返回指定对象的原始值。 |</code></pre><p> 数组去重</p>\n<pre><code>    let arr1 = [1, 3, 2, 4, 5, 3, 1, 4, 2];\n    const result = [...new Set(arr1)];\n    console.log(result); // [1, 3, 2, 4, 5]</code></pre><pre><code>     let set = new Set();\n     let a = NaN;\n     let b = NaN;\n     set.add(a).add(b);\n     // 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。但只能存一个NaN的值。\n     set.add({});\n     set.add({});\n     set.size; // 由于两个空对象不相等，所以它们被视为两个值。\n     const array = Array.from(set); // Array.from方法可以将 Set 结构转为数组。</code></pre><p>数组去重方法二：</p>\n<pre><code>     function dedupe (arr) {\n         return Array.from(new Set(arr));\n     }</code></pre><table>\n<thead>\n<tr>\n<th align="center">遍历方法</th>\n<th align="center"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align="center">keys()</td>\n<td align="center">返回键名的遍历器</td>\n</tr>\n<tr>\n<td align="center">values()</td>\n<td align="center">返回键值的遍历器</td>\n</tr>\n<tr>\n<td align="center">entries()</td>\n<td align="center">返回键值对的遍历器</td>\n</tr>\n<tr>\n<td align="center">forEach()</td>\n<td align="center">使用回调函数遍历每个成员</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p> Set的遍历顺序就是插入顺序。\n       由于键名和键值是同一个值 ，所以keys方法和values方法的行为完全一致。</p>\n</blockquote>\n<pre><code>     let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\n     for (let item of set.keys()) {\n         console.log(item); // &#39;red&#39;, &#39;green&#39;, &#39;blue&#39;\n     }\n     for (let item of set.entries()) {\n         console.log(item)\n     }\n     [&quot;red&quot;, &quot;red&quot;]\n     [&quot;green&quot;, &quot;green&quot;]\n     [&quot;blue&quot;, &quot;blue&quot;]\n     可以通过for--of直接遍历Set.\n     for (let x of set) {\n         console.log(x)\n     }\n\n     let a = new Set([1, 2, 3]);\n     let b = new Set([4, 3, 2]);</code></pre><p> 并集</p>\n<pre><code>     let union = new Set([...a, ...b]);\n     Set {1, 2, 3, 4}</code></pre><p> 交集</p>\n<pre><code>     let intersect = new Set([...a].filter(x =&gt; b.has(x)));\n     set {2, 3}</code></pre><p> 差集</p>\n<pre><code>     let difference = new Set([...a].filter(x =&gt; !b.has(x)));\n      Set {1}</code></pre><p>  扩展 \n     WeakSet结构与 Set 类似，也是不重复的值的集合。\n     区别：WeakSet 的成员只能是对象，而不能是其他类型的值。\n     WeakSet没有size属性，没有办法遍历它的成员。</p>\n<h5 id="2-map-">2. Map对象</h5>\n<p>Object只能用字符串当作键。\nMap各种类型的值（包括对象）都可以当作键</p>\n<pre><code>    const m = new Map();\n    const o = {p: &#39;Hello World&#39;};\n    m.set(o, &#39;content&#39;);\n    m.get(o); // content\n    m.has(o) // true\n    m.delete(o)\n    m.has(o) // false\n    const map = new Map([\n         [&#39;name&#39;, &#39;张三&#39;],\n         [&#39;title&#39;, &#39;Author&#39;]\n    ]);\n\n     map.size // 2\n     map.has(&#39;name&#39;) // true\n     map.get(&#39;name&#39;); // &quot;张三&quot;\n     map.has(&#39;title&#39;) // true\n     map.get(&#39;title&#39;) // &quot;Author&quot;</code></pre><blockquote>\n<p> 如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<pre><code>    forEach方法还可以接受第二个参数，用来绑定this。\n     map.forEach(function(value, key, map) {\n         this.report(key, value);\n     }, reporter);</code></pre><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。\n     WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n    一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p>\n</blockquote>\n<pre><code> 注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\nObject {foo: 1}</code></pre><p>·</p>\n<hr>\n<p>·</p>\n<h5 id="for-in-for-of-"><code>for--in</code>  和  <code>for--of</code> 区别</h5>\n<p>JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。\n     ES6 提供for...of循环，允许遍历获得键值</p>\n<pre><code>     var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n     for (let a in arr) {\n       console.log(a); // 0, 1, 2, 3\n     }\n     for (let a of arr) {\n       console.log(a); // a, b, c, d\n     }\n     for...in循环读取键名，for...of循环读取键值。</code></pre><p>for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。</p>\n<pre><code>     let arr = [1, 3, 5, 7];\n     arr.foo = &#39;hello&#39;;\n\n     for (let i in arr) {\n       console.log(i); // &#39;1&#39;, &#39;3&#39;, &#39;5&#39;, &#39;7&#39;, &#39;foo&#39;\n     }\n\n     for (let i of arr) {\n       console.log(i); // 1, 3, 5, 7\n    }\n     for--in 返回的都会转换成字符串格式，for--of不会。</code></pre><p>Set 结构遍历时，返回的是一个值，\n而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>\n<pre><code>     let map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2);\n     for (let pair of map) {\n       console.log(pair);\n     }\n    [&#39;a&#39;, 1]\n    [&#39;b&#39;, 2]\n\n     for (let [key, value] of map) {\n       console.log(key + &#39; : &#39; + value);\n     }\n     a : 1\n     b : 2\n\n     let es6 = {\n       edition: 6,\n       committee: &quot;TC39&quot;,\n       standard: &quot;ECMA-262&quot;\n     };\n     像这样的一个对象，在直接使用for--of时，会报错，解决方法：\n     for (var key of Object.keys(es6)) {\n       console.log(key + &#39;:&#39; + es6[key]);\n     }\n\n     也可以使用Generator函数将对象重新包装一下。\n     function* entries (obj) {\n       for (let key of Object.keys(obj)) {\n         yield [key, obj[key]]\n       }\n     }\n    for (let [key, value] of entries(es6)) {\n      console.log(key, value)\n    }</code></pre><h5 id="-">循环的缺点</h5>\n<ul>\n<li><p>forEach循环无法中途跳出，break和return 都不能奏效。但for-of可以</p>\n</li>\n<li><p>for--in缺点：主要用于便利对象</p>\n</li>\n<li><p>数组键名是Number，但for--in是以字符串作为键名；</p>\n</li>\n<li><p>for--in不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；</p>\n</li>\n<li><p>有时for--in会以任意顺序遍历。</p>\n</li>\n</ul>\n'},fdf6:function(n,e){n.exports='<h2 id="-">备份</h2>\n<p><code>mongodump -h dbhost -d dbname -o dbdirectory</code></p>\n<ul>\n<li><p>-h 服务器地址，如127.0.0.1，（也可以加上端口号）</p>\n</li>\n<li><p>-d 需要备份的数据库实例 eg: test</p>\n</li>\n<li><p>-o 备份的数据存放位置，eg: c:\\data\\dump 该目录需要提前建立，在备份完成后，系统会在dump目录下建立一个test目录，这里存放该数据库实例的备份数据。</p>\n</li>\n</ul>\n<p>eg:</p>\n<pre><code>&gt;mongodump\n\n客户端会在127.0.0.1:27017的服务上，备份所有数据到`bin/dump/`目录\n</code></pre><hr>\n<h2 id="-">恢复</h2>\n<p><code>mongorestore</code></p>\n<pre><code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;\n\n--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017\n\n--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2\n\n--drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除\n\n&lt;path&gt;： mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。\n\n--dir： 指定备份的目录\n\n不能同时指定 &lt;path&gt; 和 --dir 选项\n</code></pre><p>也可以像备份那样直接在命令行输入简化命令<code>mongorestore</code></p>\n<h3 id="-">备份</h3>\n<blockquote>\n<p> mongodump -h dbhost -d dbname -o dbdirectory -u user -p password</p>\n</blockquote>\n<pre><code>mongodump 127.0.0.1:27017 dbhost 数据库名 dbname c:data(备份的目录) dbdirectory 用户名 user 密码 password</code></pre><h3 id="-">恢复</h3>\n<blockquote>\n<p>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path></p>\n</blockquote>\n<pre><code>mongorestore -h 127.0.0.1:27017 -d 数据库名 设置备份所在位置\n\n--drop： 恢复的时候，会先删除当前数据，然后恢复备份数据。备份后添加修改的数据都没了\n\n--dir: 指定备份目录，不能同时指定path和--dir;</code></pre><h3 id="-">定时备份</h3>\n<p>shell脚本</p>\n<pre><code>#!/bin/sh\n# dump 命令执行路径，根据mongodb安装路径而定\nDUMP=/usr/bin/mongodump\n# 临时备份路径\nOUT_DIR=/home/backup/mongod_bak/mongod_bak_now\n# 压缩后的备份存放路径\nTAR_DIR=/home/backup/mongod_bak/mongod_bak_list\n# 当前系统时间\nDATE=`date +%Y-%m-%d`\n# 数据库账号\nDB_USER=user\n# 数据库密码\nDB_PASS=password\n# 代表删除7天前的备份，即只保留近 7 天的备份\nDAYS=7\n# 最终保存的数据库备份文件\nTAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot;\ncd $OUT_DIR\nrm -rf $OUT_DIR/*\nmkdir -p $OUT_DIR/$DATE\n$DUMP -h 127.0.0.1:27017 -u $DB_USER -p $DB_PASS -d dbname -o $OUT_DIR/$DATE\n# 压缩格式为 .tar.gz 格式\ntar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE\n# 删除 15 天前的备份文件\nfind $TAR_DIR/ -mtime +$DAYS -delete\n\nexit</code></pre>'},fe36:function(n,e){n.exports="<p><strong>display: grid \\ inline-grid \\ subgrid</strong></p>\n<pre><code>grid: 生成块级网格\ninline-grid: 生成行内网格\nsubgrid: 如果网格容器嵌套网格容器，用来继承父网格容器的列、行大小。\n</code></pre><blockquote>\n<p>注：设置了网格布局之后，<code>column</code>, <code>float</code>, <code>clear</code>, <code>vertical-align</code>属性无效。</p>\n</blockquote>\n<p><strong>grid-template-columns</strong>\n<strong>grid-template-rows</strong></p>\n<pre><code>grid-template-columns 设置行和列大小\n\ntrack-size: 轨道大小，可以css长度，百分比，分数，（fr单位）。\nline-name: 网格线名字</code></pre><p>eg: </p>\n<pre><code>display: grid;\ngrid-template-columns: 40px 50px auto 50px 40px;\ngrid-template-rows: 25% 100px auto;\n\n定义网格线名字，写[]里面\ngrid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\n\n重复的部分用repeat()简化\ngrid-template-columns: repeat(3, 20px [col-start]) 5%;\n\n===\n\ngrid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%;</code></pre><p>使用<code>fr</code>单位，将容器分为几等份。</p>\n<p>如果包含实际值，设置<code>fr</code>的行或列将平分剩余部分；</p>\n<p><strong>grid-template-areas</strong></p>\n<pre><code>&#39;grid-area-name&#39;: 网格项的grid-area名\n&#39;.&#39;: 空网格单元\n&#39;none&#39;: 不定义网格区域</code></pre><p><strong>grid-column-gap</strong>\n<strong>grid-row-gap</strong></p>\n<pre><code>网格单元间距</code></pre><blockquote>\n<p>简写： <code>grid-gap</code></p>\n</blockquote>\n<p>eg:</p>\n<pre><code>    display:grid;\n    grid-template-columns: 100px 50px 100px;\n    grid-template-rows: 80px auto 80px; \n    grid-gap: 10px 15px;</code></pre><p><strong>justify-items</strong>\n网格内对齐方式  但会影响宽度</p>\n<pre><code>start: 左对齐\nend: 右对齐\ncenter: 居中\n</code></pre><p><strong>align-items</strong>\n没作用</p>\n<pre><code>start: 顶部对齐\nend: 底部对齐\ncenter: 居中对齐</code></pre>"},fe3d:function(n,e){n.exports='<blockquote>\n<p> 异步编程的一种解决方式，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n</blockquote>\n<h6 id="-">特点：</h6>\n<ol>\n<li>对象状态不受外界的影响</li>\n<li>一旦状态改变就不会再变，任何时候都能得到这个结果</li>\n<li>一旦建立立即执行，无法取消。</li>\n</ol>\n<blockquote>\n<p>基本用法</p>\n</blockquote>\n<pre><code>var promise=new Promise(function(resolve,reject){\n        //代码块\n        if(异步操作成功){\n            resolve(value);\n        }else{\n            reject(error);\n        }\n    })\n// 其中resolve和reject是两个函数，resolve在异步操作成功是执行，否则执行reject。\n\n&gt; 调用时，用then方法\n    promise.then(function(value){\n        //成功时resolve执行的代码\n     },function(error){\n        //失败时reject执行的代码\n    })</code></pre><blockquote>\n<p>一个简单的例子、</p>\n</blockquote>\n<pre><code>     function timeout(ms){\n        return new Promise((resolve,reject)=&gt;{\n            setTimeout(resolve,ms,&#39;done&#39;);\n        })\n    }\n\n     timeout(100).then((value)=&gt;{\n        console.log(value);//&#39;done&#39;\n    })</code></pre><blockquote>\n<p>promise新建后会立即执行</p>\n</blockquote>\n<pre><code>    let promise = new Promise(function(resolve,reject){\n        console.log(&#39;Promise&#39;);\n        resolve()\n    })\n\n    promise.then(function(){\n         console.log(&#39;Resolved&#39;);\n    })\n    console.log(&#39;hello world&#39;);\n    Promise\n    //hello world\n    //Resolved\n    //上面呢代码中，promise新建后会立即执行，所以首先输出，然后then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以最后输出</code></pre><blockquote>\n<p>异步获取AJAX</p>\n</blockquote>\n<pre><code>    var getJSON=function(url){\n        var promise=new Promise(function(resolve,reject){\n            var xhr=new XMLHttpRequest();\n            xhr.open(&#39;GET&#39;,url);\n            xhr.send(null);\n            xhr.onreadystatechange=handler;\n            xhr.responseType=&#39;json&#39;;\n            xhr.setRequestHeader(&#39;Accept&#39;,&#39;application/json&#39;);\n\n            function handler(){\n                if(this.readyState!==4){\n                    return;\n                }\n                if(this.status===200||this.status===304){\n                    resolve(this.response)\n                }else{\n                    reject(new Error(this.statusText))//返回当前请求的响应行状态\n                }\n            }\n        })\n        return promise;\n    }\n\n    getJSON(&#39;/posts.json&#39;).then(function(json){\n        console.log(&#39;Contents:&#39;+json);\n    },function(error){\n        console.error(&#39;出错了&#39;,error)\n    })</code></pre><ul>\n<li><p>异步操作resolve除了可以返回一个正常值以外，还可以返回另一个异步操作；</p>\n<pre><code> var p1=new Promise(function(resolve,reject){\n\n })\n var p2=new Promise(function(resolve,reject){\n     resolve(p1);\n })\n //这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。\n如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；\n如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</code></pre></li>\n</ul>\n<blockquote>\n<h3 id="then-">then方法</h3>\n</blockquote>\n<ul>\n<li>定义在原型上的Promise.prototype.then</li>\n<li>作用是为Promise实例添加状态改变时的回调函数</li>\n<li>第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</li>\n<li>可以采用链式写法<pre><code> getJSON(&quot;/post/1.json&quot;).then(\n    post =&gt; getJSON(post.commentURL)\n  ).then(\n    comments =&gt; console.log(&quot;Resolved: &quot;, comments),\n   err =&gt; console.log(&quot;Rejected: &quot;, err)\n );</code></pre></li>\n</ul>\n<blockquote>\n<h3 id="catch-">catch方法</h3>\n</blockquote>\n<ul>\n<li>Promise.prototype.catch方法</li>\n<li>是then的另一种实现，即\n   getJSON.then(null,rejection),用于指定发生错误时的回调函数</li>\n</ul>\n<pre><code>    getJSON(&quot;/posts.json&quot;).then(function(posts) {\n      // ...\n     }).catch(function(error) {\n       // 处理 getJSON 和 前一个回调函数运行时发生的错误\n       console.log(&#39;发生错误！&#39;, error);\n     });</code></pre><blockquote>\n<p> 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</p>\n</blockquote>\n<ul>\n<li>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</li>\n</ul>\n<pre><code>    getJSON(&quot;/post/1.json&quot;).then(function(post) {\n      return getJSON(post.commentURL);\n    }).then(function(comments) {\n      // some code\n    }).catch(function(error) {\n      // 处理前面三个Promise产生的错误\n    });</code></pre><blockquote>\n<p> 建议总是使用catch方法，而不使用then方法的第二个参数。没有指定catch方法，错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。</p>\n</blockquote>\n<ul>\n<li>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。<pre><code>   process.on(&#39;unhandledRejection&#39;, function (err, p) {\n    console.error(err.stack)\n   });</code></pre><blockquote>\n<p>上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>######最好的方法就是</p>\n<pre><code>    someAsyncThing().then(function() {\n       return someOtherAsyncThing();\n     }).catch(function(error) {\n       console.log(&#39;oh no&#39;, error);\n       // 下面一行会报错，因为y没有声明\n      y + 2;\n    }).catch(function(error) {\n      console.log(&#39;carry on&#39;, error);\n    });\n     // oh no [ReferenceError: x is not defined]\n    // carry on [ReferenceError: y is not defined]</code></pre></blockquote>\n<blockquote>\n<p>上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。</p>\n</blockquote>\n'},fe7b:function(n,e){n.exports='<h1 id="i-will-doing-in-2018">I will doing in 2018</h1>\n<ol>\n<li>master(&#39;掌握&#39;) <code>node.js</code></li>\n</ol>\n<p><del>2. understand(&#39;了解&#39;) <code>http</code>,<code>webSocket</code></del></p>\n<p><del>3. has my-blog</del></p>\n<ol start="4">\n<li><p>complete one Small program</p>\n</li>\n<li><p>Two level builder</p>\n</li>\n</ol>\n<p><del>6. go to beijing for work,15</del></p>\n<ol start="7">\n<li><p><code>react</code> review and has a react program blog -&gt; </p>\n</li>\n<li><p>introducting <code>java</code>, (or <code>AI</code>)</p>\n</li>\n<li><p>publish an article everyday</p>\n</li>\n</ol>\n<p><del>10. Save money for Get driver&#39;s license</del></p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<p>~</p>\n<h2 id="love-qqh-more-then-before">love qqh More then before</h2>\n'},ff0c:function(n,e){n.exports='<ol>\n<li>新建elementUI.js  </li>\n</ol>\n<pre><code>import Vue from &#39;vue&#39;;\nimport { \n    Row,\n    Col,\n    Button,\n    Input, \n    Dialog,\n    Form,\n    FormItem,\n    Loading,\n    Checkbox,\n    Tooltip\n} from &#39;element-ui&#39;;\nimport &#39;element-ui/lib/theme-chalk/index.css&#39;;\n\nexport default function elementui() {\n    Vue.use(Row);\n    Vue.use(Col);\n    Vue.use(Input);\n    Vue.use(Button);\n    Vue.use(Dialog);\n    Vue.use(Form);\n    Vue.use(FormItem);\n    Vue.use(Loading);\n    Vue.use(Checkbox);\n    Vue.use(Tooltip);\n}</code></pre><ol start="2">\n<li>main.js </li>\n</ol>\n<pre><code>import elementui from &#39;./utils/elementUI&#39;;\n\nelementui()</code></pre>'}});