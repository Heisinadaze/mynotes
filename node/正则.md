
### 特殊字符：


- `\b`: 只匹配一个位置，（单词分界处）;
- `.`: 匹配除了换行符意外的任意字符;
- `*`: 匹配数量; (`.*`表示任意数量的不包含换行的字符 `>= 0`)
- `+`: 同`*`,(`>= 1`);
- `?`: 同`*`,(` === 0 || === 1`);
- `\d`: 匹配一位数字;
- `\D`: 反义的`d`,匹配任意非数字;
- `{2}`: 同`*`表示重复匹配两次(`{5, 12}`表示5到12位, `{2,}`表示重复两次以上);
- `\s`: 匹配任意空白符，包括空格，制表符，换行符，中文全角空格等;
- `\S`: 反义的`\s`,匹配任意不是空白符的字符;
- `\w`: 匹配字母或数字或下划线或汉字等;
- `\W`: 反义的`\w`,匹配任意的不是字母，数字，下划线，汉字的字符;
- `^`: 匹配字符串的开始;
- `$`: 匹配字符串的结束;
- `\B`: 匹配不是开头或结束的位置;
- `\`: 转义符;
- `[aeiou!%@?]`: 匹配数组中任意一个字符;
- `[0-9]`: 匹配0到9之间的一个数字;
- `[a-z0-9A-Z]`: 同上;
- `|`: 分枝条件，或,(使用时，要注意，当满足一个条件时，将不会继续匹配后面的条件是否满足);
- `()`: 分组匹配，常配合重复次数使用;
- `[^X]`: 匹配除了`x`以外的任意字符;
- `[^aeiou]`: 匹配除了`aeiou`以外的任意字符;
- `\t`: 制表符，Tab;
- `\r`: 回车;
- `\v`: 竖向制表符;
- `\f`: 换页符;
- `\n`: 换行符;
- `\e`: Escape;




### 工具 `Regester`


### 后向引用 `(用于重复搜索前面某个分组匹配的文本。)`

> 在用`()`分组时，每个分组会自动拥有一个组号；\
规则是从左向右，以分组的左括号为标志,\
第一个出现的分组的组号为1，第二个为2，以此类推。\
`\1`代表分组1匹配的文本。

> 例：
```
\b(\w+)\b\s+\1\b; // 用来匹配像'go go',等重复的单词。
```

 **自定义组名：**
 
 语法：`(?<Word>\w+)`(或者把尖括号换成'也行：`(?'Word'\w+)`),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。


### 零宽断言 

> 对于像`\b`, `^`, `$`,那样用于指定一个位置，这个位置应该应该满足一定条件，即断言 \
`(?=exp)`: 断言自身出现的位置的后面能匹配表达式exp; \
`(?<=exp)`: 断言自身出现的位置的前面能匹配表达式exp;

```
\b\w+(?=ing\b); // 匹配以ing结尾的单词的前面部分（除了ing以外的部分）

(?<=\bre)\w+\b; // 匹配re开头的单词，除了re的后半部分。
```


**负向零宽断言**

```
\b\w*p[^u]\w*\b: // 匹配后面不是字母u的字母p
```
但是当以p结尾的单词，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词， 于是就匹配出两个单词。

```
\b\w*p(?!u)\w*\b; 解决方法
```

> `(?!exp)`: 断言此位置的后面不能匹配表达式exp;
> `(?<!exp)`: 断言此位置的前面不能匹配表达式exp;

```
\d{3}(?!\d): 匹配后面不能是数字的三个数字；

(?<![a-z])\d{7}: 匹配前面不是小写字母的七位数字；

(?<=<(\w+)>).*(?=<\/\1>): 匹配不包含属性的简单的HTML标签里的内容；
```



### 注释

> (>#注释语句)

使用注释时，最好忽略模式里的空白符，在#后面到这一行结束时，所有的文本都将被当成注释忽略掉。



### 贪婪匹配


当正则中包含能接受重复的限定符时，通常会在使整个表达式能得到匹配的前提下，匹配尽量多的字符，例如用`a.*b`匹配`aabab`时，将会匹配到整个字符串。

要转化为懒惰匹配模式，只需要在前面所有的限定符后面加一个`?`。

```
a.*?b; // 匹配到'aab', 'ab'.
```


### 处理选项

| 名称 | 说明 |
| ----- | ----- |
|lgnoreCase| 匹配时不区分大小写|
|Multiline多行模式| 修改`^`,`$`含义，是他们们别在任意一行行首或行尾匹配|
|Singleline单行模式| 修改`.`的含义，使他与每一个字符匹配，包括`\n`|
|IgnorePatternWhitespace| 忽略空白,并启用由#标记的注释|
|ExplicitCapture| 仅捕获已被显式命名的组。|


### 平衡组/递归匹配

对于需要匹配像`(100 * (50 - 15))`这样的可嵌套的层次结构。正常匹配只会匹配到最左边的左括号和最右边的右括号之间的内容，

`(?'group')`: 把捕获到的内容命名为group，并压入堆栈 \
`(?'-group')`: 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 \
`(?(group)yes|no)`: 如果堆栈上存在以名为group捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 \
`(?!)`: 零宽负向先断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。







