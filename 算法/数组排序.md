
### 冒泡排序

> 一种排序算法

一次比较两个元素（大的右边，小的左边）。一个把大的元素慢慢浮出到数组边缘，即冒泡排序。

第一轮先把最大的放到右边
然后比较把第二大的数字放到右边第二个
依次到最后

```
    function sort (arr) {
        for (let i = 0; i < arr.length - 1; i++) {
            for (let j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    [ arr[j], arr[j + 1] ] = [ arr[j + 1], arr[j] ]
                }
            }
        }
    }

    let arr = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8];
    console.log('before' + arr);
    sort(arr);
    console.log('after ' + arr);
```



### 快速排序

从数组中间分来，一边的数字全部小于右边，递归下来。

```

function quickSort (a) {
  // a表示传进来的数组
  if (a.length <= 1) return a

  let mid = ~~(a.length / 2)
  let midItem = a.splice(mid, 1)[0]
  let left = []
  let right = []

  a.forEach(item => {
    if (item <= midItem) left.push(item)
    else right.push(item)
  })

  let _left = quickSort(left)
  let _right = quickSort(right)

  return _left.concat(midItem, _right)
}

```


**如果出现较多重复元素**

```
    function quickSort (a) {
      if (a.length <= 1) return a

      let last = a.pop()
      let left = []
      let right = []
      let mid = [last]

      a.forEach(item => {
        if (item < last) {
          left.push(item)
        } else if (item > last) {
          right.push(item)
        } else {
          mid.push(item)
        }
      })

      let _left = quickSort(left)
      let _right = quickSort(right)

      return _left.concat(mid, _right)
    }


```



```
function quickSort (a) {
      return a.length <= 1 ? a
                          : quickSort(a.slice(1).filter(item => item <= a[0]))
                                      .concat(a[0],
                                              quickSort(a.slice(1).filter(item => item > a[0])))
    }
```




