### VUEX 状态管理仓库

应用于大型的单页应用

> 类似于全局变量，和全局变量的区别: 
1.vuex是动态的；
2 不能直接赋值和取值；
附：不能用全局变量的原因------因为每个单文件组件都是一个VUE实例，不能跨域访问

四个部分： `state`, `action`, `mutation`,`getter`

> 过程：
1通过组件触发action方法，（this.$store.dispath触发，或init）
action默认第一个参数是context
通过context.commit()可以触发mutation
2 mutation默认接受的第一个参数是state
可以直接访问state里面的变量如state.user
3 然后通过getter获取参数
这四个部分都属于自己的辅助函数
辅助函数更加方便精简


![小香香](http://upload-images.jianshu.io/upload_images/2941543-97aa86b2857d8082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 组件传值的方法
* props 父组件给子组件传值
* $emit 子组件给父组件传值
* router 路由传参
* vuex 传值
* $ref 父组件给子组件传值
* 离线缓存

### 箭头函数和普通函数的区别

* 更简洁， 没有this

* 箭头函数不可以使用类似于arguments对象（super(ES6)，new.target(ES6)……），该对象在函数体内不存在。如果要用，可以用Rest参数代替。

* 不可以使用yield命令，因此箭头函数不能用作Generator函数。（async）

* 箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。


绑定this方法：
```
function make () {
  var self = this;
  return function () {
    console.log(self);
  }
}

方法二
function make () {
  return function () {
    console.log(this);
  }.bind(this);
}
```


### 垃圾回收机制

标记清除（常用）   和    引用计数

标记清除：垃圾收集器在运行时给存储在内存中的所有变量都加上标记。然后去掉环境中的变量以及被环境中变量引用的变量的标记。在此之后，再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存收集工作。销毁那些带标记的值，并回收他们所占用的内存。

引用计数：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值引用次数减1.当这个值得引用次数变为0时，说明没办法再访问这个值了，就将其占用的内存空间回收回来。当垃圾收集器再次运行时，释放那些引用次数为零的值所占用的内存。


### set对象
类似于数组，但是成员的值都是唯一的，没有重复的值。
 Set的遍历顺序就是插入顺序。

一个最简单的应用：数组去重
```
    let arr1 = [1, 3, 2, 4, 5, 3, 1, 4, 2];
    const result = [...new Set(arr1)];
    console.log(result); // [1, 3, 2, 4, 5]
```

### Map对象
Object只能用字符串当作键。
Map各种类型的值（包括对象）都可以当作键
```
    const m = new Map();
    const o = {p: 'Hello World'};
    m.set(o, 'content');
    m.get(o); // content
    m.has(o) // true
    m.delete(o)
    m.has(o) // false
    const map = new Map([
         ['name', '张三'],
         ['title', 'Author']
    ]);

     map.size // 2
     map.has('name') // true
     map.get('name'); // "张三"
     map.has('title') // true
     map.get('title') // "Author"
```
>  如果对同一个键多次赋值，后面的值将覆盖前面的值。


### 循环的缺点
* forEach循环无法中途跳出，break和return 都不能奏效。但for-of可以

* for--in缺点：主要用于便利对象
* 数组键名是Number，但for--in是以字符串作为键名；
* for--in不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键；
* 有时for--in会以任意顺序遍历。


### vue响应式原理

![image.png](http://upload-images.jianshu.io/upload_images/2941543-bd143f62c920604a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1通过 Observer 对 data 做监听，并且提供了订阅某个数据项变化的能力。

2template 编译，解析其中的 Directive，得到每一个 Directive 所依赖的数据项和update方法。

3通过Watcher把上述两部分结合起来，即把Directive中的数据依赖通过Watcher订阅在对应数据的 Observer 的 Dep 上。当数据变化时，就会触发 Observer 的 Dep 上的 notify 方法通知对应的 Watcher 的 update，进而触发 Directive 的 update 方法来更新 DOM 视图，最后达到模型和视图关联起来。
