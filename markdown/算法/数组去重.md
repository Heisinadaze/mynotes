```
let array = [1,2,3,3,4,2,4,5];
```


> 方法一（通过indexOf，返回该数组下表）
```
		Array.prototype.unique = function()
		{
			var n = [this[0]]; //结果数组
			for(var i = 1; i < this.length; i++) //从第二项开始遍历
			{
			// 	//如果当前数组的第i项在当前数组中第一次出现的位置不是i，
			// 	//那么表示第i项是重复的，忽略掉。否则存入结果数组
				if (this.indexOf(this[i]) == i) n.push(this[i]);
				console.log(this.indexOf(this[i]),i);
			}
			return n;
		}
调用
    array.unique()
```


---

> 方法二(通过sort从小到大排序，然后遍历数组比较相邻元素是否相等)
```
    Array.prototype.unique = function()
		{
			this.sort();
			var re=[this[0]];
			for(var i = 1; i < this.length; i++)
			{
				if( this[i] !== re[re.length-1])
				{
					re.push(this[i]);
				}
			}
			return re;
		}
        调用
		array.unique();
```

---


> 方法三（通过哈希表）
```
		Array.prototype.unique = function()
		{
			var n = {},r=[]; //n为hash表，r为临时数组
			for(var i = 0; i < this.length; i++) //遍历当前数组
			{
				console.log(n[this[i]])
				if (!n[this[i]]) //如果hash表中没有当前项
				{
					n[this[i]] = true; //存入hash表
					r.push(this[i]); //把当前数组的当前项push到临时数组里面
				}
			}
			return r;
		}
        array.unique()
```




[散列表]()（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的[数据结构](http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](http://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，存放记录的[数组](http://baike.baidu.com/item/%E6%95%B0%E7%BB%84)叫做[散列表](http://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8)。


---

> 方法四（类似于方法一）
方法一是假设当前元素的下标是否是重复的
方法四是判断有没有这个下标，没有返回-1；
```
		Array.prototype.unique = function()
		{
			var n = []; //一个新的临时数组
			for(var i = 0; i < this.length; i++) //遍历当前数组
			{
				//如果当前数组的第i已经保存进了临时数组，那么跳过，
				//否则把当前项push到临时数组里面
				console.log(n.indexOf(this[i]),n);
				if (n.indexOf(this[i]) == -1) n.push(this[i]);
			}
			return n;
		}
        array.unique()
```

---








